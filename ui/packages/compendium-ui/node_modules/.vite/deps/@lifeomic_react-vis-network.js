import {
  require_react_is
} from "./chunk-KVDXUF75.js";
import {
  require_react
} from "./chunk-RKYDPMON.js";
import {
  __commonJS
} from "./chunk-TFWDKVI3.js";

// ../../node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "../../node_modules/object-assign/index.js"(exports, module) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
          if (hasOwnProperty.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from, symbols[i])) {
              to[symbols[i]] = from[symbols[i]];
            }
          }
        }
      }
      return to;
    };
  }
});

// ../../node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  "../../node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module) {
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module.exports = ReactPropTypesSecret;
  }
});

// ../../node_modules/prop-types/lib/has.js
var require_has = __commonJS({
  "../../node_modules/prop-types/lib/has.js"(exports, module) {
    module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
  }
});

// ../../node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
  "../../node_modules/prop-types/checkPropTypes.js"(exports, module) {
    "use strict";
    var printWarning = function() {
    };
    if (true) {
      ReactPropTypesSecret = require_ReactPropTypesSecret();
      loggedTypeFailures = {};
      has = require_has();
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    var ReactPropTypesSecret;
    var loggedTypeFailures;
    var has;
    function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
      if (true) {
        for (var typeSpecName in typeSpecs) {
          if (has(typeSpecs, typeSpecName)) {
            var error;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err = Error(
                  (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                );
                err.name = "Invariant Violation";
                throw err;
              }
              error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
            } catch (ex) {
              error = ex;
            }
            if (error && !(error instanceof Error)) {
              printWarning(
                (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
              );
            }
            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
              loggedTypeFailures[error.message] = true;
              var stack = getStack ? getStack() : "";
              printWarning(
                "Failed " + location + " type: " + error.message + (stack != null ? stack : "")
              );
            }
          }
        }
      }
    }
    checkPropTypes.resetWarningCache = function() {
      if (true) {
        loggedTypeFailures = {};
      }
    };
    module.exports = checkPropTypes;
  }
});

// ../../node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = __commonJS({
  "../../node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module) {
    "use strict";
    var ReactIs = require_react_is();
    var assign = require_object_assign();
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    var has = require_has();
    var checkPropTypes = require_checkPropTypes();
    var printWarning = function() {
    };
    if (true) {
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    module.exports = function(isValidElement, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") {
          return iteratorFn;
        }
      }
      var ANONYMOUS = "<<anonymous>>";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bigint: createPrimitiveTypeChecker("bigint"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is(x, y) {
        if (x === y) {
          return x !== 0 || 1 / x === 1 / y;
        } else {
          return x !== x && y !== y;
        }
      }
      function PropTypeError(message, data) {
        this.message = message;
        this.data = data && typeof data === "object" ? data : {};
        this.stack = "";
      }
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate) {
        if (true) {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err = new Error(
                "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
              );
              err.name = "Invariant Violation";
              throw err;
            } else if (typeof console !== "undefined") {
              var cacheKey = componentName + ":" + propName;
              if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
              manualPropTypeWarningCount < 3) {
                printWarning(
                  "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                );
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
              }
              return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
            }
            return null;
          } else {
            return validate(props, propName, componentName, location, propFullName);
          }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError(
              "Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
              { expectedType }
            );
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
          }
          for (var i = 0; i < propValue.length; i++) {
            var error = typeChecker(propValue, i, componentName, location, propFullName + "[" + i + "]", ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!isValidElement(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!ReactIs.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (true) {
            if (arguments.length > 1) {
              printWarning(
                "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
              );
            } else {
              printWarning("Invalid argument supplied to oneOf, expected an array.");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          for (var i = 0; i < expectedValues.length; i++) {
            if (is(propValue, expectedValues[i])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
            var type = getPreciseType(value);
            if (type === "symbol") {
              return String(value);
            }
            return value;
          });
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
          }
          for (var key in propValue) {
            if (has(propValue, key)) {
              var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
          var checker = arrayOfTypeCheckers[i];
          if (typeof checker !== "function") {
            printWarning(
              "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i + "."
            );
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate(props, propName, componentName, location, propFullName) {
          var expectedTypes = [];
          for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
            var checker2 = arrayOfTypeCheckers[i2];
            var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
            if (checkerResult == null) {
              return null;
            }
            if (checkerResult.data && has(checkerResult.data, "expectedType")) {
              expectedTypes.push(checkerResult.data.expectedType);
            }
          }
          var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          if (!isNode(props[propName])) {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function invalidValidatorError(componentName, location, propFullName, key, type) {
        return new PropTypeError(
          (componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`."
        );
      }
      function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          var allKeys = assign({}, props[propName], shapeTypes);
          for (var key in allKeys) {
            var checker = shapeTypes[key];
            if (has(shapeTypes, key) && typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            if (!checker) {
              return new PropTypeError(
                "Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
              );
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function isNode(propValue) {
        switch (typeof propValue) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !propValue;
          case "object":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode);
            }
            if (propValue === null || isValidElement(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      function isSymbol(propType, propValue) {
        if (propType === "symbol") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue["@@toStringTag"] === "Symbol") {
          return true;
        }
        if (typeof Symbol === "function" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return "array";
        }
        if (propValue instanceof RegExp) {
          return "object";
        }
        if (isSymbol(propType, propValue)) {
          return "symbol";
        }
        return propType;
      }
      function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) {
          return "" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === "object") {
          if (propValue instanceof Date) {
            return "date";
          } else if (propValue instanceof RegExp) {
            return "regexp";
          }
        }
        return propType;
      }
      function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch (type) {
          case "array":
          case "object":
            return "an " + type;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + type;
          default:
            return type;
        }
      }
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});

// ../../node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  "../../node_modules/prop-types/index.js"(exports, module) {
    if (true) {
      ReactIs = require_react_is();
      throwOnDirectAccess = true;
      module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
    } else {
      module.exports = null();
    }
    var ReactIs;
    var throwOnDirectAccess;
  }
});

// ../../node_modules/vis/dist/vis-network.min.js
var require_vis_network_min = __commonJS({
  "../../node_modules/vis/dist/vis-network.min.js"(exports, module) {
    "use strict";
    !function(e, t) {
      "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.vis = t() : e.vis = t();
    }(exports, function() {
      return function(e) {
        function t(n) {
          if (i[n])
            return i[n].exports;
          var o = i[n] = { i: n, l: false, exports: {} };
          return e[n].call(o.exports, o, o.exports, t), o.l = true, o.exports;
        }
        var i = {};
        return t.m = e, t.c = i, t.d = function(e2, i2, n) {
          t.o(e2, i2) || Object.defineProperty(e2, i2, { configurable: false, enumerable: true, get: n });
        }, t.n = function(e2) {
          var i2 = e2 && e2.__esModule ? function() {
            return e2.default;
          } : function() {
            return e2;
          };
          return t.d(i2, "a", i2), i2;
        }, t.o = function(e2, t2) {
          return Object.prototype.hasOwnProperty.call(e2, t2);
        }, t.p = "", t(t.s = 83);
      }([function(e, t, i) {
        t.__esModule = true, t.default = function(e2, t2) {
          if (!(e2 instanceof t2))
            throw new TypeError("Cannot call a class as a function");
        };
      }, function(e, t, i) {
        t.__esModule = true;
        var n = i(127), o = function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }(n);
        t.default = function() {
          function e2(e3, t2) {
            for (var i2 = 0; i2 < t2.length; i2++) {
              var n2 = t2[i2];
              n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), (0, o.default)(e3, n2.key, n2);
            }
          }
          return function(t2, i2, n2) {
            return i2 && e2(t2.prototype, i2), n2 && e2(t2, n2), t2;
          };
        }();
      }, function(e, t, i) {
        e.exports = { default: i(143), __esModule: true };
      }, function(e, t, i) {
        t.__esModule = true;
        var n = i(7), o = function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }(n);
        t.default = function(e2, t2) {
          if (!e2)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return !t2 || "object" !== (void 0 === t2 ? "undefined" : (0, o.default)(t2)) && "function" != typeof t2 ? e2 : t2;
        };
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        t.__esModule = true;
        var o = i(145), s = n(o), r = i(30), a = n(r), d = i(7), h = n(d);
        t.default = function(e2, t2) {
          if ("function" != typeof t2 && null !== t2)
            throw new TypeError("Super expression must either be null or a function, not " + (void 0 === t2 ? "undefined" : (0, h.default)(t2)));
          e2.prototype = (0, a.default)(t2 && t2.prototype, { constructor: { value: e2, enumerable: false, writable: true, configurable: true } }), t2 && (s.default ? (0, s.default)(e2, t2) : e2.__proto__ = t2);
        };
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        function o(e2, t2, i2, n2) {
          var o2 = false;
          true === n2 && (o2 = null === t2[i2] && void 0 !== e2[i2]), o2 ? delete e2[i2] : e2[i2] = t2[i2];
        }
        var s = i(58), r = n(s), a = i(30), d = n(a), h = i(10), l = n(h), u = i(7), c = n(u), f = i(71), p = i(117);
        t.isNumber = function(e2) {
          return e2 instanceof Number || "number" == typeof e2;
        }, t.recursiveDOMDelete = function(e2) {
          if (e2)
            for (; true === e2.hasChildNodes(); )
              t.recursiveDOMDelete(e2.firstChild), e2.removeChild(e2.firstChild);
        }, t.giveRange = function(e2, t2, i2, n2) {
          if (t2 == e2)
            return 0.5;
          var o2 = 1 / (t2 - e2);
          return Math.max(0, (n2 - e2) * o2);
        }, t.isString = function(e2) {
          return e2 instanceof String || "string" == typeof e2;
        }, t.isDate = function(e2) {
          if (e2 instanceof Date)
            return true;
          if (t.isString(e2)) {
            if (v.exec(e2))
              return true;
            if (!isNaN(Date.parse(e2)))
              return true;
          }
          return false;
        }, t.randomUUID = function() {
          return p.v4();
        }, t.assignAllKeys = function(e2, t2) {
          for (var i2 in e2)
            e2.hasOwnProperty(i2) && "object" !== (0, c.default)(e2[i2]) && (e2[i2] = t2);
        }, t.fillIfDefined = function(e2, i2) {
          var n2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
          for (var s2 in e2)
            void 0 !== i2[s2] && (null === i2[s2] || "object" !== (0, c.default)(i2[s2]) ? o(e2, i2, s2, n2) : "object" === (0, c.default)(e2[s2]) && t.fillIfDefined(e2[s2], i2[s2], n2));
        }, t.extend = function(e2, t2) {
          for (var i2 = 1; i2 < arguments.length; i2++) {
            var n2 = arguments[i2];
            for (var o2 in n2)
              n2.hasOwnProperty(o2) && (e2[o2] = n2[o2]);
          }
          return e2;
        }, t.selectiveExtend = function(e2, t2, i2) {
          if (!Array.isArray(e2))
            throw new Error("Array with property names expected as first argument");
          for (var n2 = 2; n2 < arguments.length; n2++)
            for (var o2 = arguments[n2], s2 = 0; s2 < e2.length; s2++) {
              var r2 = e2[s2];
              o2 && o2.hasOwnProperty(r2) && (t2[r2] = o2[r2]);
            }
          return t2;
        }, t.selectiveDeepExtend = function(e2, i2, n2) {
          var s2 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
          if (Array.isArray(n2))
            throw new TypeError("Arrays are not supported by deepExtend");
          for (var r2 = 0; r2 < e2.length; r2++) {
            var a2 = e2[r2];
            if (n2.hasOwnProperty(a2))
              if (n2[a2] && n2[a2].constructor === Object)
                void 0 === i2[a2] && (i2[a2] = {}), i2[a2].constructor === Object ? t.deepExtend(i2[a2], n2[a2], false, s2) : o(i2, n2, a2, s2);
              else {
                if (Array.isArray(n2[a2]))
                  throw new TypeError("Arrays are not supported by deepExtend");
                o(i2, n2, a2, s2);
              }
          }
          return i2;
        }, t.selectiveNotDeepExtend = function(e2, i2, n2) {
          var s2 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
          if (Array.isArray(n2))
            throw new TypeError("Arrays are not supported by deepExtend");
          for (var r2 in n2)
            if (n2.hasOwnProperty(r2) && -1 === e2.indexOf(r2))
              if (n2[r2] && n2[r2].constructor === Object)
                void 0 === i2[r2] && (i2[r2] = {}), i2[r2].constructor === Object ? t.deepExtend(i2[r2], n2[r2]) : o(i2, n2, r2, s2);
              else if (Array.isArray(n2[r2])) {
                i2[r2] = [];
                for (var a2 = 0; a2 < n2[r2].length; a2++)
                  i2[r2].push(n2[r2][a2]);
              } else
                o(i2, n2, r2, s2);
          return i2;
        }, t.deepExtend = function(e2, i2) {
          var n2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], s2 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
          for (var r2 in i2)
            if (i2.hasOwnProperty(r2) || true === n2)
              if (i2[r2] && i2[r2].constructor === Object)
                void 0 === e2[r2] && (e2[r2] = {}), e2[r2].constructor === Object ? t.deepExtend(e2[r2], i2[r2], n2) : o(e2, i2, r2, s2);
              else if (Array.isArray(i2[r2])) {
                e2[r2] = [];
                for (var a2 = 0; a2 < i2[r2].length; a2++)
                  e2[r2].push(i2[r2][a2]);
              } else
                o(e2, i2, r2, s2);
          return e2;
        }, t.equalArray = function(e2, t2) {
          if (e2.length != t2.length)
            return false;
          for (var i2 = 0, n2 = e2.length; i2 < n2; i2++)
            if (e2[i2] != t2[i2])
              return false;
          return true;
        }, t.convert = function(e2, i2) {
          var n2;
          if (void 0 !== e2) {
            if (null === e2)
              return null;
            if (!i2)
              return e2;
            if ("string" != typeof i2 && !(i2 instanceof String))
              throw new Error("Type must be a string");
            switch (i2) {
              case "boolean":
              case "Boolean":
                return Boolean(e2);
              case "number":
              case "Number":
                return t.isString(e2) && !isNaN(Date.parse(e2)) ? f(e2).valueOf() : Number(e2.valueOf());
              case "string":
              case "String":
                return String(e2);
              case "Date":
                if (t.isNumber(e2))
                  return new Date(e2);
                if (e2 instanceof Date)
                  return new Date(e2.valueOf());
                if (f.isMoment(e2))
                  return new Date(e2.valueOf());
                if (t.isString(e2))
                  return n2 = v.exec(e2), n2 ? new Date(Number(n2[1])) : f(new Date(e2)).toDate();
                throw new Error("Cannot convert object of type " + t.getType(e2) + " to type Date");
              case "Moment":
                if (t.isNumber(e2))
                  return f(e2);
                if (e2 instanceof Date)
                  return f(e2.valueOf());
                if (f.isMoment(e2))
                  return f(e2);
                if (t.isString(e2))
                  return n2 = v.exec(e2), f(n2 ? Number(n2[1]) : e2);
                throw new Error("Cannot convert object of type " + t.getType(e2) + " to type Date");
              case "ISODate":
                if (t.isNumber(e2))
                  return new Date(e2);
                if (e2 instanceof Date)
                  return e2.toISOString();
                if (f.isMoment(e2))
                  return e2.toDate().toISOString();
                if (t.isString(e2))
                  return n2 = v.exec(e2), n2 ? new Date(Number(n2[1])).toISOString() : f(e2).format();
                throw new Error("Cannot convert object of type " + t.getType(e2) + " to type ISODate");
              case "ASPDate":
                if (t.isNumber(e2))
                  return "/Date(" + e2 + ")/";
                if (e2 instanceof Date)
                  return "/Date(" + e2.valueOf() + ")/";
                if (t.isString(e2)) {
                  n2 = v.exec(e2);
                  return "/Date(" + (n2 ? new Date(Number(n2[1])).valueOf() : new Date(e2).valueOf()) + ")/";
                }
                throw new Error("Cannot convert object of type " + t.getType(e2) + " to type ASPDate");
              default:
                throw new Error('Unknown type "' + i2 + '"');
            }
          }
        };
        var v = /^\/?Date\((\-?\d+)/i;
        t.getType = function(e2) {
          var t2 = void 0 === e2 ? "undefined" : (0, c.default)(e2);
          return "object" == t2 ? null === e2 ? "null" : e2 instanceof Boolean ? "Boolean" : e2 instanceof Number ? "Number" : e2 instanceof String ? "String" : Array.isArray(e2) ? "Array" : e2 instanceof Date ? "Date" : "Object" : "number" == t2 ? "Number" : "boolean" == t2 ? "Boolean" : "string" == t2 ? "String" : void 0 === t2 ? "undefined" : t2;
        }, t.copyAndExtendArray = function(e2, t2) {
          for (var i2 = [], n2 = 0; n2 < e2.length; n2++)
            i2.push(e2[n2]);
          return i2.push(t2), i2;
        }, t.copyArray = function(e2) {
          for (var t2 = [], i2 = 0; i2 < e2.length; i2++)
            t2.push(e2[i2]);
          return t2;
        }, t.getAbsoluteLeft = function(e2) {
          return e2.getBoundingClientRect().left;
        }, t.getAbsoluteRight = function(e2) {
          return e2.getBoundingClientRect().right;
        }, t.getAbsoluteTop = function(e2) {
          return e2.getBoundingClientRect().top;
        }, t.addClassName = function(e2, t2) {
          var i2 = e2.className.split(" "), n2 = t2.split(" ");
          i2 = i2.concat(n2.filter(function(e3) {
            return i2.indexOf(e3) < 0;
          })), e2.className = i2.join(" ");
        }, t.removeClassName = function(e2, t2) {
          var i2 = e2.className.split(" "), n2 = t2.split(" ");
          i2 = i2.filter(function(e3) {
            return n2.indexOf(e3) < 0;
          }), e2.className = i2.join(" ");
        }, t.forEach = function(e2, t2) {
          var i2, n2;
          if (Array.isArray(e2))
            for (i2 = 0, n2 = e2.length; i2 < n2; i2++)
              t2(e2[i2], i2, e2);
          else
            for (i2 in e2)
              e2.hasOwnProperty(i2) && t2(e2[i2], i2, e2);
        }, t.toArray = function(e2) {
          var t2 = [];
          for (var i2 in e2)
            e2.hasOwnProperty(i2) && t2.push(e2[i2]);
          return t2;
        }, t.updateProperty = function(e2, t2, i2) {
          return e2[t2] !== i2 && (e2[t2] = i2, true);
        }, t.throttle = function(e2) {
          var t2 = false;
          return function() {
            t2 || (t2 = true, requestAnimationFrame(function() {
              t2 = false, e2();
            }));
          };
        }, t.addEventListener = function(e2, t2, i2, n2) {
          e2.addEventListener ? (void 0 === n2 && (n2 = false), "mousewheel" === t2 && navigator.userAgent.indexOf("Firefox") >= 0 && (t2 = "DOMMouseScroll"), e2.addEventListener(t2, i2, n2)) : e2.attachEvent("on" + t2, i2);
        }, t.removeEventListener = function(e2, t2, i2, n2) {
          e2.removeEventListener ? (void 0 === n2 && (n2 = false), "mousewheel" === t2 && navigator.userAgent.indexOf("Firefox") >= 0 && (t2 = "DOMMouseScroll"), e2.removeEventListener(t2, i2, n2)) : e2.detachEvent("on" + t2, i2);
        }, t.preventDefault = function(e2) {
          e2 || (e2 = window.event), e2.preventDefault ? e2.preventDefault() : e2.returnValue = false;
        }, t.getTarget = function(e2) {
          e2 || (e2 = window.event);
          var t2;
          return e2.target ? t2 = e2.target : e2.srcElement && (t2 = e2.srcElement), void 0 != t2.nodeType && 3 == t2.nodeType && (t2 = t2.parentNode), t2;
        }, t.hasParent = function(e2, t2) {
          for (var i2 = e2; i2; ) {
            if (i2 === t2)
              return true;
            i2 = i2.parentNode;
          }
          return false;
        }, t.option = {}, t.option.asBoolean = function(e2, t2) {
          return "function" == typeof e2 && (e2 = e2()), null != e2 ? 0 != e2 : t2 || null;
        }, t.option.asNumber = function(e2, t2) {
          return "function" == typeof e2 && (e2 = e2()), null != e2 ? Number(e2) || t2 || null : t2 || null;
        }, t.option.asString = function(e2, t2) {
          return "function" == typeof e2 && (e2 = e2()), null != e2 ? String(e2) : t2 || null;
        }, t.option.asSize = function(e2, i2) {
          return "function" == typeof e2 && (e2 = e2()), t.isString(e2) ? e2 : t.isNumber(e2) ? e2 + "px" : i2 || null;
        }, t.option.asElement = function(e2, t2) {
          return "function" == typeof e2 && (e2 = e2()), e2 || t2 || null;
        }, t.hexToRGB = function(e2) {
          var t2 = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
          e2 = e2.replace(t2, function(e3, t3, i3, n2) {
            return t3 + t3 + i3 + i3 + n2 + n2;
          });
          var i2 = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e2);
          return i2 ? { r: parseInt(i2[1], 16), g: parseInt(i2[2], 16), b: parseInt(i2[3], 16) } : null;
        }, t.overrideOpacity = function(e2, i2) {
          var n2;
          return -1 != e2.indexOf("rgba") ? e2 : -1 != e2.indexOf("rgb") ? (n2 = e2.substr(e2.indexOf("(") + 1).replace(")", "").split(","), "rgba(" + n2[0] + "," + n2[1] + "," + n2[2] + "," + i2 + ")") : (n2 = t.hexToRGB(e2), null == n2 ? e2 : "rgba(" + n2.r + "," + n2.g + "," + n2.b + "," + i2 + ")");
        }, t.RGBToHex = function(e2, t2, i2) {
          return "#" + ((1 << 24) + (e2 << 16) + (t2 << 8) + i2).toString(16).slice(1);
        }, t.parseColor = function(e2) {
          var i2;
          if (true === t.isString(e2)) {
            if (true === t.isValidRGB(e2)) {
              var n2 = e2.substr(4).substr(0, e2.length - 5).split(",").map(function(e3) {
                return parseInt(e3);
              });
              e2 = t.RGBToHex(n2[0], n2[1], n2[2]);
            }
            if (true === t.isValidHex(e2)) {
              var o2 = t.hexToHSV(e2), s2 = { h: o2.h, s: 0.8 * o2.s, v: Math.min(1, 1.02 * o2.v) }, r2 = { h: o2.h, s: Math.min(1, 1.25 * o2.s), v: 0.8 * o2.v }, a2 = t.HSVToHex(r2.h, r2.s, r2.v), d2 = t.HSVToHex(s2.h, s2.s, s2.v);
              i2 = { background: e2, border: a2, highlight: { background: d2, border: a2 }, hover: { background: d2, border: a2 } };
            } else
              i2 = { background: e2, border: e2, highlight: { background: e2, border: e2 }, hover: { background: e2, border: e2 } };
          } else
            i2 = {}, i2.background = e2.background || void 0, i2.border = e2.border || void 0, t.isString(e2.highlight) ? i2.highlight = { border: e2.highlight, background: e2.highlight } : (i2.highlight = {}, i2.highlight.background = e2.highlight && e2.highlight.background || void 0, i2.highlight.border = e2.highlight && e2.highlight.border || void 0), t.isString(e2.hover) ? i2.hover = { border: e2.hover, background: e2.hover } : (i2.hover = {}, i2.hover.background = e2.hover && e2.hover.background || void 0, i2.hover.border = e2.hover && e2.hover.border || void 0);
          return i2;
        }, t.RGBToHSV = function(e2, t2, i2) {
          e2 /= 255, t2 /= 255, i2 /= 255;
          var n2 = Math.min(e2, Math.min(t2, i2)), o2 = Math.max(e2, Math.max(t2, i2));
          if (n2 == o2)
            return { h: 0, s: 0, v: n2 };
          var s2 = e2 == n2 ? t2 - i2 : i2 == n2 ? e2 - t2 : i2 - e2;
          return { h: 60 * ((e2 == n2 ? 3 : i2 == n2 ? 1 : 5) - s2 / (o2 - n2)) / 360, s: (o2 - n2) / o2, v: o2 };
        };
        var g = { split: function(e2) {
          var t2 = {};
          return e2.split(";").forEach(function(e3) {
            if ("" != e3.trim()) {
              var i2 = e3.split(":"), n2 = i2[0].trim(), o2 = i2[1].trim();
              t2[n2] = o2;
            }
          }), t2;
        }, join: function(e2) {
          return (0, l.default)(e2).map(function(t2) {
            return t2 + ": " + e2[t2];
          }).join("; ");
        } };
        t.addCssText = function(e2, i2) {
          var n2 = g.split(e2.style.cssText), o2 = g.split(i2), s2 = t.extend(n2, o2);
          e2.style.cssText = g.join(s2);
        }, t.removeCssText = function(e2, t2) {
          var i2 = g.split(e2.style.cssText), n2 = g.split(t2);
          for (var o2 in n2)
            n2.hasOwnProperty(o2) && delete i2[o2];
          e2.style.cssText = g.join(i2);
        }, t.HSVToRGB = function(e2, t2, i2) {
          var n2, o2, s2, r2 = Math.floor(6 * e2), a2 = 6 * e2 - r2, d2 = i2 * (1 - t2), h2 = i2 * (1 - a2 * t2), l2 = i2 * (1 - (1 - a2) * t2);
          switch (r2 % 6) {
            case 0:
              n2 = i2, o2 = l2, s2 = d2;
              break;
            case 1:
              n2 = h2, o2 = i2, s2 = d2;
              break;
            case 2:
              n2 = d2, o2 = i2, s2 = l2;
              break;
            case 3:
              n2 = d2, o2 = h2, s2 = i2;
              break;
            case 4:
              n2 = l2, o2 = d2, s2 = i2;
              break;
            case 5:
              n2 = i2, o2 = d2, s2 = h2;
          }
          return { r: Math.floor(255 * n2), g: Math.floor(255 * o2), b: Math.floor(255 * s2) };
        }, t.HSVToHex = function(e2, i2, n2) {
          var o2 = t.HSVToRGB(e2, i2, n2);
          return t.RGBToHex(o2.r, o2.g, o2.b);
        }, t.hexToHSV = function(e2) {
          var i2 = t.hexToRGB(e2);
          return t.RGBToHSV(i2.r, i2.g, i2.b);
        }, t.isValidHex = function(e2) {
          return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(e2);
        }, t.isValidRGB = function(e2) {
          return e2 = e2.replace(" ", ""), /rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/i.test(e2);
        }, t.isValidRGBA = function(e2) {
          return e2 = e2.replace(" ", ""), /rgba\((\d{1,3}),(\d{1,3}),(\d{1,3}),(.{1,3})\)/i.test(e2);
        }, t.selectiveBridgeObject = function(e2, i2) {
          if (null !== i2 && "object" === (void 0 === i2 ? "undefined" : (0, c.default)(i2))) {
            for (var n2 = (0, d.default)(i2), o2 = 0; o2 < e2.length; o2++)
              i2.hasOwnProperty(e2[o2]) && "object" == (0, c.default)(i2[e2[o2]]) && (n2[e2[o2]] = t.bridgeObject(i2[e2[o2]]));
            return n2;
          }
          return null;
        }, t.bridgeObject = function(e2) {
          if (null !== e2 && "object" === (void 0 === e2 ? "undefined" : (0, c.default)(e2))) {
            var i2 = (0, d.default)(e2);
            if (e2 instanceof Element)
              i2 = e2;
            else {
              i2 = (0, d.default)(e2);
              for (var n2 in e2)
                e2.hasOwnProperty(n2) && "object" == (0, c.default)(e2[n2]) && (i2[n2] = t.bridgeObject(e2[n2]));
            }
            return i2;
          }
          return null;
        }, t.insertSort = function(e2, t2) {
          for (var i2 = 0; i2 < e2.length; i2++) {
            for (var n2 = e2[i2], o2 = i2; o2 > 0 && t2(n2, e2[o2 - 1]) < 0; o2--)
              e2[o2] = e2[o2 - 1];
            e2[o2] = n2;
          }
          return e2;
        }, t.mergeOptions = function(e2, t2, i2) {
          var n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}, o2 = function(e3) {
            return null !== e3 && void 0 !== e3;
          }, s2 = function(e3) {
            return null !== e3 && "object" === (void 0 === e3 ? "undefined" : (0, c.default)(e3));
          };
          if (!s2(e2))
            throw new Error("Parameter mergeTarget must be an object");
          if (!s2(t2))
            throw new Error("Parameter options must be an object");
          if (!o2(i2))
            throw new Error("Parameter option must have a value");
          if (!s2(n2))
            throw new Error("Parameter globalOptions must be an object");
          var r2 = t2[i2], a2 = s2(n2) && !function(e3) {
            for (var t3 in e3)
              if (e3.hasOwnProperty(t3))
                return false;
            return true;
          }(n2), h2 = a2 ? n2[i2] : void 0, l2 = h2 ? h2.enabled : void 0;
          if (void 0 !== r2) {
            if ("boolean" == typeof r2)
              return s2(e2[i2]) || (e2[i2] = {}), void (e2[i2].enabled = r2);
            if (null === r2 && !s2(e2[i2])) {
              if (!o2(h2))
                return;
              e2[i2] = (0, d.default)(h2);
            }
            if (s2(r2)) {
              var u2 = true;
              void 0 !== r2.enabled ? u2 = r2.enabled : void 0 !== l2 && (u2 = h2.enabled), function(e3, t3, i3) {
                s2(e3[i3]) || (e3[i3] = {});
                var n3 = t3[i3], o3 = e3[i3];
                for (var r3 in n3)
                  n3.hasOwnProperty(r3) && (o3[r3] = n3[r3]);
              }(e2, t2, i2), e2[i2].enabled = u2;
            }
          }
        }, t.binarySearchCustom = function(e2, t2, i2, n2) {
          for (var o2 = 0, s2 = 0, r2 = e2.length - 1; s2 <= r2 && o2 < 1e4; ) {
            var a2 = Math.floor((s2 + r2) / 2), d2 = e2[a2], h2 = void 0 === n2 ? d2[i2] : d2[i2][n2], l2 = t2(h2);
            if (0 == l2)
              return a2;
            -1 == l2 ? s2 = a2 + 1 : r2 = a2 - 1, o2++;
          }
          return -1;
        }, t.binarySearchValue = function(e2, t2, i2, n2, o2) {
          var s2, r2, a2, d2, h2 = 0, l2 = 0, u2 = e2.length - 1;
          for (o2 = void 0 != o2 ? o2 : function(e3, t3) {
            return e3 == t3 ? 0 : e3 < t3 ? -1 : 1;
          }; l2 <= u2 && h2 < 1e4; ) {
            if (d2 = Math.floor(0.5 * (u2 + l2)), s2 = e2[Math.max(0, d2 - 1)][i2], r2 = e2[d2][i2], a2 = e2[Math.min(e2.length - 1, d2 + 1)][i2], 0 == o2(r2, t2))
              return d2;
            if (o2(s2, t2) < 0 && o2(r2, t2) > 0)
              return "before" == n2 ? Math.max(0, d2 - 1) : d2;
            if (o2(r2, t2) < 0 && o2(a2, t2) > 0)
              return "before" == n2 ? d2 : Math.min(e2.length - 1, d2 + 1);
            o2(r2, t2) < 0 ? l2 = d2 + 1 : u2 = d2 - 1, h2++;
          }
          return -1;
        }, t.easingFunctions = { linear: function(e2) {
          return e2;
        }, easeInQuad: function(e2) {
          return e2 * e2;
        }, easeOutQuad: function(e2) {
          return e2 * (2 - e2);
        }, easeInOutQuad: function(e2) {
          return e2 < 0.5 ? 2 * e2 * e2 : (4 - 2 * e2) * e2 - 1;
        }, easeInCubic: function(e2) {
          return e2 * e2 * e2;
        }, easeOutCubic: function(e2) {
          return --e2 * e2 * e2 + 1;
        }, easeInOutCubic: function(e2) {
          return e2 < 0.5 ? 4 * e2 * e2 * e2 : (e2 - 1) * (2 * e2 - 2) * (2 * e2 - 2) + 1;
        }, easeInQuart: function(e2) {
          return e2 * e2 * e2 * e2;
        }, easeOutQuart: function(e2) {
          return 1 - --e2 * e2 * e2 * e2;
        }, easeInOutQuart: function(e2) {
          return e2 < 0.5 ? 8 * e2 * e2 * e2 * e2 : 1 - 8 * --e2 * e2 * e2 * e2;
        }, easeInQuint: function(e2) {
          return e2 * e2 * e2 * e2 * e2;
        }, easeOutQuint: function(e2) {
          return 1 + --e2 * e2 * e2 * e2 * e2;
        }, easeInOutQuint: function(e2) {
          return e2 < 0.5 ? 16 * e2 * e2 * e2 * e2 * e2 : 1 + 16 * --e2 * e2 * e2 * e2 * e2;
        } }, t.getScrollBarWidth = function() {
          var e2 = document.createElement("p");
          e2.style.width = "100%", e2.style.height = "200px";
          var t2 = document.createElement("div");
          t2.style.position = "absolute", t2.style.top = "0px", t2.style.left = "0px", t2.style.visibility = "hidden", t2.style.width = "200px", t2.style.height = "150px", t2.style.overflow = "hidden", t2.appendChild(e2), document.body.appendChild(t2);
          var i2 = e2.offsetWidth;
          t2.style.overflow = "scroll";
          var n2 = e2.offsetWidth;
          return i2 == n2 && (n2 = t2.clientWidth), document.body.removeChild(t2), i2 - n2;
        }, t.topMost = function(e2, t2) {
          var i2 = void 0;
          Array.isArray(t2) || (t2 = [t2]);
          var n2 = true, o2 = false, s2 = void 0;
          try {
            for (var a2, d2 = (0, r.default)(e2); !(n2 = (a2 = d2.next()).done); n2 = true) {
              var h2 = a2.value;
              if (h2) {
                i2 = h2[t2[0]];
                for (var l2 = 1; l2 < t2.length; l2++)
                  i2 && (i2 = i2[t2[l2]]);
                if (void 0 !== i2)
                  break;
              }
            }
          } catch (e3) {
            o2 = true, s2 = e3;
          } finally {
            try {
              !n2 && d2.return && d2.return();
            } finally {
              if (o2)
                throw s2;
            }
          }
          return i2;
        };
      }, function(e, t) {
        var i = e.exports = { version: "2.5.1" };
        "number" == typeof __e && (__e = i);
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        t.__esModule = true;
        var o = i(102), s = n(o), r = i(104), a = n(r), d = "function" == typeof a.default && "symbol" == typeof s.default ? function(e2) {
          return typeof e2;
        } : function(e2) {
          return e2 && "function" == typeof a.default && e2.constructor === a.default && e2 !== a.default.prototype ? "symbol" : typeof e2;
        };
        t.default = "function" == typeof a.default && "symbol" === d(s.default) ? function(e2) {
          return void 0 === e2 ? "undefined" : d(e2);
        } : function(e2) {
          return e2 && "function" == typeof a.default && e2.constructor === a.default && e2 !== a.default.prototype ? "symbol" : void 0 === e2 ? "undefined" : d(e2);
        };
      }, function(e, t, i) {
        var n = i(44)("wks"), o = i(28), s = i(9).Symbol, r = "function" == typeof s;
        (e.exports = function(e2) {
          return n[e2] || (n[e2] = r && s[e2] || (r ? s : o)("Symbol." + e2));
        }).store = n;
      }, function(e, t) {
        var i = e.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();
        "number" == typeof __g && (__g = i);
      }, function(e, t, i) {
        e.exports = { default: i(100), __esModule: true };
      }, function(e, t, i) {
        var n = i(9), o = i(6), s = i(61), r = i(18), a = function(e2, t2, i2) {
          var d, h, l, u = e2 & a.F, c = e2 & a.G, f = e2 & a.S, p = e2 & a.P, v = e2 & a.B, g = e2 & a.W, y = c ? o : o[t2] || (o[t2] = {}), m = y.prototype, b = c ? n : f ? n[t2] : (n[t2] || {}).prototype;
          c && (i2 = t2);
          for (d in i2)
            (h = !u && b && void 0 !== b[d]) && d in y || (l = h ? b[d] : i2[d], y[d] = c && "function" != typeof b[d] ? i2[d] : v && h ? s(l, n) : g && b[d] == l ? function(e3) {
              var t3 = function(t4, i3, n2) {
                if (this instanceof e3) {
                  switch (arguments.length) {
                    case 0:
                      return new e3();
                    case 1:
                      return new e3(t4);
                    case 2:
                      return new e3(t4, i3);
                  }
                  return new e3(t4, i3, n2);
                }
                return e3.apply(this, arguments);
              };
              return t3.prototype = e3.prototype, t3;
            }(l) : p && "function" == typeof l ? s(Function.call, l) : l, p && ((y.virtual || (y.virtual = {}))[d] = l, e2 & a.R && m && !m[d] && r(m, d, l)));
        };
        a.F = 1, a.G = 2, a.S = 4, a.P = 8, a.B = 16, a.W = 32, a.U = 64, a.R = 128, e.exports = a;
      }, function(e, t, i) {
        var n = i(19), o = i(62), s = i(40), r = Object.defineProperty;
        t.f = i(13) ? Object.defineProperty : function(e2, t2, i2) {
          if (n(e2), t2 = s(t2, true), n(i2), o)
            try {
              return r(e2, t2, i2);
            } catch (e3) {
            }
          if ("get" in i2 || "set" in i2)
            throw TypeError("Accessors not supported!");
          return "value" in i2 && (e2[t2] = i2.value), e2;
        };
      }, function(e, t, i) {
        e.exports = !i(20)(function() {
          return 7 != Object.defineProperty({}, "a", { get: function() {
            return 7;
          } }).a;
        });
      }, function(e, t) {
        var i = {}.hasOwnProperty;
        e.exports = function(e2, t2) {
          return i.call(e2, t2);
        };
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(7), s = n(o), r = i(0), a = n(r), d = i(1), h = n(d), l = function() {
          function e2(t2, i2, n2) {
            (0, a.default)(this, e2), this.body = i2, this.labelModule = n2, this.setOptions(t2), this.top = void 0, this.left = void 0, this.height = void 0, this.width = void 0, this.radius = void 0, this.margin = void 0, this.refreshNeeded = true, this.boundingBox = { top: 0, left: 0, right: 0, bottom: 0 };
          }
          return (0, h.default)(e2, [{ key: "setOptions", value: function(e3) {
            this.options = e3;
          } }, { key: "_setMargins", value: function(e3) {
            this.margin = {}, this.options.margin && ("object" == (0, s.default)(this.options.margin) ? (this.margin.top = this.options.margin.top, this.margin.right = this.options.margin.right, this.margin.bottom = this.options.margin.bottom, this.margin.left = this.options.margin.left) : (this.margin.top = this.options.margin, this.margin.right = this.options.margin, this.margin.bottom = this.options.margin, this.margin.left = this.options.margin)), e3.adjustSizes(this.margin);
          } }, { key: "_distanceToBorder", value: function(e3, t2) {
            var i2 = this.options.borderWidth;
            return this.resize(e3), Math.min(Math.abs(this.width / 2 / Math.cos(t2)), Math.abs(this.height / 2 / Math.sin(t2))) + i2;
          } }, { key: "enableShadow", value: function(e3, t2) {
            t2.shadow && (e3.shadowColor = t2.shadowColor, e3.shadowBlur = t2.shadowSize, e3.shadowOffsetX = t2.shadowX, e3.shadowOffsetY = t2.shadowY);
          } }, { key: "disableShadow", value: function(e3, t2) {
            t2.shadow && (e3.shadowColor = "rgba(0,0,0,0)", e3.shadowBlur = 0, e3.shadowOffsetX = 0, e3.shadowOffsetY = 0);
          } }, { key: "enableBorderDashes", value: function(e3, t2) {
            if (false !== t2.borderDashes)
              if (void 0 !== e3.setLineDash) {
                var i2 = t2.borderDashes;
                true === i2 && (i2 = [5, 15]), e3.setLineDash(i2);
              } else
                console.warn("setLineDash is not supported in this browser. The dashed borders cannot be used."), this.options.shapeProperties.borderDashes = false, t2.borderDashes = false;
          } }, { key: "disableBorderDashes", value: function(e3, t2) {
            false !== t2.borderDashes && (void 0 !== e3.setLineDash ? e3.setLineDash([0]) : (console.warn("setLineDash is not supported in this browser. The dashed borders cannot be used."), this.options.shapeProperties.borderDashes = false, t2.borderDashes = false));
          } }, { key: "needsRefresh", value: function(e3, t2) {
            return true === this.refreshNeeded ? (this.refreshNeeded = false, true) : void 0 === this.width || this.labelModule.differentState(e3, t2);
          } }, { key: "initContextForDraw", value: function(e3, t2) {
            var i2 = t2.borderWidth / this.body.view.scale;
            e3.lineWidth = Math.min(this.width, i2), e3.strokeStyle = t2.borderColor, e3.fillStyle = t2.color;
          } }, { key: "performStroke", value: function(e3, t2) {
            var i2 = t2.borderWidth / this.body.view.scale;
            e3.save(), i2 > 0 && (this.enableBorderDashes(e3, t2), e3.stroke(), this.disableBorderDashes(e3, t2)), e3.restore();
          } }, { key: "performFill", value: function(e3, t2) {
            this.enableShadow(e3, t2), e3.fill(), this.disableShadow(e3, t2), this.performStroke(e3, t2);
          } }, { key: "_addBoundingBoxMargin", value: function(e3) {
            this.boundingBox.left -= e3, this.boundingBox.top -= e3, this.boundingBox.bottom += e3, this.boundingBox.right += e3;
          } }, { key: "_updateBoundingBox", value: function(e3, t2, i2, n2, o2) {
            void 0 !== i2 && this.resize(i2, n2, o2), this.left = e3 - this.width / 2, this.top = t2 - this.height / 2, this.boundingBox.left = this.left, this.boundingBox.top = this.top, this.boundingBox.bottom = this.top + this.height, this.boundingBox.right = this.left + this.width;
          } }, { key: "updateBoundingBox", value: function(e3, t2, i2, n2, o2) {
            this._updateBoundingBox(e3, t2, i2, n2, o2);
          } }, { key: "getDimensionsFromLabel", value: function(e3, t2, i2) {
            this.textSize = this.labelModule.getTextSize(e3, t2, i2);
            var n2 = this.textSize.width, o2 = this.textSize.height;
            return 0 === n2 && (n2 = 14, o2 = 14), { width: n2, height: o2 };
          } }]), e2;
        }();
        t.default = l;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(2), s = n(o), r = i(0), a = n(r), d = i(1), h = n(d), l = i(3), u = n(l), c = i(4), f = n(c), p = i(15), v = n(p), g = function(e2) {
          function t2(e3, i2, n2) {
            return (0, a.default)(this, t2), (0, u.default)(this, (t2.__proto__ || (0, s.default)(t2)).call(this, e3, i2, n2));
          }
          return (0, f.default)(t2, e2), (0, h.default)(t2, [{ key: "resize", value: function(e3) {
            var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.selected, i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.hover, n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : { size: this.options.size };
            if (this.needsRefresh(t3, i2)) {
              this.labelModule.getTextSize(e3, t3, i2);
              var o2 = 2 * n2.size;
              this.width = o2, this.height = o2, this.radius = 0.5 * this.width;
            }
          } }, { key: "_drawShape", value: function(e3, t3, i2, n2, o2, s2, r2, a2) {
            if (this.resize(e3, s2, r2, a2), this.left = n2 - this.width / 2, this.top = o2 - this.height / 2, this.initContextForDraw(e3, a2), e3[t3](n2, o2, a2.size), this.performFill(e3, a2), void 0 !== this.options.label) {
              this.labelModule.calculateLabelSize(e3, s2, r2, n2, o2, "hanging");
              var d2 = o2 + 0.5 * this.height + 0.5 * this.labelModule.size.height;
              this.labelModule.draw(e3, n2, d2, s2, r2, "hanging");
            }
            this.updateBoundingBox(n2, o2);
          } }, { key: "updateBoundingBox", value: function(e3, t3) {
            this.boundingBox.top = t3 - this.options.size, this.boundingBox.left = e3 - this.options.size, this.boundingBox.right = e3 + this.options.size, this.boundingBox.bottom = t3 + this.options.size, void 0 !== this.options.label && this.labelModule.size.width > 0 && (this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left), this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width), this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelModule.size.height));
          } }]), t2;
        }(v.default);
        t.default = g;
      }, function(e, t, i) {
        var n = i(59), o = i(38);
        e.exports = function(e2) {
          return n(o(e2));
        };
      }, function(e, t, i) {
        var n = i(12), o = i(27);
        e.exports = i(13) ? function(e2, t2, i2) {
          return n.f(e2, t2, o(1, i2));
        } : function(e2, t2, i2) {
          return e2[t2] = i2, e2;
        };
      }, function(e, t, i) {
        var n = i(25);
        e.exports = function(e2) {
          if (!n(e2))
            throw TypeError(e2 + " is not an object!");
          return e2;
        };
      }, function(e, t) {
        e.exports = function(e2) {
          try {
            return !!e2();
          } catch (e3) {
            return true;
          }
        };
      }, function(e, t, i) {
        e.exports = { default: i(120), __esModule: true };
      }, function(e, t, i) {
        function n() {
          var e2 = function() {
          };
          return { on: e2, off: e2, destroy: e2, emit: e2, get: function(t2) {
            return { set: e2 };
          } };
        }
        if ("undefined" != typeof window) {
          var o = i(124), s = window.Hammer || i(125);
          e.exports = o(s, { preventDefault: "mouse" });
        } else
          e.exports = function() {
            return n();
          };
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        t.__esModule = true;
        var o = i(133), s = n(o), r = i(58), a = n(r);
        t.default = function() {
          function e2(e3, t2) {
            var i2 = [], n2 = true, o2 = false, s2 = void 0;
            try {
              for (var r2, d = (0, a.default)(e3); !(n2 = (r2 = d.next()).done) && (i2.push(r2.value), !t2 || i2.length !== t2); n2 = true)
                ;
            } catch (e4) {
              o2 = true, s2 = e4;
            } finally {
              try {
                !n2 && d.return && d.return();
              } finally {
                if (o2)
                  throw s2;
              }
            }
            return i2;
          }
          return function(t2, i2) {
            if (Array.isArray(t2))
              return t2;
            if ((0, s.default)(Object(t2)))
              return e2(t2, i2);
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          };
        }();
      }, function(e, t) {
        e.exports = {};
      }, function(e, t) {
        e.exports = function(e2) {
          return "object" == typeof e2 ? null !== e2 : "function" == typeof e2;
        };
      }, function(e, t, i) {
        var n = i(65), o = i(45);
        e.exports = Object.keys || function(e2) {
          return n(e2, o);
        };
      }, function(e, t) {
        e.exports = function(e2, t2) {
          return { enumerable: !(1 & e2), configurable: !(2 & e2), writable: !(4 & e2), value: t2 };
        };
      }, function(e, t) {
        var i = 0, n = Math.random();
        e.exports = function(e2) {
          return "Symbol(".concat(void 0 === e2 ? "" : e2, ")_", (++i + n).toString(36));
        };
      }, function(e, t, i) {
        var n = i(38);
        e.exports = function(e2) {
          return Object(n(e2));
        };
      }, function(e, t, i) {
        e.exports = { default: i(98), __esModule: true };
      }, function(e, t) {
        t.f = {}.propertyIsEnumerable;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        function o(e2, t2) {
          if (e2 && !Array.isArray(e2) && (t2 = e2, e2 = null), this._options = t2 || {}, this._data = {}, this.length = 0, this._fieldId = this._options.fieldId || "id", this._type = {}, this._options.type)
            for (var i2 = (0, l.default)(this._options.type), n2 = 0, o2 = i2.length; n2 < o2; n2++) {
              var s2 = i2[n2], r2 = this._options.type[s2];
              this._type[s2] = "Date" == r2 || "ISODate" == r2 || "ASPDate" == r2 ? "Date" : r2;
            }
          this._subscribers = {}, e2 && this.add(e2), this.setOptions(t2);
        }
        var s = i(21), r = n(s), a = i(7), d = n(a), h = i(10), l = n(h), u = i(5), c = i(72);
        o.prototype.setOptions = function(e2) {
          e2 && void 0 !== e2.queue && (false === e2.queue ? this._queue && (this._queue.destroy(), delete this._queue) : (this._queue || (this._queue = c.extend(this, { replace: ["add", "update", "remove"] })), "object" === (0, d.default)(e2.queue) && this._queue.setOptions(e2.queue)));
        }, o.prototype.on = function(e2, t2) {
          var i2 = this._subscribers[e2];
          i2 || (i2 = [], this._subscribers[e2] = i2), i2.push({ callback: t2 });
        }, o.prototype.off = function(e2, t2) {
          var i2 = this._subscribers[e2];
          i2 && (this._subscribers[e2] = i2.filter(function(e3) {
            return e3.callback != t2;
          }));
        }, o.prototype._trigger = function(e2, t2, i2) {
          if ("*" == e2)
            throw new Error("Cannot trigger event *");
          var n2 = [];
          e2 in this._subscribers && (n2 = n2.concat(this._subscribers[e2])), "*" in this._subscribers && (n2 = n2.concat(this._subscribers["*"]));
          for (var o2 = 0, s2 = n2.length; o2 < s2; o2++) {
            var r2 = n2[o2];
            r2.callback && r2.callback(e2, t2, i2 || null);
          }
        }, o.prototype.add = function(e2, t2) {
          var i2, n2 = [], o2 = this;
          if (Array.isArray(e2))
            for (var s2 = 0, r2 = e2.length; s2 < r2; s2++)
              i2 = o2._addItem(e2[s2]), n2.push(i2);
          else {
            if (!e2 || "object" !== (void 0 === e2 ? "undefined" : (0, d.default)(e2)))
              throw new Error("Unknown dataType");
            i2 = o2._addItem(e2), n2.push(i2);
          }
          return n2.length && this._trigger("add", { items: n2 }, t2), n2;
        }, o.prototype.update = function(e2, t2) {
          var i2 = [], n2 = [], o2 = [], s2 = [], r2 = this, a2 = r2._fieldId, h2 = function(e3) {
            var t3 = e3[a2];
            if (r2._data[t3]) {
              var d2 = u.extend({}, r2._data[t3]);
              t3 = r2._updateItem(e3), n2.push(t3), s2.push(e3), o2.push(d2);
            } else
              t3 = r2._addItem(e3), i2.push(t3);
          };
          if (Array.isArray(e2))
            for (var l2 = 0, c2 = e2.length; l2 < c2; l2++)
              e2[l2] && "object" === (0, d.default)(e2[l2]) ? h2(e2[l2]) : console.warn("Ignoring input item, which is not an object at index " + l2);
          else {
            if (!e2 || "object" !== (void 0 === e2 ? "undefined" : (0, d.default)(e2)))
              throw new Error("Unknown dataType");
            h2(e2);
          }
          if (i2.length && this._trigger("add", { items: i2 }, t2), n2.length) {
            var f = { items: n2, oldData: o2, data: s2 };
            this._trigger("update", f, t2);
          }
          return i2.concat(n2);
        }, o.prototype.get = function(e2) {
          var t2, i2, n2, o2 = this, s2 = u.getType(arguments[0]);
          "String" == s2 || "Number" == s2 ? (t2 = arguments[0], n2 = arguments[1]) : "Array" == s2 ? (i2 = arguments[0], n2 = arguments[1]) : n2 = arguments[0];
          var r2;
          if (n2 && n2.returnType) {
            r2 = -1 == ["Array", "Object"].indexOf(n2.returnType) ? "Array" : n2.returnType;
          } else
            r2 = "Array";
          var a2, d2, h2, c2, f, p = n2 && n2.type || this._options.type, v = n2 && n2.filter, g = [];
          if (void 0 != t2)
            (a2 = o2._getItem(t2, p)) && v && !v(a2) && (a2 = null);
          else if (void 0 != i2)
            for (c2 = 0, f = i2.length; c2 < f; c2++)
              a2 = o2._getItem(i2[c2], p), v && !v(a2) || g.push(a2);
          else
            for (d2 = (0, l.default)(this._data), c2 = 0, f = d2.length; c2 < f; c2++)
              h2 = d2[c2], a2 = o2._getItem(h2, p), v && !v(a2) || g.push(a2);
          if (n2 && n2.order && void 0 == t2 && this._sort(g, n2.order), n2 && n2.fields) {
            var y = n2.fields;
            if (void 0 != t2)
              a2 = this._filterFields(a2, y);
            else
              for (c2 = 0, f = g.length; c2 < f; c2++)
                g[c2] = this._filterFields(g[c2], y);
          }
          if ("Object" == r2) {
            var m, b = {};
            for (c2 = 0, f = g.length; c2 < f; c2++)
              m = g[c2], b[m.id] = m;
            return b;
          }
          return void 0 != t2 ? a2 : g;
        }, o.prototype.getIds = function(e2) {
          var t2, i2, n2, o2, s2, r2 = this._data, a2 = e2 && e2.filter, d2 = e2 && e2.order, h2 = e2 && e2.type || this._options.type, u2 = (0, l.default)(r2), c2 = [];
          if (a2)
            if (d2) {
              for (s2 = [], t2 = 0, i2 = u2.length; t2 < i2; t2++)
                n2 = u2[t2], o2 = this._getItem(n2, h2), a2(o2) && s2.push(o2);
              for (this._sort(s2, d2), t2 = 0, i2 = s2.length; t2 < i2; t2++)
                c2.push(s2[t2][this._fieldId]);
            } else
              for (t2 = 0, i2 = u2.length; t2 < i2; t2++)
                n2 = u2[t2], o2 = this._getItem(n2, h2), a2(o2) && c2.push(o2[this._fieldId]);
          else if (d2) {
            for (s2 = [], t2 = 0, i2 = u2.length; t2 < i2; t2++)
              n2 = u2[t2], s2.push(r2[n2]);
            for (this._sort(s2, d2), t2 = 0, i2 = s2.length; t2 < i2; t2++)
              c2.push(s2[t2][this._fieldId]);
          } else
            for (t2 = 0, i2 = u2.length; t2 < i2; t2++)
              n2 = u2[t2], o2 = r2[n2], c2.push(o2[this._fieldId]);
          return c2;
        }, o.prototype.getDataSet = function() {
          return this;
        }, o.prototype.forEach = function(e2, t2) {
          var i2, n2, o2, s2, r2 = t2 && t2.filter, a2 = t2 && t2.type || this._options.type, d2 = this._data, h2 = (0, l.default)(d2);
          if (t2 && t2.order) {
            var u2 = this.get(t2);
            for (i2 = 0, n2 = u2.length; i2 < n2; i2++)
              o2 = u2[i2], s2 = o2[this._fieldId], e2(o2, s2);
          } else
            for (i2 = 0, n2 = h2.length; i2 < n2; i2++)
              s2 = h2[i2], o2 = this._getItem(s2, a2), r2 && !r2(o2) || e2(o2, s2);
        }, o.prototype.map = function(e2, t2) {
          var i2, n2, o2, s2, r2 = t2 && t2.filter, a2 = t2 && t2.type || this._options.type, d2 = [], h2 = this._data, u2 = (0, l.default)(h2);
          for (i2 = 0, n2 = u2.length; i2 < n2; i2++)
            o2 = u2[i2], s2 = this._getItem(o2, a2), r2 && !r2(s2) || d2.push(e2(s2, o2));
          return t2 && t2.order && this._sort(d2, t2.order), d2;
        }, o.prototype._filterFields = function(e2, t2) {
          if (!e2)
            return e2;
          var i2, n2, o2 = {}, s2 = (0, l.default)(e2), r2 = s2.length;
          if (Array.isArray(t2))
            for (i2 = 0; i2 < r2; i2++)
              n2 = s2[i2], -1 != t2.indexOf(n2) && (o2[n2] = e2[n2]);
          else
            for (i2 = 0; i2 < r2; i2++)
              n2 = s2[i2], t2.hasOwnProperty(n2) && (o2[t2[n2]] = e2[n2]);
          return o2;
        }, o.prototype._sort = function(e2, t2) {
          if (u.isString(t2)) {
            var i2 = t2;
            e2.sort(function(e3, t3) {
              var n2 = e3[i2], o2 = t3[i2];
              return n2 > o2 ? 1 : n2 < o2 ? -1 : 0;
            });
          } else {
            if ("function" != typeof t2)
              throw new TypeError("Order must be a function or a string");
            e2.sort(t2);
          }
        }, o.prototype.remove = function(e2, t2) {
          var i2, n2, o2, s2, r2 = [], a2 = [], d2 = [];
          for (d2 = Array.isArray(e2) ? e2 : [e2], i2 = 0, n2 = d2.length; i2 < n2; i2++)
            (s2 = this._remove(d2[i2])) && void 0 != (o2 = s2[this._fieldId]) && (r2.push(o2), a2.push(s2));
          return r2.length && this._trigger("remove", { items: r2, oldData: a2 }, t2), r2;
        }, o.prototype._remove = function(e2) {
          var t2, i2;
          return u.isNumber(e2) || u.isString(e2) ? i2 = e2 : e2 && "object" === (void 0 === e2 ? "undefined" : (0, d.default)(e2)) && (i2 = e2[this._fieldId]), void 0 !== i2 && this._data[i2] ? (t2 = this._data[i2], delete this._data[i2], this.length--, t2) : null;
        }, o.prototype.clear = function(e2) {
          var t2, i2, n2 = (0, l.default)(this._data), o2 = [];
          for (t2 = 0, i2 = n2.length; t2 < i2; t2++)
            o2.push(this._data[n2[t2]]);
          return this._data = {}, this.length = 0, this._trigger("remove", { items: n2, oldData: o2 }, e2), n2;
        }, o.prototype.max = function(e2) {
          var t2, i2, n2 = this._data, o2 = (0, l.default)(n2), s2 = null, r2 = null;
          for (t2 = 0, i2 = o2.length; t2 < i2; t2++) {
            var a2 = o2[t2], d2 = n2[a2], h2 = d2[e2];
            null != h2 && (!s2 || h2 > r2) && (s2 = d2, r2 = h2);
          }
          return s2;
        }, o.prototype.min = function(e2) {
          var t2, i2, n2 = this._data, o2 = (0, l.default)(n2), s2 = null, r2 = null;
          for (t2 = 0, i2 = o2.length; t2 < i2; t2++) {
            var a2 = o2[t2], d2 = n2[a2], h2 = d2[e2];
            null != h2 && (!s2 || h2 < r2) && (s2 = d2, r2 = h2);
          }
          return s2;
        }, o.prototype.distinct = function(e2) {
          var t2, i2, n2, o2 = this._data, s2 = (0, l.default)(o2), r2 = [], a2 = this._options.type && this._options.type[e2] || null, d2 = 0;
          for (t2 = 0, n2 = s2.length; t2 < n2; t2++) {
            var h2 = s2[t2], c2 = o2[h2], f = c2[e2], p = false;
            for (i2 = 0; i2 < d2; i2++)
              if (r2[i2] == f) {
                p = true;
                break;
              }
            p || void 0 === f || (r2[d2] = f, d2++);
          }
          if (a2)
            for (t2 = 0, n2 = r2.length; t2 < n2; t2++)
              r2[t2] = u.convert(r2[t2], a2);
          return r2;
        }, o.prototype._addItem = function(e2) {
          var t2 = e2[this._fieldId];
          if (void 0 != t2) {
            if (this._data[t2])
              throw new Error("Cannot add item: item with id " + t2 + " already exists");
          } else
            t2 = u.randomUUID(), e2[this._fieldId] = t2;
          var i2, n2, o2 = {}, s2 = (0, l.default)(e2);
          for (i2 = 0, n2 = s2.length; i2 < n2; i2++) {
            var r2 = s2[i2], a2 = this._type[r2];
            o2[r2] = u.convert(e2[r2], a2);
          }
          return this._data[t2] = o2, this.length++, t2;
        }, o.prototype._getItem = function(e2, t2) {
          var i2, n2, o2, s2, r2 = this._data[e2];
          if (!r2)
            return null;
          var a2 = {}, d2 = (0, l.default)(r2);
          if (t2)
            for (o2 = 0, s2 = d2.length; o2 < s2; o2++)
              i2 = d2[o2], n2 = r2[i2], a2[i2] = u.convert(n2, t2[i2]);
          else
            for (o2 = 0, s2 = d2.length; o2 < s2; o2++)
              i2 = d2[o2], n2 = r2[i2], a2[i2] = n2;
          return a2[this._fieldId] || (a2[this._fieldId] = r2.id), a2;
        }, o.prototype._updateItem = function(e2) {
          var t2 = e2[this._fieldId];
          if (void 0 == t2)
            throw new Error("Cannot update item: item has no id (item: " + (0, r.default)(e2) + ")");
          var i2 = this._data[t2];
          if (!i2)
            throw new Error("Cannot update item: no item with id " + t2 + " found");
          for (var n2 = (0, l.default)(e2), o2 = 0, s2 = n2.length; o2 < s2; o2++) {
            var a2 = n2[o2], d2 = this._type[a2];
            i2[a2] = u.convert(e2[a2], d2);
          }
          return t2;
        }, e.exports = o;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(0), s = n(o), r = i(1), a = n(r), d = i(5), h = i(77).default, l = i(34).default, u = i(142).default, c = i(149).default, f = i(150).default, p = i(151).default, v = i(152).default, g = i(153).default, y = i(154).default, m = i(155).default, b = i(156).default, _ = i(157).default, w = i(158).default, k = i(159).default, x = i(160).default, O = i(161).default, M = i(162).default, E = i(54), S = E.printStyle, D = function() {
          function e2(t2, i2, n2, o2, r2, a2) {
            (0, s.default)(this, e2), this.options = d.bridgeObject(r2), this.globalOptions = r2, this.defaultOptions = a2, this.body = i2, this.edges = [], this.id = void 0, this.imagelist = n2, this.grouplist = o2, this.x = void 0, this.y = void 0, this.baseSize = this.options.size, this.baseFontSize = this.options.font.size, this.predefinedPosition = false, this.selected = false, this.hover = false, this.labelModule = new h(this.body, this.options, false), this.setOptions(t2);
          }
          return (0, a.default)(e2, [{ key: "attachEdge", value: function(e3) {
            -1 === this.edges.indexOf(e3) && this.edges.push(e3);
          } }, { key: "detachEdge", value: function(e3) {
            var t2 = this.edges.indexOf(e3);
            -1 != t2 && this.edges.splice(t2, 1);
          } }, { key: "setOptions", value: function(t2) {
            var i2 = this.options.shape;
            if (t2) {
              if (void 0 !== t2.id && (this.id = t2.id), void 0 === this.id)
                throw new Error("Node must have an id");
              e2.checkMass(t2, this.id), void 0 !== t2.x && (null === t2.x ? (this.x = void 0, this.predefinedPosition = false) : (this.x = parseInt(t2.x), this.predefinedPosition = true)), void 0 !== t2.y && (null === t2.y ? (this.y = void 0, this.predefinedPosition = false) : (this.y = parseInt(t2.y), this.predefinedPosition = true)), void 0 !== t2.size && (this.baseSize = t2.size), void 0 !== t2.value && (t2.value = parseFloat(t2.value)), e2.parseOptions(this.options, t2, true, this.globalOptions, this.grouplist);
              var n2 = [t2, this.options, this.defaultOptions];
              return this.chooser = l.choosify("node", n2), this._load_images(), this.updateLabelModule(t2), this.updateShape(i2), void 0 !== t2.hidden || void 0 !== t2.physics;
            }
          } }, { key: "_load_images", value: function() {
            if ("circularImage" === this.options.shape || "image" === this.options.shape) {
              if (void 0 === this.options.image)
                throw new Error("Option image must be defined for node type '" + this.options.shape + "'");
              if (void 0 === this.imagelist)
                throw new Error("Internal Error: No images provided");
              if ("string" == typeof this.options.image)
                this.imageObj = this.imagelist.load(this.options.image, this.options.brokenImage, this.id);
              else {
                if (void 0 === this.options.image.unselected)
                  throw new Error("No unselected image provided");
                this.imageObj = this.imagelist.load(this.options.image.unselected, this.options.brokenImage, this.id), void 0 !== this.options.image.selected ? this.imageObjAlt = this.imagelist.load(this.options.image.selected, this.options.brokenImage, this.id) : this.imageObjAlt = void 0;
              }
            }
          } }, { key: "getFormattingValues", value: function() {
            var e3 = { color: this.options.color.background, borderWidth: this.options.borderWidth, borderColor: this.options.color.border, size: this.options.size, borderDashes: this.options.shapeProperties.borderDashes, borderRadius: this.options.shapeProperties.borderRadius, shadow: this.options.shadow.enabled, shadowColor: this.options.shadow.color, shadowSize: this.options.shadow.size, shadowX: this.options.shadow.x, shadowY: this.options.shadow.y };
            return this.selected || this.hover ? true === this.chooser ? this.selected ? (e3.borderWidth *= 2, e3.color = this.options.color.highlight.background, e3.borderColor = this.options.color.highlight.border, e3.shadow = this.options.shadow.enabled) : this.hover && (e3.color = this.options.color.hover.background, e3.borderColor = this.options.color.hover.border, e3.shadow = this.options.shadow.enabled) : "function" == typeof this.chooser && (this.chooser(e3, this.options.id, this.selected, this.hover), false === e3.shadow && (e3.shadowColor === this.options.shadow.color && e3.shadowSize === this.options.shadow.size && e3.shadowX === this.options.shadow.x && e3.shadowY === this.options.shadow.y || (e3.shadow = true))) : e3.shadow = this.options.shadow.enabled, e3;
          } }, { key: "updateLabelModule", value: function(t2) {
            void 0 !== this.options.label && null !== this.options.label || (this.options.label = ""), e2.updateGroupOptions(this.options, t2, this.grouplist);
            var i2 = this.grouplist.get(this.options.group, false), n2 = [t2, this.options, i2, this.globalOptions, this.defaultOptions];
            this.labelModule.update(this.options, n2), void 0 !== this.labelModule.baseSize && (this.baseFontSize = this.labelModule.baseSize);
          } }, { key: "updateShape", value: function(e3) {
            if (e3 === this.options.shape && this.shape)
              this.shape.setOptions(this.options, this.imageObj, this.imageObjAlt);
            else
              switch (this.options.shape) {
                case "box":
                  this.shape = new u(this.options, this.body, this.labelModule);
                  break;
                case "circle":
                  this.shape = new c(this.options, this.body, this.labelModule);
                  break;
                case "circularImage":
                  this.shape = new f(this.options, this.body, this.labelModule, this.imageObj, this.imageObjAlt);
                  break;
                case "database":
                  this.shape = new p(this.options, this.body, this.labelModule);
                  break;
                case "diamond":
                  this.shape = new v(this.options, this.body, this.labelModule);
                  break;
                case "dot":
                  this.shape = new g(this.options, this.body, this.labelModule);
                  break;
                case "ellipse":
                  this.shape = new y(this.options, this.body, this.labelModule);
                  break;
                case "icon":
                  this.shape = new m(this.options, this.body, this.labelModule);
                  break;
                case "image":
                  this.shape = new b(this.options, this.body, this.labelModule, this.imageObj, this.imageObjAlt);
                  break;
                case "square":
                  this.shape = new _(this.options, this.body, this.labelModule);
                  break;
                case "hexagon":
                  this.shape = new w(this.options, this.body, this.labelModule);
                  break;
                case "star":
                  this.shape = new k(this.options, this.body, this.labelModule);
                  break;
                case "text":
                  this.shape = new x(this.options, this.body, this.labelModule);
                  break;
                case "triangle":
                  this.shape = new O(this.options, this.body, this.labelModule);
                  break;
                case "triangleDown":
                  this.shape = new M(this.options, this.body, this.labelModule);
                  break;
                default:
                  this.shape = new y(this.options, this.body, this.labelModule);
              }
            this.needsRefresh();
          } }, { key: "select", value: function() {
            this.selected = true, this.needsRefresh();
          } }, { key: "unselect", value: function() {
            this.selected = false, this.needsRefresh();
          } }, { key: "needsRefresh", value: function() {
            this.shape.refreshNeeded = true;
          } }, { key: "getTitle", value: function() {
            return this.options.title;
          } }, { key: "distanceToBorder", value: function(e3, t2) {
            return this.shape.distanceToBorder(e3, t2);
          } }, { key: "isFixed", value: function() {
            return this.options.fixed.x && this.options.fixed.y;
          } }, { key: "isSelected", value: function() {
            return this.selected;
          } }, { key: "getValue", value: function() {
            return this.options.value;
          } }, { key: "getLabelSize", value: function() {
            return this.labelModule.size();
          } }, { key: "setValueRange", value: function(e3, t2, i2) {
            if (void 0 !== this.options.value) {
              var n2 = this.options.scaling.customScalingFunction(e3, t2, i2, this.options.value), o2 = this.options.scaling.max - this.options.scaling.min;
              if (true === this.options.scaling.label.enabled) {
                var s2 = this.options.scaling.label.max - this.options.scaling.label.min;
                this.options.font.size = this.options.scaling.label.min + n2 * s2;
              }
              this.options.size = this.options.scaling.min + n2 * o2;
            } else
              this.options.size = this.baseSize, this.options.font.size = this.baseFontSize;
            this.updateLabelModule();
          } }, { key: "draw", value: function(e3) {
            var t2 = this.getFormattingValues();
            this.shape.draw(e3, this.x, this.y, this.selected, this.hover, t2);
          } }, { key: "updateBoundingBox", value: function(e3) {
            this.shape.updateBoundingBox(this.x, this.y, e3);
          } }, { key: "resize", value: function(e3) {
            var t2 = this.getFormattingValues();
            this.shape.resize(e3, this.selected, this.hover, t2);
          } }, { key: "getItemsOnPoint", value: function(e3) {
            var t2 = [];
            return this.labelModule.visible() && l.pointInRect(this.labelModule.getSize(), e3) && t2.push({ nodeId: this.id, labelId: 0 }), l.pointInRect(this.shape.boundingBox, e3) && t2.push({ nodeId: this.id }), t2;
          } }, { key: "isOverlappingWith", value: function(e3) {
            return this.shape.left < e3.right && this.shape.left + this.shape.width > e3.left && this.shape.top < e3.bottom && this.shape.top + this.shape.height > e3.top;
          } }, { key: "isBoundingBoxOverlappingWith", value: function(e3) {
            return this.shape.boundingBox.left < e3.right && this.shape.boundingBox.right > e3.left && this.shape.boundingBox.top < e3.bottom && this.shape.boundingBox.bottom > e3.top;
          } }], [{ key: "updateGroupOptions", value: function(e3, t2, i2) {
            if (void 0 !== i2) {
              var n2 = e3.group;
              if (void 0 !== t2 && void 0 !== t2.group && n2 !== t2.group)
                throw new Error("updateGroupOptions: group values in options don't match.");
              if ("number" == typeof n2 || "string" == typeof n2 && "" != n2) {
                var o2 = i2.get(n2);
                d.selectiveNotDeepExtend(["font"], e3, o2), e3.color = d.parseColor(e3.color);
              }
            }
          } }, { key: "parseOptions", value: function(t2, i2) {
            var n2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], o2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}, s2 = arguments[4], r2 = ["color", "fixed", "shadow"];
            if (d.selectiveNotDeepExtend(r2, t2, i2, n2), e2.checkMass(i2), d.mergeOptions(t2, i2, "shadow", o2), void 0 !== i2.color && null !== i2.color) {
              var a2 = d.parseColor(i2.color);
              d.fillIfDefined(t2.color, a2);
            } else
              true === n2 && null === i2.color && (t2.color = d.bridgeObject(o2.color));
            void 0 !== i2.fixed && null !== i2.fixed && ("boolean" == typeof i2.fixed ? (t2.fixed.x = i2.fixed, t2.fixed.y = i2.fixed) : (void 0 !== i2.fixed.x && "boolean" == typeof i2.fixed.x && (t2.fixed.x = i2.fixed.x), void 0 !== i2.fixed.y && "boolean" == typeof i2.fixed.y && (t2.fixed.y = i2.fixed.y))), true === n2 && null === i2.font && (t2.font = d.bridgeObject(o2.font)), e2.updateGroupOptions(t2, i2, s2), void 0 !== i2.scaling && d.mergeOptions(t2.scaling, i2.scaling, "label", o2.scaling);
          } }, { key: "checkMass", value: function(e3, t2) {
            if (void 0 !== e3.mass && e3.mass <= 0) {
              var i2 = "";
              void 0 !== t2 && (i2 = " in node id: " + t2), console.log("%cNegative or zero mass disallowed" + i2 + ", setting mass to 1.", S), e3.mass = 1;
            }
          } }]), e2;
        }();
        t.default = D;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(7), s = n(o), r = i(0), a = n(r), d = i(1), h = n(d), l = i(5), u = function() {
          function e2() {
            (0, a.default)(this, e2);
          }
          return (0, h.default)(e2, null, [{ key: "choosify", value: function(e3, t2) {
            var i2 = ["node", "edge", "label"], n2 = true, o2 = l.topMost(t2, "chosen");
            if ("boolean" == typeof o2)
              n2 = o2;
            else if ("object" === (void 0 === o2 ? "undefined" : (0, s.default)(o2))) {
              if (-1 === i2.indexOf(e3))
                throw new Error("choosify: subOption '" + e3 + "' should be one of '" + i2.join("', '") + "'");
              var r2 = l.topMost(t2, ["chosen", e3]);
              "boolean" != typeof r2 && "function" != typeof r2 || (n2 = r2);
            }
            return n2;
          } }, { key: "pointInRect", value: function(e3, t2, i2) {
            if (e3.width <= 0 || e3.height <= 0)
              return false;
            if (void 0 !== i2) {
              var n2 = { x: t2.x - i2.x, y: t2.y - i2.y };
              if (0 !== i2.angle) {
                var o2 = -i2.angle;
                t2 = { x: Math.cos(o2) * n2.x - Math.sin(o2) * n2.y, y: Math.sin(o2) * n2.x + Math.cos(o2) * n2.y };
              } else
                t2 = n2;
            }
            var s2 = e3.x + e3.width, r2 = e3.y + e3.width;
            return e3.left < t2.x && s2 > t2.x && e3.top < t2.y && r2 > t2.y;
          } }, { key: "isValidLabel", value: function(e3) {
            return "string" == typeof e3 && "" !== e3;
          } }]), e2;
        }();
        t.default = u;
      }, function(e, t, i) {
        t.onTouch = function(e2, t2) {
          t2.inputHandler = function(e3) {
            e3.isFirst && t2(e3);
          }, e2.on("hammer.input", t2.inputHandler);
        }, t.onRelease = function(e2, t2) {
          return t2.inputHandler = function(e3) {
            e3.isFinal && t2(e3);
          }, e2.on("hammer.input", t2.inputHandler);
        }, t.offTouch = function(e2, t2) {
          e2.off("hammer.input", t2.inputHandler);
        }, t.offRelease = t.offTouch, t.disablePreventDefaultVertically = function(e2) {
          return e2.getTouchAction = function() {
            return ["pan-y"];
          }, e2;
        };
      }, function(e, t, i) {
        i(85);
        for (var n = i(9), o = i(18), s = i(24), r = i(8)("toStringTag"), a = "CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList".split(","), d = 0; d < a.length; d++) {
          var h = a[d], l = n[h], u = l && l.prototype;
          u && !u[r] && o(u, r, h), s[h] = s.Array;
        }
      }, function(e, t) {
        var i = {}.toString;
        e.exports = function(e2) {
          return i.call(e2).slice(8, -1);
        };
      }, function(e, t) {
        e.exports = function(e2) {
          if (void 0 == e2)
            throw TypeError("Can't call method on  " + e2);
          return e2;
        };
      }, function(e, t) {
        e.exports = true;
      }, function(e, t, i) {
        var n = i(25);
        e.exports = function(e2, t2) {
          if (!n(e2))
            return e2;
          var i2, o;
          if (t2 && "function" == typeof (i2 = e2.toString) && !n(o = i2.call(e2)))
            return o;
          if ("function" == typeof (i2 = e2.valueOf) && !n(o = i2.call(e2)))
            return o;
          if (!t2 && "function" == typeof (i2 = e2.toString) && !n(o = i2.call(e2)))
            return o;
          throw TypeError("Can't convert object to primitive value");
        };
      }, function(e, t, i) {
        var n = i(19), o = i(90), s = i(45), r = i(43)("IE_PROTO"), a = function() {
        }, d = function() {
          var e2, t2 = i(63)("iframe"), n2 = s.length;
          for (t2.style.display = "none", i(94).appendChild(t2), t2.src = "javascript:", e2 = t2.contentWindow.document, e2.open(), e2.write("<script>document.F=Object<\/script>"), e2.close(), d = e2.F; n2--; )
            delete d.prototype[s[n2]];
          return d();
        };
        e.exports = Object.create || function(e2, t2) {
          var i2;
          return null !== e2 ? (a.prototype = n(e2), i2 = new a(), a.prototype = null, i2[r] = e2) : i2 = d(), void 0 === t2 ? i2 : o(i2, t2);
        };
      }, function(e, t) {
        var i = Math.ceil, n = Math.floor;
        e.exports = function(e2) {
          return isNaN(e2 = +e2) ? 0 : (e2 > 0 ? n : i)(e2);
        };
      }, function(e, t, i) {
        var n = i(44)("keys"), o = i(28);
        e.exports = function(e2) {
          return n[e2] || (n[e2] = o(e2));
        };
      }, function(e, t, i) {
        var n = i(9), o = n["__core-js_shared__"] || (n["__core-js_shared__"] = {});
        e.exports = function(e2) {
          return o[e2] || (o[e2] = {});
        };
      }, function(e, t) {
        e.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
      }, function(e, t, i) {
        var n = i(12).f, o = i(14), s = i(8)("toStringTag");
        e.exports = function(e2, t2, i2) {
          e2 && !o(e2 = i2 ? e2 : e2.prototype, s) && n(e2, s, { configurable: true, value: t2 });
        };
      }, function(e, t, i) {
        var n = i(95)(true);
        i(60)(String, "String", function(e2) {
          this._t = String(e2), this._i = 0;
        }, function() {
          var e2, t2 = this._t, i2 = this._i;
          return i2 >= t2.length ? { value: void 0, done: true } : (e2 = n(t2, i2), this._i += e2.length, { value: e2, done: false });
        });
      }, function(e, t, i) {
        t.f = i(8);
      }, function(e, t, i) {
        var n = i(9), o = i(6), s = i(39), r = i(48), a = i(12).f;
        e.exports = function(e2) {
          var t2 = o.Symbol || (o.Symbol = s ? {} : n.Symbol || {});
          "_" == e2.charAt(0) || e2 in t2 || a(t2, e2, { value: r.f(e2) });
        };
      }, function(e, t) {
        t.f = Object.getOwnPropertySymbols;
      }, function(e, t, i) {
        function n(e2, t2) {
          this._data = null, this._ids = {}, this.length = 0, this._options = t2 || {}, this._fieldId = "id", this._subscribers = {};
          var i2 = this;
          this.listener = function() {
            i2._onEvent.apply(i2, arguments);
          }, this.setData(e2);
        }
        var o = i(10), s = function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }(o), r = i(5), a = i(32);
        n.prototype.setData = function(e2) {
          var t2, i2, n2, o2, s2;
          if (this._data) {
            for (this._data.off && this._data.off("*", this.listener), t2 = this._data.getIds({ filter: this._options && this._options.filter }), s2 = [], n2 = 0, o2 = t2.length; n2 < o2; n2++)
              s2.push(this._data._data[t2[n2]]);
            this._ids = {}, this.length = 0, this._trigger("remove", { items: t2, oldData: s2 });
          }
          if (this._data = e2, this._data) {
            for (this._fieldId = this._options.fieldId || this._data && this._data.options && this._data.options.fieldId || "id", t2 = this._data.getIds({ filter: this._options && this._options.filter }), n2 = 0, o2 = t2.length; n2 < o2; n2++)
              i2 = t2[n2], this._ids[i2] = true;
            this.length = t2.length, this._trigger("add", { items: t2 }), this._data.on && this._data.on("*", this.listener);
          }
        }, n.prototype.refresh = function() {
          var e2, t2, i2, n2 = this._data.getIds({ filter: this._options && this._options.filter }), o2 = (0, s.default)(this._ids), r2 = {}, a2 = [], d = [], h = [];
          for (t2 = 0, i2 = n2.length; t2 < i2; t2++)
            e2 = n2[t2], r2[e2] = true, this._ids[e2] || (a2.push(e2), this._ids[e2] = true);
          for (t2 = 0, i2 = o2.length; t2 < i2; t2++)
            e2 = o2[t2], r2[e2] || (d.push(e2), h.push(this._data._data[e2]), delete this._ids[e2]);
          this.length += a2.length - d.length, a2.length && this._trigger("add", { items: a2 }), d.length && this._trigger("remove", { items: d, oldData: h });
        }, n.prototype.get = function(e2) {
          var t2, i2, n2, o2 = this, s2 = r.getType(arguments[0]);
          "String" == s2 || "Number" == s2 || "Array" == s2 ? (t2 = arguments[0], i2 = arguments[1], n2 = arguments[2]) : (i2 = arguments[0], n2 = arguments[1]);
          var a2 = r.extend({}, this._options, i2);
          this._options.filter && i2 && i2.filter && (a2.filter = function(e3) {
            return o2._options.filter(e3) && i2.filter(e3);
          });
          var d = [];
          return void 0 != t2 && d.push(t2), d.push(a2), d.push(n2), this._data && this._data.get.apply(this._data, d);
        }, n.prototype.getIds = function(e2) {
          var t2;
          if (this._data) {
            var i2, n2 = this._options.filter;
            i2 = e2 && e2.filter ? n2 ? function(t3) {
              return n2(t3) && e2.filter(t3);
            } : e2.filter : n2, t2 = this._data.getIds({ filter: i2, order: e2 && e2.order });
          } else
            t2 = [];
          return t2;
        }, n.prototype.map = function(e2, t2) {
          var i2 = [];
          if (this._data) {
            var n2, o2 = this._options.filter;
            n2 = t2 && t2.filter ? o2 ? function(e3) {
              return o2(e3) && t2.filter(e3);
            } : t2.filter : o2, i2 = this._data.map(e2, { filter: n2, order: t2 && t2.order });
          } else
            i2 = [];
          return i2;
        }, n.prototype.getDataSet = function() {
          for (var e2 = this; e2 instanceof n; )
            e2 = e2._data;
          return e2 || null;
        }, n.prototype._onEvent = function(e2, t2, i2) {
          var n2, o2, s2, r2, a2 = t2 && t2.items, d = [], h = [], l = [], u = [], c = [], f = [];
          if (a2 && this._data) {
            switch (e2) {
              case "add":
                for (n2 = 0, o2 = a2.length; n2 < o2; n2++)
                  s2 = a2[n2], (r2 = this.get(s2)) && (this._ids[s2] = true, d.push(s2));
                break;
              case "update":
                for (n2 = 0, o2 = a2.length; n2 < o2; n2++)
                  s2 = a2[n2], r2 = this.get(s2), r2 ? this._ids[s2] ? (h.push(s2), c.push(t2.data[n2]), u.push(t2.oldData[n2])) : (this._ids[s2] = true, d.push(s2)) : this._ids[s2] && (delete this._ids[s2], l.push(s2), f.push(t2.oldData[n2]));
                break;
              case "remove":
                for (n2 = 0, o2 = a2.length; n2 < o2; n2++)
                  s2 = a2[n2], this._ids[s2] && (delete this._ids[s2], l.push(s2), f.push(t2.oldData[n2]));
            }
            this.length += d.length - l.length, d.length && this._trigger("add", { items: d }, i2), h.length && this._trigger("update", { items: h, oldData: u, data: c }, i2), l.length && this._trigger("remove", { items: l, oldData: f }, i2);
          }
        }, n.prototype.on = a.prototype.on, n.prototype.off = a.prototype.off, n.prototype._trigger = a.prototype._trigger, n.prototype.subscribe = n.prototype.on, n.prototype.unsubscribe = n.prototype.off, e.exports = n;
      }, function(e, t, i) {
        var n, o, s;
        !function(i2, r) {
          o = [], n = r, void 0 !== (s = "function" == typeof n ? n.apply(t, o) : n) && (e.exports = s);
        }(0, function() {
          function e2(e3) {
            var t2, i2 = e3 && e3.preventDefault || false, n2 = e3 && e3.container || window, o2 = {}, s2 = { keydown: {}, keyup: {} }, r = {};
            for (t2 = 97; t2 <= 122; t2++)
              r[String.fromCharCode(t2)] = { code: t2 - 97 + 65, shift: false };
            for (t2 = 65; t2 <= 90; t2++)
              r[String.fromCharCode(t2)] = { code: t2, shift: true };
            for (t2 = 0; t2 <= 9; t2++)
              r["" + t2] = { code: 48 + t2, shift: false };
            for (t2 = 1; t2 <= 12; t2++)
              r["F" + t2] = { code: 111 + t2, shift: false };
            for (t2 = 0; t2 <= 9; t2++)
              r["num" + t2] = { code: 96 + t2, shift: false };
            r["num*"] = { code: 106, shift: false }, r["num+"] = { code: 107, shift: false }, r["num-"] = { code: 109, shift: false }, r["num/"] = { code: 111, shift: false }, r["num."] = { code: 110, shift: false }, r.left = { code: 37, shift: false }, r.up = { code: 38, shift: false }, r.right = { code: 39, shift: false }, r.down = { code: 40, shift: false }, r.space = { code: 32, shift: false }, r.enter = { code: 13, shift: false }, r.shift = { code: 16, shift: void 0 }, r.esc = { code: 27, shift: false }, r.backspace = { code: 8, shift: false }, r.tab = { code: 9, shift: false }, r.ctrl = { code: 17, shift: false }, r.alt = { code: 18, shift: false }, r.delete = { code: 46, shift: false }, r.pageup = { code: 33, shift: false }, r.pagedown = { code: 34, shift: false }, r["="] = { code: 187, shift: false }, r["-"] = { code: 189, shift: false }, r["]"] = { code: 221, shift: false }, r["["] = { code: 219, shift: false };
            var a = function(e4) {
              h(e4, "keydown");
            }, d = function(e4) {
              h(e4, "keyup");
            }, h = function(e4, t3) {
              if (void 0 !== s2[t3][e4.keyCode]) {
                for (var n3 = s2[t3][e4.keyCode], o3 = 0; o3 < n3.length; o3++)
                  void 0 === n3[o3].shift ? n3[o3].fn(e4) : 1 == n3[o3].shift && 1 == e4.shiftKey ? n3[o3].fn(e4) : 0 == n3[o3].shift && 0 == e4.shiftKey && n3[o3].fn(e4);
                1 == i2 && e4.preventDefault();
              }
            };
            return o2.bind = function(e4, t3, i3) {
              if (void 0 === i3 && (i3 = "keydown"), void 0 === r[e4])
                throw new Error("unsupported key: " + e4);
              void 0 === s2[i3][r[e4].code] && (s2[i3][r[e4].code] = []), s2[i3][r[e4].code].push({ fn: t3, shift: r[e4].shift });
            }, o2.bindAll = function(e4, t3) {
              void 0 === t3 && (t3 = "keydown");
              for (var i3 in r)
                r.hasOwnProperty(i3) && o2.bind(i3, e4, t3);
            }, o2.getKey = function(e4) {
              for (var t3 in r)
                if (r.hasOwnProperty(t3)) {
                  if (1 == e4.shiftKey && 1 == r[t3].shift && e4.keyCode == r[t3].code)
                    return t3;
                  if (0 == e4.shiftKey && 0 == r[t3].shift && e4.keyCode == r[t3].code)
                    return t3;
                  if (e4.keyCode == r[t3].code && "shift" == t3)
                    return t3;
                }
              return "unknown key, currently not supported";
            }, o2.unbind = function(e4, t3, i3) {
              if (void 0 === i3 && (i3 = "keydown"), void 0 === r[e4])
                throw new Error("unsupported key: " + e4);
              if (void 0 !== t3) {
                var n3 = [], o3 = s2[i3][r[e4].code];
                if (void 0 !== o3)
                  for (var a2 = 0; a2 < o3.length; a2++)
                    o3[a2].fn == t3 && o3[a2].shift == r[e4].shift || n3.push(s2[i3][r[e4].code][a2]);
                s2[i3][r[e4].code] = n3;
              } else
                s2[i3][r[e4].code] = [];
            }, o2.reset = function() {
              s2 = { keydown: {}, keyup: {} };
            }, o2.destroy = function() {
              s2 = { keydown: {}, keyup: {} }, n2.removeEventListener("keydown", a, true), n2.removeEventListener("keyup", d, true);
            }, n2.addEventListener("keydown", a, true), n2.addEventListener("keyup", d, true), o2;
          }
          return e2;
        });
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(2), s = n(o), r = i(0), a = n(r), d = i(1), h = n(d), l = i(3), u = n(l), c = i(4), f = n(c), p = i(15), v = n(p), g = function(e2) {
          function t2(e3, i2, n2) {
            (0, a.default)(this, t2);
            var o2 = (0, u.default)(this, (t2.__proto__ || (0, s.default)(t2)).call(this, e3, i2, n2));
            return o2.labelOffset = 0, o2.selected = false, o2;
          }
          return (0, f.default)(t2, e2), (0, h.default)(t2, [{ key: "setOptions", value: function(e3, t3, i2) {
            this.options = e3, void 0 === t3 && void 0 === i2 || this.setImages(t3, i2);
          } }, { key: "setImages", value: function(e3, t3) {
            t3 && this.selected ? (this.imageObj = t3, this.imageObjAlt = e3) : (this.imageObj = e3, this.imageObjAlt = t3);
          } }, { key: "switchImages", value: function(e3) {
            var t3 = e3 && !this.selected || !e3 && this.selected;
            if (this.selected = e3, void 0 !== this.imageObjAlt && t3) {
              var i2 = this.imageObj;
              this.imageObj = this.imageObjAlt, this.imageObjAlt = i2;
            }
          } }, { key: "_resizeImage", value: function() {
            var e3, t3;
            if (false === this.options.shapeProperties.useImageSize) {
              var i2 = 1, n2 = 1;
              this.imageObj.width && this.imageObj.height && (this.imageObj.width > this.imageObj.height ? i2 = this.imageObj.width / this.imageObj.height : n2 = this.imageObj.height / this.imageObj.width), e3 = 2 * this.options.size * i2, t3 = 2 * this.options.size * n2;
            } else
              e3 = this.imageObj.width, t3 = this.imageObj.height;
            this.width = e3, this.height = t3, this.radius = 0.5 * this.width;
          } }, { key: "_drawRawCircle", value: function(e3, t3, i2, n2) {
            this.initContextForDraw(e3, n2), e3.circle(t3, i2, n2.size), this.performFill(e3, n2);
          } }, { key: "_drawImageAtPosition", value: function(e3, t3) {
            if (0 != this.imageObj.width) {
              e3.globalAlpha = 1, this.enableShadow(e3, t3);
              var i2 = 1;
              true === this.options.shapeProperties.interpolation && (i2 = this.imageObj.width / this.width / this.body.view.scale), this.imageObj.drawImageAtPosition(e3, i2, this.left, this.top, this.width, this.height), this.disableShadow(e3, t3);
            }
          } }, { key: "_drawImageLabel", value: function(e3, t3, i2, n2, o2) {
            var s2, r2 = 0;
            if (void 0 !== this.height) {
              r2 = 0.5 * this.height;
              var a2 = this.labelModule.getTextSize(e3, n2, o2);
              a2.lineCount >= 1 && (r2 += a2.height / 2);
            }
            s2 = i2 + r2, this.options.label && (this.labelOffset = r2), this.labelModule.draw(e3, t3, s2, n2, o2, "hanging");
          } }]), t2;
        }(v.default);
        t.default = g;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true }), t.printStyle = void 0;
        var o = i(21), s = n(o), r = i(7), a = n(r), d = i(10), h = n(d), l = i(0), u = n(l), c = i(1), f = n(c), p = i(5), v = false, g = void 0, y = "background: #FFeeee; color: #dd0000", m = function() {
          function e2() {
            (0, u.default)(this, e2);
          }
          return (0, f.default)(e2, null, [{ key: "validate", value: function(t2, i2, n2) {
            v = false, g = i2;
            var o2 = i2;
            return void 0 !== n2 && (o2 = i2[n2]), e2.parse(t2, o2, []), v;
          } }, { key: "parse", value: function(t2, i2, n2) {
            for (var o2 in t2)
              t2.hasOwnProperty(o2) && e2.check(o2, t2, i2, n2);
          } }, { key: "check", value: function(t2, i2, n2, o2) {
            if (void 0 === n2[t2] && void 0 === n2.__any__)
              return void e2.getSuggestion(t2, n2, o2);
            var s2 = t2, r2 = true;
            void 0 === n2[t2] && void 0 !== n2.__any__ && (s2 = "__any__", r2 = "object" === e2.getType(i2[t2]));
            var a2 = n2[s2];
            r2 && void 0 !== a2.__type__ && (a2 = a2.__type__), e2.checkFields(t2, i2, n2, s2, a2, o2);
          } }, { key: "checkFields", value: function(t2, i2, n2, o2, s2, r2) {
            var a2 = function(i3) {
              console.log("%c" + i3 + e2.printLocation(r2, t2), y);
            }, d2 = e2.getType(i2[t2]), l2 = s2[d2];
            void 0 !== l2 ? "array" === e2.getType(l2) && -1 === l2.indexOf(i2[t2]) ? (a2('Invalid option detected in "' + t2 + '". Allowed values are:' + e2.print(l2) + ' not "' + i2[t2] + '". '), v = true) : "object" === d2 && "__any__" !== o2 && (r2 = p.copyAndExtendArray(r2, t2), e2.parse(i2[t2], n2[o2], r2)) : void 0 === s2.any && (a2('Invalid type received for "' + t2 + '". Expected: ' + e2.print((0, h.default)(s2)) + ". Received [" + d2 + '] "' + i2[t2] + '"'), v = true);
          } }, { key: "getType", value: function(e3) {
            var t2 = void 0 === e3 ? "undefined" : (0, a.default)(e3);
            return "object" === t2 ? null === e3 ? "null" : e3 instanceof Boolean ? "boolean" : e3 instanceof Number ? "number" : e3 instanceof String ? "string" : Array.isArray(e3) ? "array" : e3 instanceof Date ? "date" : void 0 !== e3.nodeType ? "dom" : true === e3._isAMomentObject ? "moment" : "object" : "number" === t2 ? "number" : "boolean" === t2 ? "boolean" : "string" === t2 ? "string" : void 0 === t2 ? "undefined" : t2;
          } }, { key: "getSuggestion", value: function(t2, i2, n2) {
            var o2 = e2.findInOptions(t2, i2, n2, false), s2 = e2.findInOptions(t2, g, [], true), r2 = void 0;
            r2 = void 0 !== o2.indexMatch ? " in " + e2.printLocation(o2.path, t2, "") + 'Perhaps it was incomplete? Did you mean: "' + o2.indexMatch + '"?\n\n' : s2.distance <= 4 && o2.distance > s2.distance ? " in " + e2.printLocation(o2.path, t2, "") + "Perhaps it was misplaced? Matching option found at: " + e2.printLocation(s2.path, s2.closestMatch, "") : o2.distance <= 8 ? '. Did you mean "' + o2.closestMatch + '"?' + e2.printLocation(o2.path, t2) : ". Did you mean one of these: " + e2.print((0, h.default)(i2)) + e2.printLocation(n2, t2), console.log('%cUnknown option detected: "' + t2 + '"' + r2, y), v = true;
          } }, { key: "findInOptions", value: function(t2, i2, n2) {
            var o2 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], s2 = 1e9, r2 = "", a2 = [], d2 = t2.toLowerCase(), h2 = void 0;
            for (var l2 in i2) {
              var u2 = void 0;
              if (void 0 !== i2[l2].__type__ && true === o2) {
                var c2 = e2.findInOptions(t2, i2[l2], p.copyAndExtendArray(n2, l2));
                s2 > c2.distance && (r2 = c2.closestMatch, a2 = c2.path, s2 = c2.distance, h2 = c2.indexMatch);
              } else
                -1 !== l2.toLowerCase().indexOf(d2) && (h2 = l2), u2 = e2.levenshteinDistance(t2, l2), s2 > u2 && (r2 = l2, a2 = p.copyArray(n2), s2 = u2);
            }
            return { closestMatch: r2, path: a2, distance: s2, indexMatch: h2 };
          } }, { key: "printLocation", value: function(e3, t2) {
            for (var i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "Problem value found at: \n", n2 = "\n\n" + i2 + "options = {\n", o2 = 0; o2 < e3.length; o2++) {
              for (var s2 = 0; s2 < o2 + 1; s2++)
                n2 += "  ";
              n2 += e3[o2] + ": {\n";
            }
            for (var r2 = 0; r2 < e3.length + 1; r2++)
              n2 += "  ";
            n2 += t2 + "\n";
            for (var a2 = 0; a2 < e3.length + 1; a2++) {
              for (var d2 = 0; d2 < e3.length - a2; d2++)
                n2 += "  ";
              n2 += "}\n";
            }
            return n2 + "\n\n";
          } }, { key: "print", value: function(e3) {
            return (0, s.default)(e3).replace(/(\")|(\[)|(\])|(,"__type__")/g, "").replace(/(\,)/g, ", ");
          } }, { key: "levenshteinDistance", value: function(e3, t2) {
            if (0 === e3.length)
              return t2.length;
            if (0 === t2.length)
              return e3.length;
            var i2, n2 = [];
            for (i2 = 0; i2 <= t2.length; i2++)
              n2[i2] = [i2];
            var o2;
            for (o2 = 0; o2 <= e3.length; o2++)
              n2[0][o2] = o2;
            for (i2 = 1; i2 <= t2.length; i2++)
              for (o2 = 1; o2 <= e3.length; o2++)
                t2.charAt(i2 - 1) == e3.charAt(o2 - 1) ? n2[i2][o2] = n2[i2 - 1][o2 - 1] : n2[i2][o2] = Math.min(n2[i2 - 1][o2 - 1] + 1, Math.min(n2[i2][o2 - 1] + 1, n2[i2 - 1][o2] + 1));
            return n2[t2.length][e3.length];
          } }]), e2;
        }();
        t.default = m, t.printStyle = y;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(21), s = n(o), r = i(7), a = n(r), d = i(30), h = n(d), l = i(0), u = n(l), c = i(1), f = n(c), p = i(5), v = i(77).default, g = i(34).default, y = i(164).default, m = i(166).default, b = i(167).default, _ = i(168).default, w = function() {
          function e2(t2, i2, n2, o2) {
            if ((0, u.default)(this, e2), void 0 === i2)
              throw new Error("No body provided");
            this.options = p.bridgeObject(n2), this.globalOptions = n2, this.defaultOptions = o2, this.body = i2, this.id = void 0, this.fromId = void 0, this.toId = void 0, this.selected = false, this.hover = false, this.labelDirty = true, this.baseWidth = this.options.width, this.baseFontSize = this.options.font.size, this.from = void 0, this.to = void 0, this.edgeType = void 0, this.connected = false, this.labelModule = new v(this.body, this.options, true), this.setOptions(t2);
          }
          return (0, f.default)(e2, [{ key: "setOptions", value: function(t2) {
            if (t2) {
              e2.parseOptions(this.options, t2, true, this.globalOptions), void 0 !== t2.id && (this.id = t2.id), void 0 !== t2.from && (this.fromId = t2.from), void 0 !== t2.to && (this.toId = t2.to), void 0 !== t2.title && (this.title = t2.title), void 0 !== t2.value && (t2.value = parseFloat(t2.value));
              var i2 = [t2, this.options, this.defaultOptions];
              this.chooser = g.choosify("edge", i2), this.updateLabelModule(t2);
              var n2 = this.updateEdgeType();
              return this._setInteractionWidths(), this.connect(), void 0 === t2.hidden && void 0 === t2.physics || (n2 = true), n2;
            }
          } }, { key: "getFormattingValues", value: function() {
            var e3 = true === this.options.arrows.to || true === this.options.arrows.to.enabled, t2 = true === this.options.arrows.from || true === this.options.arrows.from.enabled, i2 = true === this.options.arrows.middle || true === this.options.arrows.middle.enabled, n2 = this.options.color.inherit, o2 = { toArrow: e3, toArrowScale: this.options.arrows.to.scaleFactor, toArrowType: this.options.arrows.to.type, middleArrow: i2, middleArrowScale: this.options.arrows.middle.scaleFactor, middleArrowType: this.options.arrows.middle.type, fromArrow: t2, fromArrowScale: this.options.arrows.from.scaleFactor, fromArrowType: this.options.arrows.from.type, arrowStrikethrough: this.options.arrowStrikethrough, color: n2 ? void 0 : this.options.color.color, inheritsColor: n2, opacity: this.options.color.opacity, hidden: this.options.hidden, length: this.options.length, shadow: this.options.shadow.enabled, shadowColor: this.options.shadow.color, shadowSize: this.options.shadow.size, shadowX: this.options.shadow.x, shadowY: this.options.shadow.y, dashes: this.options.dashes, width: this.options.width };
            if (this.selected || this.hover)
              if (true === this.chooser) {
                if (this.selected) {
                  var s2 = this.options.selectionWidth;
                  "function" == typeof s2 ? o2.width = s2(o2.width) : "number" == typeof s2 && (o2.width += s2), o2.width = Math.max(o2.width, 0.3 / this.body.view.scale), o2.color = this.options.color.highlight, o2.shadow = this.options.shadow.enabled;
                } else if (this.hover) {
                  var r2 = this.options.hoverWidth;
                  "function" == typeof r2 ? o2.width = r2(o2.width) : "number" == typeof r2 && (o2.width += r2), o2.width = Math.max(o2.width, 0.3 / this.body.view.scale), o2.color = this.options.color.hover, o2.shadow = this.options.shadow.enabled;
                }
              } else
                "function" == typeof this.chooser && (this.chooser(o2, this.options.id, this.selected, this.hover), void 0 !== o2.color && (o2.inheritsColor = false), false === o2.shadow && (o2.shadowColor === this.options.shadow.color && o2.shadowSize === this.options.shadow.size && o2.shadowX === this.options.shadow.x && o2.shadowY === this.options.shadow.y || (o2.shadow = true)));
            else
              o2.shadow = this.options.shadow.enabled, o2.width = Math.max(o2.width, 0.3 / this.body.view.scale);
            return o2;
          } }, { key: "updateLabelModule", value: function(e3) {
            var t2 = [e3, this.options, this.globalOptions, this.defaultOptions];
            this.labelModule.update(this.options, t2), void 0 !== this.labelModule.baseSize && (this.baseFontSize = this.labelModule.baseSize);
          } }, { key: "updateEdgeType", value: function() {
            var e3 = this.options.smooth, t2 = false, i2 = true;
            return void 0 !== this.edgeType && ((this.edgeType instanceof m && true === e3.enabled && "dynamic" === e3.type || this.edgeType instanceof y && true === e3.enabled && "cubicBezier" === e3.type || this.edgeType instanceof b && true === e3.enabled && "dynamic" !== e3.type && "cubicBezier" !== e3.type || this.edgeType instanceof _ && false === e3.type.enabled) && (i2 = false), true === i2 && (t2 = this.cleanup())), true === i2 ? true === e3.enabled ? "dynamic" === e3.type ? (t2 = true, this.edgeType = new m(this.options, this.body, this.labelModule)) : "cubicBezier" === e3.type ? this.edgeType = new y(this.options, this.body, this.labelModule) : this.edgeType = new b(this.options, this.body, this.labelModule) : this.edgeType = new _(this.options, this.body, this.labelModule) : this.edgeType.setOptions(this.options), t2;
          } }, { key: "connect", value: function() {
            this.disconnect(), this.from = this.body.nodes[this.fromId] || void 0, this.to = this.body.nodes[this.toId] || void 0, this.connected = void 0 !== this.from && void 0 !== this.to, true === this.connected ? (this.from.attachEdge(this), this.to.attachEdge(this)) : (this.from && this.from.detachEdge(this), this.to && this.to.detachEdge(this)), this.edgeType.connect();
          } }, { key: "disconnect", value: function() {
            this.from && (this.from.detachEdge(this), this.from = void 0), this.to && (this.to.detachEdge(this), this.to = void 0), this.connected = false;
          } }, { key: "getTitle", value: function() {
            return this.title;
          } }, { key: "isSelected", value: function() {
            return this.selected;
          } }, { key: "getValue", value: function() {
            return this.options.value;
          } }, { key: "setValueRange", value: function(e3, t2, i2) {
            if (void 0 !== this.options.value) {
              var n2 = this.options.scaling.customScalingFunction(e3, t2, i2, this.options.value), o2 = this.options.scaling.max - this.options.scaling.min;
              if (true === this.options.scaling.label.enabled) {
                var s2 = this.options.scaling.label.max - this.options.scaling.label.min;
                this.options.font.size = this.options.scaling.label.min + n2 * s2;
              }
              this.options.width = this.options.scaling.min + n2 * o2;
            } else
              this.options.width = this.baseWidth, this.options.font.size = this.baseFontSize;
            this._setInteractionWidths(), this.updateLabelModule();
          } }, { key: "_setInteractionWidths", value: function() {
            "function" == typeof this.options.hoverWidth ? this.edgeType.hoverWidth = this.options.hoverWidth(this.options.width) : this.edgeType.hoverWidth = this.options.hoverWidth + this.options.width, "function" == typeof this.options.selectionWidth ? this.edgeType.selectionWidth = this.options.selectionWidth(this.options.width) : this.edgeType.selectionWidth = this.options.selectionWidth + this.options.width;
          } }, { key: "draw", value: function(e3) {
            var t2 = this.getFormattingValues();
            if (!t2.hidden) {
              var i2 = this.edgeType.getViaNode(), n2 = {};
              this.edgeType.fromPoint = this.edgeType.from, this.edgeType.toPoint = this.edgeType.to, t2.fromArrow && (n2.from = this.edgeType.getArrowData(e3, "from", i2, this.selected, this.hover, t2), false === t2.arrowStrikethrough && (this.edgeType.fromPoint = n2.from.core)), t2.toArrow && (n2.to = this.edgeType.getArrowData(e3, "to", i2, this.selected, this.hover, t2), false === t2.arrowStrikethrough && (this.edgeType.toPoint = n2.to.core)), t2.middleArrow && (n2.middle = this.edgeType.getArrowData(e3, "middle", i2, this.selected, this.hover, t2)), this.edgeType.drawLine(e3, t2, this.selected, this.hover, i2), this.drawArrows(e3, n2, t2), this.drawLabel(e3, i2);
            }
          } }, { key: "drawArrows", value: function(e3, t2, i2) {
            i2.fromArrow && this.edgeType.drawArrowHead(e3, i2, this.selected, this.hover, t2.from), i2.middleArrow && this.edgeType.drawArrowHead(e3, i2, this.selected, this.hover, t2.middle), i2.toArrow && this.edgeType.drawArrowHead(e3, i2, this.selected, this.hover, t2.to);
          } }, { key: "drawLabel", value: function(e3, t2) {
            if (void 0 !== this.options.label) {
              var i2 = this.from, n2 = this.to;
              if (this.labelModule.differentState(this.selected, this.hover) && this.labelModule.getTextSize(e3, this.selected, this.hover), i2.id != n2.id) {
                this.labelModule.pointToSelf = false;
                var o2 = this.edgeType.getPoint(0.5, t2);
                e3.save();
                var s2 = this._getRotation(e3);
                0 != s2.angle && (e3.translate(s2.x, s2.y), e3.rotate(s2.angle)), this.labelModule.draw(e3, o2.x, o2.y, this.selected, this.hover), e3.restore();
              } else {
                this.labelModule.pointToSelf = true;
                var r2, a2, d2 = this.options.selfReferenceSize;
                i2.shape.width > i2.shape.height ? (r2 = i2.x + 0.5 * i2.shape.width, a2 = i2.y - d2) : (r2 = i2.x + d2, a2 = i2.y - 0.5 * i2.shape.height), o2 = this._pointOnCircle(r2, a2, d2, 0.125), this.labelModule.draw(e3, o2.x, o2.y, this.selected, this.hover);
              }
            }
          } }, { key: "getItemsOnPoint", value: function(e3) {
            var t2 = [];
            if (this.labelModule.visible()) {
              var i2 = this._getRotation();
              g.pointInRect(this.labelModule.getSize(), e3, i2) && t2.push({ edgeId: this.id, labelId: 0 });
            }
            var n2 = { left: e3.x, top: e3.y };
            return this.isOverlappingWith(n2) && t2.push({ edgeId: this.id }), t2;
          } }, { key: "isOverlappingWith", value: function(e3) {
            if (this.connected) {
              var t2 = this.from.x, i2 = this.from.y, n2 = this.to.x, o2 = this.to.y, s2 = e3.left, r2 = e3.top;
              return this.edgeType.getDistanceToEdge(t2, i2, n2, o2, s2, r2) < 10;
            }
            return false;
          } }, { key: "_getRotation", value: function(e3) {
            var t2 = this.edgeType.getViaNode(), i2 = this.edgeType.getPoint(0.5, t2);
            void 0 !== e3 && this.labelModule.calculateLabelSize(e3, this.selected, this.hover, i2.x, i2.y);
            var n2 = { x: i2.x, y: this.labelModule.size.yLine, angle: 0 };
            if (!this.labelModule.visible())
              return n2;
            if ("horizontal" === this.options.font.align)
              return n2;
            var o2 = this.from.y - this.to.y, s2 = this.from.x - this.to.x, r2 = Math.atan2(o2, s2);
            return (r2 < -1 && s2 < 0 || r2 > 0 && s2 < 0) && (r2 += Math.PI), n2.angle = r2, n2;
          } }, { key: "_pointOnCircle", value: function(e3, t2, i2, n2) {
            var o2 = 2 * n2 * Math.PI;
            return { x: e3 + i2 * Math.cos(o2), y: t2 - i2 * Math.sin(o2) };
          } }, { key: "select", value: function() {
            this.selected = true;
          } }, { key: "unselect", value: function() {
            this.selected = false;
          } }, { key: "cleanup", value: function() {
            return this.edgeType.cleanup();
          } }, { key: "remove", value: function() {
            this.cleanup(), this.disconnect(), delete this.body.edges[this.id];
          } }, { key: "endPointsValid", value: function() {
            return void 0 !== this.body.nodes[this.fromId] && void 0 !== this.body.nodes[this.toId];
          } }], [{ key: "parseOptions", value: function(e3, t2) {
            var i2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}, o2 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4], r2 = ["arrowStrikethrough", "id", "from", "hidden", "hoverWidth", "labelHighlightBold", "length", "line", "opacity", "physics", "scaling", "selectionWidth", "selfReferenceSize", "to", "title", "value", "width", "font", "chosen", "widthConstraint"];
            if (p.selectiveDeepExtend(r2, e3, t2, i2), g.isValidLabel(t2.label) ? e3.label = t2.label : e3.label = void 0, p.mergeOptions(e3, t2, "smooth", n2), p.mergeOptions(e3, t2, "shadow", n2), void 0 !== t2.dashes && null !== t2.dashes ? e3.dashes = t2.dashes : true === i2 && null === t2.dashes && (e3.dashes = (0, h.default)(n2.dashes)), void 0 !== t2.scaling && null !== t2.scaling ? (void 0 !== t2.scaling.min && (e3.scaling.min = t2.scaling.min), void 0 !== t2.scaling.max && (e3.scaling.max = t2.scaling.max), p.mergeOptions(e3.scaling, t2.scaling, "label", n2.scaling)) : true === i2 && null === t2.scaling && (e3.scaling = (0, h.default)(n2.scaling)), void 0 !== t2.arrows && null !== t2.arrows)
              if ("string" == typeof t2.arrows) {
                var d2 = t2.arrows.toLowerCase();
                e3.arrows.to.enabled = -1 != d2.indexOf("to"), e3.arrows.middle.enabled = -1 != d2.indexOf("middle"), e3.arrows.from.enabled = -1 != d2.indexOf("from");
              } else {
                if ("object" !== (0, a.default)(t2.arrows))
                  throw new Error("The arrow newOptions can only be an object or a string. Refer to the documentation. You used:" + (0, s.default)(t2.arrows));
                p.mergeOptions(e3.arrows, t2.arrows, "to", n2.arrows), p.mergeOptions(e3.arrows, t2.arrows, "middle", n2.arrows), p.mergeOptions(e3.arrows, t2.arrows, "from", n2.arrows);
              }
            else
              true === i2 && null === t2.arrows && (e3.arrows = (0, h.default)(n2.arrows));
            if (void 0 !== t2.color && null !== t2.color) {
              var l2 = t2.color, u2 = e3.color;
              if (o2)
                p.deepExtend(u2, n2.color, false, i2);
              else
                for (var c2 in u2)
                  u2.hasOwnProperty(c2) && delete u2[c2];
              if (p.isString(u2))
                u2.color = u2, u2.highlight = u2, u2.hover = u2, u2.inherit = false, void 0 === l2.opacity && (u2.opacity = 1);
              else {
                var f2 = false;
                void 0 !== l2.color && (u2.color = l2.color, f2 = true), void 0 !== l2.highlight && (u2.highlight = l2.highlight, f2 = true), void 0 !== l2.hover && (u2.hover = l2.hover, f2 = true), void 0 !== l2.inherit && (u2.inherit = l2.inherit), void 0 !== l2.opacity && (u2.opacity = Math.min(1, Math.max(0, l2.opacity))), true === f2 ? u2.inherit = false : void 0 === u2.inherit && (u2.inherit = "from");
              }
            } else
              true === i2 && null === t2.color && (e3.color = p.bridgeObject(n2.color));
            true === i2 && null === t2.font && (e3.font = p.bridgeObject(n2.font));
          } }]), e2;
        }();
        t.default = w;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(2), s = n(o), r = i(0), a = n(r), d = i(1), h = n(d), l = i(3), u = n(l), c = i(4), f = n(c), p = i(78), v = n(p), g = function(e2) {
          function t2(e3, i2, n2) {
            return (0, a.default)(this, t2), (0, u.default)(this, (t2.__proto__ || (0, s.default)(t2)).call(this, e3, i2, n2));
          }
          return (0, f.default)(t2, e2), (0, h.default)(t2, [{ key: "_findBorderPositionBezier", value: function(e3, t3) {
            var i2, n2, o2, s2, r2, a2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this._getViaCoordinates(), d2 = 0, h2 = 0, l2 = 1, u2 = this.to, c2 = false;
            for (e3.id === this.from.id && (u2 = this.from, c2 = true); h2 <= l2 && d2 < 10; ) {
              var f2 = 0.5 * (h2 + l2);
              if (i2 = this.getPoint(f2, a2), n2 = Math.atan2(u2.y - i2.y, u2.x - i2.x), o2 = u2.distanceToBorder(t3, n2), s2 = Math.sqrt(Math.pow(i2.x - u2.x, 2) + Math.pow(i2.y - u2.y, 2)), r2 = o2 - s2, Math.abs(r2) < 0.2)
                break;
              r2 < 0 ? false === c2 ? h2 = f2 : l2 = f2 : false === c2 ? l2 = f2 : h2 = f2, d2++;
            }
            return i2.t = f2, i2;
          } }, { key: "_getDistanceToBezierEdge", value: function(e3, t3, i2, n2, o2, s2, r2) {
            var a2 = 1e9, d2 = void 0, h2 = void 0, l2 = void 0, u2 = void 0, c2 = void 0, f2 = e3, p2 = t3;
            for (h2 = 1; h2 < 10; h2++)
              l2 = 0.1 * h2, u2 = Math.pow(1 - l2, 2) * e3 + 2 * l2 * (1 - l2) * r2.x + Math.pow(l2, 2) * i2, c2 = Math.pow(1 - l2, 2) * t3 + 2 * l2 * (1 - l2) * r2.y + Math.pow(l2, 2) * n2, h2 > 0 && (d2 = this._getDistanceToLine(f2, p2, u2, c2, o2, s2), a2 = d2 < a2 ? d2 : a2), f2 = u2, p2 = c2;
            return a2;
          } }, { key: "_bezierCurve", value: function(e3, t3, i2, n2) {
            var o2 = void 0 !== i2 && void 0 !== i2.x, s2 = void 0 !== n2 && void 0 !== n2.x;
            e3.beginPath(), e3.moveTo(this.fromPoint.x, this.fromPoint.y), o2 && s2 ? e3.bezierCurveTo(i2.x, i2.y, n2.x, n2.y, this.toPoint.x, this.toPoint.y) : o2 ? e3.quadraticCurveTo(i2.x, i2.y, this.toPoint.x, this.toPoint.y) : e3.lineTo(this.toPoint.x, this.toPoint.y), this.enableShadow(e3, t3), e3.stroke(), this.disableShadow(e3, t3);
          } }, { key: "getViaNode", value: function() {
            return this._getViaCoordinates();
          } }]), t2;
        }(v.default);
        t.default = g;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(0), s = n(o), r = i(1), a = n(r), d = i(5), h = function() {
          function e2() {
            (0, s.default)(this, e2);
          }
          return (0, a.default)(e2, null, [{ key: "getRange", value: function(e3) {
            var t2, i2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [], n2 = 1e9, o2 = -1e9, s2 = 1e9, r2 = -1e9;
            if (i2.length > 0)
              for (var a2 = 0; a2 < i2.length; a2++)
                t2 = e3[i2[a2]], s2 > t2.shape.boundingBox.left && (s2 = t2.shape.boundingBox.left), r2 < t2.shape.boundingBox.right && (r2 = t2.shape.boundingBox.right), n2 > t2.shape.boundingBox.top && (n2 = t2.shape.boundingBox.top), o2 < t2.shape.boundingBox.bottom && (o2 = t2.shape.boundingBox.bottom);
            return 1e9 === s2 && -1e9 === r2 && 1e9 === n2 && -1e9 === o2 && (n2 = 0, o2 = 0, s2 = 0, r2 = 0), { minX: s2, maxX: r2, minY: n2, maxY: o2 };
          } }, { key: "getRangeCore", value: function(e3) {
            var t2, i2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [], n2 = 1e9, o2 = -1e9, s2 = 1e9, r2 = -1e9;
            if (i2.length > 0)
              for (var a2 = 0; a2 < i2.length; a2++)
                t2 = e3[i2[a2]], s2 > t2.x && (s2 = t2.x), r2 < t2.x && (r2 = t2.x), n2 > t2.y && (n2 = t2.y), o2 < t2.y && (o2 = t2.y);
            return 1e9 === s2 && -1e9 === r2 && 1e9 === n2 && -1e9 === o2 && (n2 = 0, o2 = 0, s2 = 0, r2 = 0), { minX: s2, maxX: r2, minY: n2, maxY: o2 };
          } }, { key: "findCenter", value: function(e3) {
            return { x: 0.5 * (e3.maxX + e3.minX), y: 0.5 * (e3.maxY + e3.minY) };
          } }, { key: "cloneOptions", value: function(e3, t2) {
            var i2 = {};
            return void 0 === t2 || "node" === t2 ? (d.deepExtend(i2, e3.options, true), i2.x = e3.x, i2.y = e3.y, i2.amountOfConnections = e3.edges.length) : d.deepExtend(i2, e3.options, true), i2;
          } }]), e2;
        }();
        t.default = h;
      }, function(e, t, i) {
        e.exports = { default: i(84), __esModule: true };
      }, function(e, t, i) {
        var n = i(37);
        e.exports = Object("z").propertyIsEnumerable(0) ? Object : function(e2) {
          return "String" == n(e2) ? e2.split("") : Object(e2);
        };
      }, function(e, t, i) {
        var n = i(39), o = i(11), s = i(64), r = i(18), a = i(14), d = i(24), h = i(89), l = i(46), u = i(66), c = i(8)("iterator"), f = !([].keys && "next" in [].keys()), p = function() {
          return this;
        };
        e.exports = function(e2, t2, i2, v, g, y, m) {
          h(i2, t2, v);
          var b, _, w, k = function(e3) {
            if (!f && e3 in E)
              return E[e3];
            switch (e3) {
              case "keys":
              case "values":
                return function() {
                  return new i2(this, e3);
                };
            }
            return function() {
              return new i2(this, e3);
            };
          }, x = t2 + " Iterator", O = "values" == g, M = false, E = e2.prototype, S = E[c] || E["@@iterator"] || g && E[g], D = S || k(g), C = g ? O ? k("entries") : D : void 0, T = "Array" == t2 ? E.entries || S : S;
          if (T && (w = u(T.call(new e2()))) !== Object.prototype && w.next && (l(w, x, true), n || a(w, c) || r(w, c, p)), O && S && "values" !== S.name && (M = true, D = function() {
            return S.call(this);
          }), n && !m || !f && !M && E[c] || r(E, c, D), d[t2] = D, d[x] = p, g)
            if (b = { values: O ? D : k("values"), keys: y ? D : k("keys"), entries: C }, m)
              for (_ in b)
                _ in E || s(E, _, b[_]);
            else
              o(o.P + o.F * (f || M), t2, b);
          return b;
        };
      }, function(e, t, i) {
        var n = i(88);
        e.exports = function(e2, t2, i2) {
          if (n(e2), void 0 === t2)
            return e2;
          switch (i2) {
            case 1:
              return function(i3) {
                return e2.call(t2, i3);
              };
            case 2:
              return function(i3, n2) {
                return e2.call(t2, i3, n2);
              };
            case 3:
              return function(i3, n2, o) {
                return e2.call(t2, i3, n2, o);
              };
          }
          return function() {
            return e2.apply(t2, arguments);
          };
        };
      }, function(e, t, i) {
        e.exports = !i(13) && !i(20)(function() {
          return 7 != Object.defineProperty(i(63)("div"), "a", { get: function() {
            return 7;
          } }).a;
        });
      }, function(e, t, i) {
        var n = i(25), o = i(9).document, s = n(o) && n(o.createElement);
        e.exports = function(e2) {
          return s ? o.createElement(e2) : {};
        };
      }, function(e, t, i) {
        e.exports = i(18);
      }, function(e, t, i) {
        var n = i(14), o = i(17), s = i(91)(false), r = i(43)("IE_PROTO");
        e.exports = function(e2, t2) {
          var i2, a = o(e2), d = 0, h = [];
          for (i2 in a)
            i2 != r && n(a, i2) && h.push(i2);
          for (; t2.length > d; )
            n(a, i2 = t2[d++]) && (~s(h, i2) || h.push(i2));
          return h;
        };
      }, function(e, t, i) {
        var n = i(14), o = i(29), s = i(43)("IE_PROTO"), r = Object.prototype;
        e.exports = Object.getPrototypeOf || function(e2) {
          return e2 = o(e2), n(e2, s) ? e2[s] : "function" == typeof e2.constructor && e2 instanceof e2.constructor ? e2.constructor.prototype : e2 instanceof Object ? r : null;
        };
      }, function(e, t, i) {
        var n = i(37), o = i(8)("toStringTag"), s = "Arguments" == n(function() {
          return arguments;
        }()), r = function(e2, t2) {
          try {
            return e2[t2];
          } catch (e3) {
          }
        };
        e.exports = function(e2) {
          var t2, i2, a;
          return void 0 === e2 ? "Undefined" : null === e2 ? "Null" : "string" == typeof (i2 = r(t2 = Object(e2), o)) ? i2 : s ? n(t2) : "Object" == (a = n(t2)) && "function" == typeof t2.callee ? "Arguments" : a;
        };
      }, function(e, t, i) {
        var n = i(11), o = i(6), s = i(20);
        e.exports = function(e2, t2) {
          var i2 = (o.Object || {})[e2] || Object[e2], r = {};
          r[e2] = t2(i2), n(n.S + n.F * s(function() {
            i2(1);
          }), "Object", r);
        };
      }, function(e, t, i) {
        var n = i(65), o = i(45).concat("length", "prototype");
        t.f = Object.getOwnPropertyNames || function(e2) {
          return n(e2, o);
        };
      }, function(e, t, i) {
        var n = i(31), o = i(27), s = i(17), r = i(40), a = i(14), d = i(62), h = Object.getOwnPropertyDescriptor;
        t.f = i(13) ? h : function(e2, t2) {
          if (e2 = s(e2), t2 = r(t2, true), d)
            try {
              return h(e2, t2);
            } catch (e3) {
            }
          if (a(e2, t2))
            return o(!n.f.call(e2, t2), e2[t2]);
        };
      }, function(e, t, i) {
        e.exports = "undefined" != typeof window && window.moment || i(114);
      }, function(e, t, i) {
        function n(e2) {
          this.delay = null, this.max = 1 / 0, this._queue = [], this._timeout = null, this._extended = null, this.setOptions(e2);
        }
        n.prototype.setOptions = function(e2) {
          e2 && void 0 !== e2.delay && (this.delay = e2.delay), e2 && void 0 !== e2.max && (this.max = e2.max), this._flushIfNeeded();
        }, n.extend = function(e2, t2) {
          var i2 = new n(t2);
          if (void 0 !== e2.flush)
            throw new Error("Target object already has a property flush");
          e2.flush = function() {
            i2.flush();
          };
          var o = [{ name: "flush", original: void 0 }];
          if (t2 && t2.replace)
            for (var s = 0; s < t2.replace.length; s++) {
              var r = t2.replace[s];
              o.push({ name: r, original: e2[r] }), i2.replace(e2, r);
            }
          return i2._extended = { object: e2, methods: o }, i2;
        }, n.prototype.destroy = function() {
          if (this.flush(), this._extended) {
            for (var e2 = this._extended.object, t2 = this._extended.methods, i2 = 0; i2 < t2.length; i2++) {
              var n2 = t2[i2];
              n2.original ? e2[n2.name] = n2.original : delete e2[n2.name];
            }
            this._extended = null;
          }
        }, n.prototype.replace = function(e2, t2) {
          var i2 = this, n2 = e2[t2];
          if (!n2)
            throw new Error("Method " + t2 + " undefined");
          e2[t2] = function() {
            for (var e3 = [], t3 = 0; t3 < arguments.length; t3++)
              e3[t3] = arguments[t3];
            i2.queue({ args: e3, fn: n2, context: this });
          };
        }, n.prototype.queue = function(e2) {
          "function" == typeof e2 ? this._queue.push({ fn: e2 }) : this._queue.push(e2), this._flushIfNeeded();
        }, n.prototype._flushIfNeeded = function() {
          if (this._queue.length > this.max && this.flush(), clearTimeout(this._timeout), this.queue.length > 0 && "number" == typeof this.delay) {
            var e2 = this;
            this._timeout = setTimeout(function() {
              e2.flush();
            }, this.delay);
          }
        }, n.prototype.flush = function() {
          for (; this._queue.length > 0; ) {
            var e2 = this._queue.shift();
            e2.fn.apply(e2.context || e2.fn, e2.args || []);
          }
        }, e.exports = n;
      }, function(e, t) {
        function i(e2) {
          if (e2)
            return n(e2);
        }
        function n(e2) {
          for (var t2 in i.prototype)
            e2[t2] = i.prototype[t2];
          return e2;
        }
        e.exports = i, i.prototype.on = i.prototype.addEventListener = function(e2, t2) {
          return this._callbacks = this._callbacks || {}, (this._callbacks[e2] = this._callbacks[e2] || []).push(t2), this;
        }, i.prototype.once = function(e2, t2) {
          function i2() {
            n2.off(e2, i2), t2.apply(this, arguments);
          }
          var n2 = this;
          return this._callbacks = this._callbacks || {}, i2.fn = t2, this.on(e2, i2), this;
        }, i.prototype.off = i.prototype.removeListener = i.prototype.removeAllListeners = i.prototype.removeEventListener = function(e2, t2) {
          if (this._callbacks = this._callbacks || {}, 0 == arguments.length)
            return this._callbacks = {}, this;
          var i2 = this._callbacks[e2];
          if (!i2)
            return this;
          if (1 == arguments.length)
            return delete this._callbacks[e2], this;
          for (var n2, o = 0; o < i2.length; o++)
            if ((n2 = i2[o]) === t2 || n2.fn === t2) {
              i2.splice(o, 1);
              break;
            }
          return this;
        }, i.prototype.emit = function(e2) {
          this._callbacks = this._callbacks || {};
          var t2 = [].slice.call(arguments, 1), i2 = this._callbacks[e2];
          if (i2) {
            i2 = i2.slice(0);
            for (var n2 = 0, o = i2.length; n2 < o; ++n2)
              i2[n2].apply(this, t2);
          }
          return this;
        }, i.prototype.listeners = function(e2) {
          return this._callbacks = this._callbacks || {}, this._callbacks[e2] || [];
        }, i.prototype.hasListeners = function(e2) {
          return !!this.listeners(e2).length;
        };
      }, function(e, t, i) {
        function n(e2) {
          return N = e2, p();
        }
        function o() {
          B = 0, z = N.charAt(0);
        }
        function s() {
          B++, z = N.charAt(B);
        }
        function r() {
          return N.charAt(B + 1);
        }
        function a(e2) {
          return j.test(e2);
        }
        function d(e2, t2) {
          if (e2 || (e2 = {}), t2)
            for (var i2 in t2)
              t2.hasOwnProperty(i2) && (e2[i2] = t2[i2]);
          return e2;
        }
        function h(e2, t2, i2) {
          for (var n2 = t2.split("."), o2 = e2; n2.length; ) {
            var s2 = n2.shift();
            n2.length ? (o2[s2] || (o2[s2] = {}), o2 = o2[s2]) : o2[s2] = i2;
          }
        }
        function l(e2, t2) {
          for (var i2, n2, o2 = null, s2 = [e2], r2 = e2; r2.parent; )
            s2.push(r2.parent), r2 = r2.parent;
          if (r2.nodes) {
            for (i2 = 0, n2 = r2.nodes.length; i2 < n2; i2++)
              if (t2.id === r2.nodes[i2].id) {
                o2 = r2.nodes[i2];
                break;
              }
          }
          for (o2 || (o2 = { id: t2.id }, e2.node && (o2.attr = d(o2.attr, e2.node))), i2 = s2.length - 1; i2 >= 0; i2--) {
            var a2 = s2[i2];
            a2.nodes || (a2.nodes = []), -1 === a2.nodes.indexOf(o2) && a2.nodes.push(o2);
          }
          t2.attr && (o2.attr = d(o2.attr, t2.attr));
        }
        function u(e2, t2) {
          if (e2.edges || (e2.edges = []), e2.edges.push(t2), e2.edge) {
            var i2 = d({}, e2.edge);
            t2.attr = d(i2, t2.attr);
          }
        }
        function c(e2, t2, i2, n2, o2) {
          var s2 = { from: t2, to: i2, type: n2 };
          return e2.edge && (s2.attr = d({}, e2.edge)), s2.attr = d(s2.attr || {}, o2), s2;
        }
        function f() {
          for (A = I.NULL, R = ""; " " === z || "	" === z || "\n" === z || "\r" === z; )
            s();
          do {
            var e2 = false;
            if ("#" === z) {
              for (var t2 = B - 1; " " === N.charAt(t2) || "	" === N.charAt(t2); )
                t2--;
              if ("\n" === N.charAt(t2) || "" === N.charAt(t2)) {
                for (; "" != z && "\n" != z; )
                  s();
                e2 = true;
              }
            }
            if ("/" === z && "/" === r()) {
              for (; "" != z && "\n" != z; )
                s();
              e2 = true;
            }
            if ("/" === z && "*" === r()) {
              for (; "" != z; ) {
                if ("*" === z && "/" === r()) {
                  s(), s();
                  break;
                }
                s();
              }
              e2 = true;
            }
            for (; " " === z || "	" === z || "\n" === z || "\r" === z; )
              s();
          } while (e2);
          if ("" === z)
            return void (A = I.DELIMITER);
          var i2 = z + r();
          if (F[i2])
            return A = I.DELIMITER, R = i2, s(), void s();
          if (F[z])
            return A = I.DELIMITER, R = z, void s();
          if (a(z) || "-" === z) {
            for (R += z, s(); a(z); )
              R += z, s();
            return "false" === R ? R = false : "true" === R ? R = true : isNaN(Number(R)) || (R = Number(R)), void (A = I.IDENTIFIER);
          }
          if ('"' === z) {
            for (s(); "" != z && ('"' != z || '"' === z && '"' === r()); )
              '"' === z ? (R += z, s()) : "\\" === z && "n" === r() ? (R += "\n", s()) : R += z, s();
            if ('"' != z)
              throw k('End of string " expected');
            return s(), void (A = I.IDENTIFIER);
          }
          for (A = I.UNKNOWN; "" != z; )
            R += z, s();
          throw new SyntaxError('Syntax error in part "' + x(R, 30) + '"');
        }
        function p() {
          var e2 = {};
          if (o(), f(), "strict" === R && (e2.strict = true, f()), "graph" !== R && "digraph" !== R || (e2.type = R, f()), A === I.IDENTIFIER && (e2.id = R, f()), "{" != R)
            throw k("Angle bracket { expected");
          if (f(), v(e2), "}" != R)
            throw k("Angle bracket } expected");
          if (f(), "" !== R)
            throw k("End of file expected");
          return f(), delete e2.node, delete e2.edge, delete e2.graph, e2;
        }
        function v(e2) {
          for (; "" !== R && "}" != R; )
            g(e2), ";" === R && f();
        }
        function g(e2) {
          var t2 = y(e2);
          if (t2)
            return void _(e2, t2);
          if (!m(e2)) {
            if (A != I.IDENTIFIER)
              throw k("Identifier expected");
            var i2 = R;
            if (f(), "=" === R) {
              if (f(), A != I.IDENTIFIER)
                throw k("Identifier expected");
              e2[i2] = R, f();
            } else
              b(e2, i2);
          }
        }
        function y(e2) {
          var t2 = null;
          if ("subgraph" === R && (t2 = {}, t2.type = "subgraph", f(), A === I.IDENTIFIER && (t2.id = R, f())), "{" === R) {
            if (f(), t2 || (t2 = {}), t2.parent = e2, t2.node = e2.node, t2.edge = e2.edge, t2.graph = e2.graph, v(t2), "}" != R)
              throw k("Angle bracket } expected");
            f(), delete t2.node, delete t2.edge, delete t2.graph, delete t2.parent, e2.subgraphs || (e2.subgraphs = []), e2.subgraphs.push(t2);
          }
          return t2;
        }
        function m(e2) {
          return "node" === R ? (f(), e2.node = w(), "node") : "edge" === R ? (f(), e2.edge = w(), "edge") : "graph" === R ? (f(), e2.graph = w(), "graph") : null;
        }
        function b(e2, t2) {
          var i2 = { id: t2 }, n2 = w();
          n2 && (i2.attr = n2), l(e2, i2), _(e2, t2);
        }
        function _(e2, t2) {
          for (; "->" === R || "--" === R; ) {
            var i2, n2 = R;
            f();
            var o2 = y(e2);
            if (o2)
              i2 = o2;
            else {
              if (A != I.IDENTIFIER)
                throw k("Identifier or subgraph expected");
              i2 = R, l(e2, { id: i2 }), f();
            }
            u(e2, c(e2, t2, i2, n2, w())), t2 = i2;
          }
        }
        function w() {
          for (var e2 = null, t2 = { dashed: true, solid: false, dotted: [1, 5] }; "[" === R; ) {
            for (f(), e2 = {}; "" !== R && "]" != R; ) {
              if (A != I.IDENTIFIER)
                throw k("Attribute name expected");
              var i2 = R;
              if (f(), "=" != R)
                throw k("Equal sign = expected");
              if (f(), A != I.IDENTIFIER)
                throw k("Attribute value expected");
              var n2 = R;
              "style" === i2 && (n2 = t2[n2]), h(e2, i2, n2), f(), "," == R && f();
            }
            if ("]" != R)
              throw k("Bracket ] expected");
            f();
          }
          return e2;
        }
        function k(e2) {
          return new SyntaxError(e2 + ', got "' + x(R, 30) + '" (char ' + B + ")");
        }
        function x(e2, t2) {
          return e2.length <= t2 ? e2 : e2.substr(0, 27) + "...";
        }
        function O(e2, t2, i2) {
          Array.isArray(e2) ? e2.forEach(function(e3) {
            Array.isArray(t2) ? t2.forEach(function(t3) {
              i2(e3, t3);
            }) : i2(e3, t2);
          }) : Array.isArray(t2) ? t2.forEach(function(t3) {
            i2(e2, t3);
          }) : i2(e2, t2);
        }
        function M(e2, t2, i2) {
          for (var n2 = t2.split("."), o2 = n2.pop(), s2 = e2, r2 = 0; r2 < n2.length; r2++) {
            var a2 = n2[r2];
            a2 in s2 || (s2[a2] = {}), s2 = s2[a2];
          }
          return s2[o2] = i2, e2;
        }
        function E(e2, t2) {
          var i2 = {};
          for (var n2 in e2)
            if (e2.hasOwnProperty(n2)) {
              var o2 = t2[n2];
              Array.isArray(o2) ? o2.forEach(function(t3) {
                M(i2, t3, e2[n2]);
              }) : "string" == typeof o2 ? M(i2, o2, e2[n2]) : M(i2, n2, e2[n2]);
            }
          return i2;
        }
        function S(e2) {
          var t2 = n(e2), i2 = { nodes: [], edges: [], options: {} };
          if (t2.nodes && t2.nodes.forEach(function(e3) {
            var t3 = { id: e3.id, label: String(e3.label || e3.id) };
            d(t3, E(e3.attr, T)), t3.image && (t3.shape = "image"), i2.nodes.push(t3);
          }), t2.edges) {
            var o2 = function(e3) {
              var t3 = { from: e3.from, to: e3.to };
              return d(t3, E(e3.attr, P)), t3.arrows = "->" === e3.type ? "to" : void 0, t3;
            };
            t2.edges.forEach(function(e3) {
              var t3, n2;
              t3 = e3.from instanceof Object ? e3.from.nodes : { id: e3.from }, n2 = e3.to instanceof Object ? e3.to.nodes : { id: e3.to }, e3.from instanceof Object && e3.from.edges && e3.from.edges.forEach(function(e4) {
                var t4 = o2(e4);
                i2.edges.push(t4);
              }), O(t3, n2, function(t4, n3) {
                var s2 = c(i2, t4.id, n3.id, e3.type, e3.attr), r2 = o2(s2);
                i2.edges.push(r2);
              }), e3.to instanceof Object && e3.to.edges && e3.to.edges.forEach(function(e4) {
                var t4 = o2(e4);
                i2.edges.push(t4);
              });
            });
          }
          return t2.attr && (i2.options = t2.attr), i2;
        }
        var D = i(30), C = function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }(D), T = { fontsize: "font.size", fontcolor: "font.color", labelfontcolor: "font.color", fontname: "font.face", color: ["color.border", "color.background"], fillcolor: "color.background", tooltip: "title", labeltooltip: "title" }, P = (0, C.default)(T);
        P.color = "color.color", P.style = "dashes";
        var I = { NULL: 0, DELIMITER: 1, IDENTIFIER: 2, UNKNOWN: 3 }, F = { "{": true, "}": true, "[": true, "]": true, ";": true, "=": true, ",": true, "->": true, "--": true }, N = "", B = 0, z = "", R = "", A = I.NULL, j = /[a-zA-Z_0-9.:#]/;
        t.parseDOT = n, t.DOTToGraph = S;
      }, function(e, t, i) {
        function n(e2, t2) {
          var i2 = [], n2 = [], o = { edges: { inheritColor: false }, nodes: { fixed: false, parseColor: false } };
          void 0 !== t2 && (void 0 !== t2.fixed && (o.nodes.fixed = t2.fixed), void 0 !== t2.parseColor && (o.nodes.parseColor = t2.parseColor), void 0 !== t2.inheritColor && (o.edges.inheritColor = t2.inheritColor));
          for (var s = e2.edges, r = e2.nodes, a = 0; a < s.length; a++) {
            var d = {}, h = s[a];
            d.id = h.id, d.from = h.source, d.to = h.target, d.attributes = h.attributes, d.label = h.label, d.title = void 0 !== h.attributes ? h.attributes.title : void 0, "Directed" === h.type && (d.arrows = "to"), h.color && false === o.inheritColor && (d.color = h.color), i2.push(d);
          }
          for (var l = 0; l < r.length; l++) {
            var u = {}, c = r[l];
            u.id = c.id, u.attributes = c.attributes, u.x = c.x, u.y = c.y, u.label = c.label, u.title = void 0 !== c.attributes ? c.attributes.title : c.title, true === o.nodes.parseColor ? u.color = c.color : u.color = void 0 !== c.color ? { background: c.color, border: c.color, highlight: { background: c.color, border: c.color }, hover: { background: c.color, border: c.color } } : void 0, u.size = c.size, u.fixed = o.nodes.fixed && void 0 !== c.x && void 0 !== c.y, n2.push(u);
          }
          return { nodes: n2, edges: i2 };
        }
        t.parseGephi = n;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(0), s = n(o), r = i(1), a = n(r), d = i(130), h = n(d), l = function() {
          function e2(t2) {
            (0, s.default)(this, e2), this.images = {}, this.imageBroken = {}, this.callback = t2;
          }
          return (0, a.default)(e2, [{ key: "_tryloadBrokenUrl", value: function(e3, t2, i2) {
            if (void 0 !== e3 && void 0 !== i2) {
              if (void 0 === t2)
                return void console.warn("No broken url image defined");
              i2.onerror = function() {
                console.error("Could not load brokenImage:", t2);
              }, i2.image.src = t2;
            }
          } }, { key: "_redrawWithImage", value: function(e3) {
            this.callback && this.callback(e3);
          } }, { key: "load", value: function(e3, t2) {
            var i2 = this, n2 = this.images[e3];
            if (n2)
              return n2;
            var o2 = new h.default();
            return this.images[e3] = o2, o2.image.onload = function() {
              i2._fixImageCoordinates(o2.image), o2.init(), i2._redrawWithImage(o2);
            }, o2.image.onerror = function() {
              console.error("Could not load image:", e3), i2._tryloadBrokenUrl(e3, t2, o2);
            }, o2.image.src = e3, o2;
          } }, { key: "_fixImageCoordinates", value: function(e3) {
            0 === e3.width && (document.body.appendChild(e3), e3.width = e3.offsetWidth, e3.height = e3.offsetHeight, document.body.removeChild(e3));
          } }]), e2;
        }();
        t.default = l;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(23), s = n(o), r = i(7), a = n(r), d = i(0), h = n(d), l = i(1), u = n(l), c = i(5), f = i(34).default, p = i(136).default, v = ["bold", "ital", "boldital", "mono"], g = function() {
          function e2(t2, i2) {
            var n2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            (0, h.default)(this, e2), this.body = t2, this.pointToSelf = false, this.baseSize = void 0, this.fontOptions = {}, this.setOptions(i2), this.size = { top: 0, left: 0, width: 0, height: 0, yLine: 0 }, this.isEdgeLabel = n2;
          }
          return (0, u.default)(e2, [{ key: "setOptions", value: function(e3) {
            if (this.elementOptions = e3, this.initFontOptions(e3.font), f.isValidLabel(e3.label) ? this.labelDirty = true : e3.label = "", void 0 !== e3.font && null !== e3.font) {
              if ("string" == typeof e3.font)
                this.baseSize = this.fontOptions.size;
              else if ("object" === (0, a.default)(e3.font)) {
                var t2 = e3.font.size;
                void 0 !== t2 && (this.baseSize = t2);
              }
            }
          } }, { key: "initFontOptions", value: function(t2) {
            var i2 = this;
            if (c.forEach(v, function(e3) {
              i2.fontOptions[e3] = {};
            }), e2.parseFontString(this.fontOptions, t2))
              return void (this.fontOptions.vadjust = 0);
            c.forEach(t2, function(e3, t3) {
              void 0 !== e3 && null !== e3 && "object" !== (void 0 === e3 ? "undefined" : (0, a.default)(e3)) && (i2.fontOptions[t3] = e3);
            });
          } }, { key: "constrain", value: function(e3) {
            var t2 = { constrainWidth: false, maxWdt: -1, minWdt: -1, constrainHeight: false, minHgt: -1, valign: "middle" }, i2 = c.topMost(e3, "widthConstraint");
            if ("number" == typeof i2)
              t2.maxWdt = Number(i2), t2.minWdt = Number(i2);
            else if ("object" === (void 0 === i2 ? "undefined" : (0, a.default)(i2))) {
              var n2 = c.topMost(e3, ["widthConstraint", "maximum"]);
              "number" == typeof n2 && (t2.maxWdt = Number(n2));
              var o2 = c.topMost(e3, ["widthConstraint", "minimum"]);
              "number" == typeof o2 && (t2.minWdt = Number(o2));
            }
            var s2 = c.topMost(e3, "heightConstraint");
            if ("number" == typeof s2)
              t2.minHgt = Number(s2);
            else if ("object" === (void 0 === s2 ? "undefined" : (0, a.default)(s2))) {
              var r2 = c.topMost(e3, ["heightConstraint", "minimum"]);
              "number" == typeof r2 && (t2.minHgt = Number(r2));
              var d2 = c.topMost(e3, ["heightConstraint", "valign"]);
              "string" == typeof d2 && ("top" !== d2 && "bottom" !== d2 || (t2.valign = d2));
            }
            return t2;
          } }, { key: "update", value: function(e3, t2) {
            this.setOptions(e3, true), this.propagateFonts(t2), c.deepExtend(this.fontOptions, this.constrain(t2)), this.fontOptions.chooser = f.choosify("label", t2);
          } }, { key: "adjustSizes", value: function(e3) {
            var t2 = e3 ? e3.right + e3.left : 0;
            this.fontOptions.constrainWidth && (this.fontOptions.maxWdt -= t2, this.fontOptions.minWdt -= t2);
            var i2 = e3 ? e3.top + e3.bottom : 0;
            this.fontOptions.constrainHeight && (this.fontOptions.minHgt -= i2);
          } }, { key: "addFontOptionsToPile", value: function(e3, t2) {
            for (var i2 = 0; i2 < t2.length; ++i2)
              this.addFontToPile(e3, t2[i2]);
          } }, { key: "addFontToPile", value: function(e3, t2) {
            if (void 0 !== t2 && void 0 !== t2.font && null !== t2.font) {
              var i2 = t2.font;
              e3.push(i2);
            }
          } }, { key: "getBasicOptions", value: function(t2) {
            for (var i2 = {}, n2 = 0; n2 < t2.length; ++n2) {
              var o2 = t2[n2], s2 = {};
              e2.parseFontString(s2, o2) && (o2 = s2), c.forEach(o2, function(e3, t3) {
                void 0 !== e3 && (i2.hasOwnProperty(t3) || (-1 !== v.indexOf(t3) ? i2[t3] = {} : i2[t3] = e3));
              });
            }
            return i2;
          } }, { key: "getFontOption", value: function(t2, i2, n2) {
            for (var o2 = void 0, s2 = 0; s2 < t2.length; ++s2) {
              var r2 = t2[s2];
              if (r2.hasOwnProperty(i2)) {
                if (void 0 === (o2 = r2[i2]) || null === o2)
                  continue;
                var a2 = {};
                if (e2.parseFontString(a2, o2) && (o2 = a2), o2.hasOwnProperty(n2))
                  return o2[n2];
              }
            }
            if (this.fontOptions.hasOwnProperty(n2))
              return this.fontOptions[n2];
            throw new Error("Did not find value for multi-font for property: '" + n2 + "'");
          } }, { key: "getFontOptions", value: function(e3, t2) {
            for (var i2 = {}, n2 = ["color", "size", "face", "mod", "vadjust"], o2 = 0; o2 < n2.length; ++o2) {
              var s2 = n2[o2];
              i2[s2] = this.getFontOption(e3, t2, s2);
            }
            return i2;
          } }, { key: "propagateFonts", value: function(e3) {
            var t2 = this, i2 = [];
            this.addFontOptionsToPile(i2, e3), this.fontOptions = this.getBasicOptions(i2);
            for (var n2 = 0; n2 < v.length; ++n2)
              !function(e4) {
                var n3 = v[e4], o2 = t2.fontOptions[n3], s2 = t2.getFontOptions(i2, n3);
                c.forEach(s2, function(e5, t3) {
                  o2[t3] = e5;
                }), o2.size = Number(o2.size), o2.vadjust = Number(o2.vadjust);
              }(n2);
          } }, { key: "draw", value: function(e3, t2, i2, n2, o2) {
            var s2 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "middle";
            if (void 0 !== this.elementOptions.label) {
              var r2 = this.fontOptions.size * this.body.view.scale;
              this.elementOptions.label && r2 < this.elementOptions.scaling.label.drawThreshold - 1 || (r2 >= this.elementOptions.scaling.label.maxVisible && (r2 = Number(this.elementOptions.scaling.label.maxVisible) / this.body.view.scale), this.calculateLabelSize(e3, n2, o2, t2, i2, s2), this._drawBackground(e3), this._drawText(e3, t2, this.size.yLine, s2, r2));
            }
          } }, { key: "_drawBackground", value: function(e3) {
            if (void 0 !== this.fontOptions.background && "none" !== this.fontOptions.background) {
              e3.fillStyle = this.fontOptions.background;
              var t2 = this.getSize();
              e3.fillRect(t2.left, t2.top, t2.width, t2.height);
            }
          } }, { key: "_drawText", value: function(e3, t2, i2) {
            var n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "middle", o2 = arguments[4], r2 = this._setAlignment(e3, t2, i2, n2), a2 = (0, s.default)(r2, 2);
            t2 = a2[0], i2 = a2[1], e3.textAlign = "left", t2 -= this.size.width / 2, this.fontOptions.valign && this.size.height > this.size.labelHeight && ("top" === this.fontOptions.valign && (i2 -= (this.size.height - this.size.labelHeight) / 2), "bottom" === this.fontOptions.valign && (i2 += (this.size.height - this.size.labelHeight) / 2));
            for (var d2 = 0; d2 < this.lineCount; d2++) {
              var h2 = this.lines[d2];
              if (h2 && h2.blocks) {
                var l2 = 0;
                this.isEdgeLabel || "center" === this.fontOptions.align ? l2 += (this.size.width - h2.width) / 2 : "right" === this.fontOptions.align && (l2 += this.size.width - h2.width);
                for (var u2 = 0; u2 < h2.blocks.length; u2++) {
                  var c2 = h2.blocks[u2];
                  e3.font = c2.font;
                  var f2 = this._getColor(c2.color, o2, c2.strokeColor), p2 = (0, s.default)(f2, 2), v2 = p2[0], g2 = p2[1];
                  c2.strokeWidth > 0 && (e3.lineWidth = c2.strokeWidth, e3.strokeStyle = g2, e3.lineJoin = "round"), e3.fillStyle = v2, c2.strokeWidth > 0 && e3.strokeText(c2.text, t2 + l2, i2 + c2.vadjust), e3.fillText(c2.text, t2 + l2, i2 + c2.vadjust), l2 += c2.width;
                }
                i2 += h2.height;
              }
            }
          } }, { key: "_setAlignment", value: function(e3, t2, i2, n2) {
            if (this.isEdgeLabel && "horizontal" !== this.fontOptions.align && false === this.pointToSelf) {
              t2 = 0, i2 = 0;
              "top" === this.fontOptions.align ? (e3.textBaseline = "alphabetic", i2 -= 4) : "bottom" === this.fontOptions.align ? (e3.textBaseline = "hanging", i2 += 4) : e3.textBaseline = "middle";
            } else
              e3.textBaseline = n2;
            return [t2, i2];
          } }, { key: "_getColor", value: function(e3, t2, i2) {
            var n2 = e3 || "#000000", o2 = i2 || "#ffffff";
            if (t2 <= this.elementOptions.scaling.label.drawThreshold) {
              var s2 = Math.max(0, Math.min(1, 1 - (this.elementOptions.scaling.label.drawThreshold - t2)));
              n2 = c.overrideOpacity(n2, s2), o2 = c.overrideOpacity(o2, s2);
            }
            return [n2, o2];
          } }, { key: "getTextSize", value: function(e3) {
            var t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], i2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            return this._processLabel(e3, t2, i2), { width: this.size.width, height: this.size.height, lineCount: this.lineCount };
          } }, { key: "getSize", value: function() {
            var e3 = this.size.left, t2 = this.size.top - 1;
            if (this.isEdgeLabel) {
              var i2 = 0.5 * -this.size.width;
              switch (this.fontOptions.align) {
                case "middle":
                  e3 = i2, t2 = 0.5 * -this.size.height;
                  break;
                case "top":
                  e3 = i2, t2 = -(this.size.height + 2);
                  break;
                case "bottom":
                  e3 = i2, t2 = 2;
              }
            }
            return { left: e3, top: t2, width: this.size.width, height: this.size.height };
          } }, { key: "calculateLabelSize", value: function(e3, t2, i2) {
            var n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, o2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, s2 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "middle";
            this._processLabel(e3, t2, i2), this.size.left = n2 - 0.5 * this.size.width, this.size.top = o2 - 0.5 * this.size.height, this.size.yLine = o2 + 0.5 * (1 - this.lineCount) * this.fontOptions.size, "hanging" === s2 && (this.size.top += 0.5 * this.fontOptions.size, this.size.top += 4, this.size.yLine += 4);
          } }, { key: "getFormattingValues", value: function(e3, t2, i2, n2) {
            var o2 = function(e4, t3, i3) {
              return "normal" === t3 ? "mod" === i3 ? "" : e4[i3] : void 0 !== e4[t3][i3] ? e4[t3][i3] : e4[i3];
            }, s2 = { color: o2(this.fontOptions, n2, "color"), size: o2(this.fontOptions, n2, "size"), face: o2(this.fontOptions, n2, "face"), mod: o2(this.fontOptions, n2, "mod"), vadjust: o2(this.fontOptions, n2, "vadjust"), strokeWidth: this.fontOptions.strokeWidth, strokeColor: this.fontOptions.strokeColor };
            (t2 || i2) && ("normal" === n2 && true === this.fontOptions.chooser && this.elementOptions.labelHighlightBold ? s2.mod = "bold" : "function" == typeof this.fontOptions.chooser && this.fontOptions.chooser(s2, this.elementOptions.id, t2, i2));
            var r2 = "";
            return void 0 !== s2.mod && "" !== s2.mod && (r2 += s2.mod + " "), r2 += s2.size + "px " + s2.face, e3.font = r2.replace(/"/g, ""), s2.font = e3.font, s2.height = s2.size, s2;
          } }, { key: "differentState", value: function(e3, t2) {
            return e3 !== this.selectedState || t2 !== this.hoverState;
          } }, { key: "_processLabelText", value: function(e3, t2, i2, n2) {
            return new p(e3, this, t2, i2).process(n2);
          } }, { key: "_processLabel", value: function(e3, t2, i2) {
            if (false !== this.labelDirty || this.differentState(t2, i2)) {
              var n2 = this._processLabelText(e3, t2, i2, this.elementOptions.label);
              this.fontOptions.minWdt > 0 && n2.width < this.fontOptions.minWdt && (n2.width = this.fontOptions.minWdt), this.size.labelHeight = n2.height, this.fontOptions.minHgt > 0 && n2.height < this.fontOptions.minHgt && (n2.height = this.fontOptions.minHgt), this.lines = n2.lines, this.lineCount = n2.lines.length, this.size.width = n2.width, this.size.height = n2.height, this.selectedState = t2, this.hoverState = i2, this.labelDirty = false;
            }
          } }, { key: "visible", value: function() {
            return 0 !== this.size.width && 0 !== this.size.height && void 0 !== this.elementOptions.label && !(this.fontOptions.size * this.body.view.scale < this.elementOptions.scaling.label.drawThreshold - 1);
          } }], [{ key: "parseFontString", value: function(e3, t2) {
            if (!t2 || "string" != typeof t2)
              return false;
            var i2 = t2.split(" ");
            return e3.size = i2[0].replace("px", ""), e3.face = i2[1], e3.color = i2[2], true;
          } }]), e2;
        }();
        t.default = g;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(23), s = n(o), r = i(0), a = n(r), d = i(1), h = n(d), l = i(5), u = i(79).default, c = function() {
          function e2(t2, i2, n2) {
            (0, a.default)(this, e2), this.body = i2, this.labelModule = n2, this.options = {}, this.setOptions(t2), this.colorDirty = true, this.color = {}, this.selectionWidth = 2, this.hoverWidth = 1.5, this.fromPoint = this.from, this.toPoint = this.to;
          }
          return (0, h.default)(e2, [{ key: "connect", value: function() {
            this.from = this.body.nodes[this.options.from], this.to = this.body.nodes[this.options.to];
          } }, { key: "cleanup", value: function() {
            return false;
          } }, { key: "setOptions", value: function(e3) {
            this.options = e3, this.from = this.body.nodes[this.options.from], this.to = this.body.nodes[this.options.to], this.id = this.options.id;
          } }, { key: "drawLine", value: function(e3, t2, i2, n2, o2) {
            e3.strokeStyle = this.getColor(e3, t2, i2, n2), e3.lineWidth = t2.width, false !== t2.dashes ? this._drawDashedLine(e3, t2, o2) : this._drawLine(e3, t2, o2);
          } }, { key: "_drawLine", value: function(e3, t2, i2, n2, o2) {
            if (this.from != this.to)
              this._line(e3, t2, i2, n2, o2);
            else {
              var r2 = this._getCircleData(e3), a2 = (0, s.default)(r2, 3), d2 = a2[0], h2 = a2[1], l2 = a2[2];
              this._circle(e3, t2, d2, h2, l2);
            }
          } }, { key: "_drawDashedLine", value: function(e3, t2, i2, n2, o2) {
            e3.lineCap = "round";
            var r2 = [5, 5];
            if (true === Array.isArray(t2.dashes) && (r2 = t2.dashes), void 0 !== e3.setLineDash) {
              if (e3.save(), e3.setLineDash(r2), e3.lineDashOffset = 0, this.from != this.to)
                this._line(e3, t2, i2);
              else {
                var a2 = this._getCircleData(e3), d2 = (0, s.default)(a2, 3), h2 = d2[0], l2 = d2[1], u2 = d2[2];
                this._circle(e3, t2, h2, l2, u2);
              }
              e3.setLineDash([0]), e3.lineDashOffset = 0, e3.restore();
            } else {
              if (this.from != this.to)
                e3.dashedLine(this.from.x, this.from.y, this.to.x, this.to.y, r2);
              else {
                var c2 = this._getCircleData(e3), f = (0, s.default)(c2, 3), p = f[0], v = f[1], g = f[2];
                this._circle(e3, t2, p, v, g);
              }
              this.enableShadow(e3, t2), e3.stroke(), this.disableShadow(e3, t2);
            }
          } }, { key: "findBorderPosition", value: function(e3, t2, i2) {
            return this.from != this.to ? this._findBorderPosition(e3, t2, i2) : this._findBorderPositionCircle(e3, t2, i2);
          } }, { key: "findBorderPositions", value: function(e3) {
            var t2 = {}, i2 = {};
            if (this.from != this.to)
              t2 = this._findBorderPosition(this.from, e3), i2 = this._findBorderPosition(this.to, e3);
            else {
              var n2 = this._getCircleData(e3).slice(0, 2), o2 = (0, s.default)(n2, 2), r2 = o2[0], a2 = o2[1];
              t2 = this._findBorderPositionCircle(this.from, e3, { x: r2, y: a2, low: 0.25, high: 0.6, direction: -1 }), i2 = this._findBorderPositionCircle(this.from, e3, { x: r2, y: a2, low: 0.6, high: 0.8, direction: 1 });
            }
            return { from: t2, to: i2 };
          } }, { key: "_getCircleData", value: function(e3) {
            var t2 = void 0, i2 = void 0, n2 = this.from, o2 = this.options.selfReferenceSize;
            return void 0 !== e3 && void 0 === n2.shape.width && n2.shape.resize(e3), n2.shape.width > n2.shape.height ? (t2 = n2.x + 0.5 * n2.shape.width, i2 = n2.y - o2) : (t2 = n2.x + o2, i2 = n2.y - 0.5 * n2.shape.height), [t2, i2, o2];
          } }, { key: "_pointOnCircle", value: function(e3, t2, i2, n2) {
            var o2 = 2 * n2 * Math.PI;
            return { x: e3 + i2 * Math.cos(o2), y: t2 - i2 * Math.sin(o2) };
          } }, { key: "_findBorderPositionCircle", value: function(e3, t2, i2) {
            for (var n2 = i2.x, o2 = i2.y, s2 = i2.low, r2 = i2.high, a2 = i2.direction, d2 = 0, h2 = this.options.selfReferenceSize, l2 = void 0, u2 = void 0, c2 = void 0, f = void 0, p = void 0, v = 0.5 * (s2 + r2); s2 <= r2 && d2 < 10 && (v = 0.5 * (s2 + r2), l2 = this._pointOnCircle(n2, o2, h2, v), u2 = Math.atan2(e3.y - l2.y, e3.x - l2.x), c2 = e3.distanceToBorder(t2, u2), f = Math.sqrt(Math.pow(l2.x - e3.x, 2) + Math.pow(l2.y - e3.y, 2)), p = c2 - f, !(Math.abs(p) < 0.05)); )
              p > 0 ? a2 > 0 ? s2 = v : r2 = v : a2 > 0 ? r2 = v : s2 = v, d2++;
            return l2.t = v, l2;
          } }, { key: "getLineWidth", value: function(e3, t2) {
            return true === e3 ? Math.max(this.selectionWidth, 0.3 / this.body.view.scale) : true === t2 ? Math.max(this.hoverWidth, 0.3 / this.body.view.scale) : Math.max(this.options.width, 0.3 / this.body.view.scale);
          } }, { key: "getColor", value: function(e3, t2, i2, n2) {
            if (false !== t2.inheritsColor) {
              if ("both" === t2.inheritsColor && this.from.id !== this.to.id) {
                var o2 = e3.createLinearGradient(this.from.x, this.from.y, this.to.x, this.to.y), s2 = void 0, r2 = void 0;
                return s2 = this.from.options.color.highlight.border, r2 = this.to.options.color.highlight.border, false === this.from.selected && false === this.to.selected ? (s2 = l.overrideOpacity(this.from.options.color.border, t2.opacity), r2 = l.overrideOpacity(this.to.options.color.border, t2.opacity)) : true === this.from.selected && false === this.to.selected ? r2 = this.to.options.color.border : false === this.from.selected && true === this.to.selected && (s2 = this.from.options.color.border), o2.addColorStop(0, s2), o2.addColorStop(1, r2), o2;
              }
              return "to" === t2.inheritsColor ? l.overrideOpacity(this.to.options.color.border, t2.opacity) : l.overrideOpacity(this.from.options.color.border, t2.opacity);
            }
            return l.overrideOpacity(t2.color, t2.opacity);
          } }, { key: "_circle", value: function(e3, t2, i2, n2, o2) {
            this.enableShadow(e3, t2), e3.beginPath(), e3.arc(i2, n2, o2, 0, 2 * Math.PI, false), e3.stroke(), this.disableShadow(e3, t2);
          } }, { key: "getDistanceToEdge", value: function(e3, t2, i2, n2, o2, r2, a2, d2) {
            var h2 = 0;
            if (this.from != this.to)
              h2 = this._getDistanceToEdge(e3, t2, i2, n2, o2, r2, a2);
            else {
              var l2 = this._getCircleData(void 0), u2 = (0, s.default)(l2, 3), c2 = u2[0], f = u2[1], p = u2[2], v = c2 - o2, g = f - r2;
              h2 = Math.abs(Math.sqrt(v * v + g * g) - p);
            }
            return h2;
          } }, { key: "_getDistanceToLine", value: function(e3, t2, i2, n2, o2, s2) {
            var r2 = i2 - e3, a2 = n2 - t2, d2 = r2 * r2 + a2 * a2, h2 = ((o2 - e3) * r2 + (s2 - t2) * a2) / d2;
            h2 > 1 ? h2 = 1 : h2 < 0 && (h2 = 0);
            var l2 = e3 + h2 * r2, u2 = t2 + h2 * a2, c2 = l2 - o2, f = u2 - s2;
            return Math.sqrt(c2 * c2 + f * f);
          } }, { key: "getArrowData", value: function(e3, t2, i2, n2, o2, r2) {
            var a2 = void 0, d2 = void 0, h2 = void 0, l2 = void 0, u2 = void 0, c2 = void 0, f = void 0, p = r2.width;
            if ("from" === t2 ? (h2 = this.from, l2 = this.to, u2 = 0.1, c2 = r2.fromArrowScale, f = r2.fromArrowType) : "to" === t2 ? (h2 = this.to, l2 = this.from, u2 = -0.1, c2 = r2.toArrowScale, f = r2.toArrowType) : (h2 = this.to, l2 = this.from, c2 = r2.middleArrowScale, f = r2.middleArrowType), h2 != l2)
              if ("middle" !== t2)
                if (true === this.options.smooth.enabled) {
                  d2 = this.findBorderPosition(h2, e3, { via: i2 });
                  var v = this.getPoint(Math.max(0, Math.min(1, d2.t + u2)), i2);
                  a2 = Math.atan2(d2.y - v.y, d2.x - v.x);
                } else
                  a2 = Math.atan2(h2.y - l2.y, h2.x - l2.x), d2 = this.findBorderPosition(h2, e3);
              else
                a2 = Math.atan2(h2.y - l2.y, h2.x - l2.x), d2 = this.getPoint(0.5, i2);
            else {
              var g = this._getCircleData(e3), y = (0, s.default)(g, 3), m = y[0], b = y[1], _ = y[2];
              "from" === t2 ? (d2 = this.findBorderPosition(this.from, e3, { x: m, y: b, low: 0.25, high: 0.6, direction: -1 }), a2 = -2 * d2.t * Math.PI + 1.5 * Math.PI + 0.1 * Math.PI) : "to" === t2 ? (d2 = this.findBorderPosition(this.from, e3, { x: m, y: b, low: 0.6, high: 1, direction: 1 }), a2 = -2 * d2.t * Math.PI + 1.5 * Math.PI - 1.1 * Math.PI) : (d2 = this._pointOnCircle(m, b, _, 0.175), a2 = 3.9269908169872414);
            }
            "middle" === t2 && c2 < 0 && (p *= -1);
            var w = 15 * c2 + 3 * p;
            return { point: d2, core: { x: d2.x - 0.9 * w * Math.cos(a2), y: d2.y - 0.9 * w * Math.sin(a2) }, angle: a2, length: w, type: f };
          } }, { key: "drawArrowHead", value: function(e3, t2, i2, n2, o2) {
            e3.strokeStyle = this.getColor(e3, t2, i2, n2), e3.fillStyle = e3.strokeStyle, e3.lineWidth = t2.width, u.draw(e3, o2), this.enableShadow(e3, t2), e3.fill(), this.disableShadow(e3, t2);
          } }, { key: "enableShadow", value: function(e3, t2) {
            true === t2.shadow && (e3.shadowColor = t2.shadowColor, e3.shadowBlur = t2.shadowSize, e3.shadowOffsetX = t2.shadowX, e3.shadowOffsetY = t2.shadowY);
          } }, { key: "disableShadow", value: function(e3, t2) {
            true === t2.shadow && (e3.shadowColor = "rgba(0,0,0,0)", e3.shadowBlur = 0, e3.shadowOffsetX = 0, e3.shadowOffsetY = 0);
          } }]), e2;
        }();
        t.default = c;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(2), s = n(o), r = i(3), a = n(r), d = i(4), h = n(d), l = i(0), u = n(l), c = i(1), f = n(c), p = function() {
          function e2() {
            (0, u.default)(this, e2);
          }
          return (0, f.default)(e2, null, [{ key: "transform", value: function(e3, t2) {
            e3 instanceof Array || (e3 = [e3]);
            for (var i2 = t2.point.x, n2 = t2.point.y, o2 = t2.angle, s2 = t2.length, r2 = 0; r2 < e3.length; ++r2) {
              var a2 = e3[r2], d2 = a2.x * Math.cos(o2) - a2.y * Math.sin(o2), h2 = a2.x * Math.sin(o2) + a2.y * Math.cos(o2);
              a2.x = i2 + s2 * d2, a2.y = n2 + s2 * h2;
            }
          } }, { key: "drawPath", value: function(e3, t2) {
            e3.beginPath(), e3.moveTo(t2[0].x, t2[0].y);
            for (var i2 = 1; i2 < t2.length; ++i2)
              e3.lineTo(t2[i2].x, t2[i2].y);
            e3.closePath();
          } }]), e2;
        }(), v = function(e2) {
          function t2() {
            return (0, u.default)(this, t2), (0, a.default)(this, (t2.__proto__ || (0, s.default)(t2)).apply(this, arguments));
          }
          return (0, h.default)(t2, e2), (0, f.default)(t2, null, [{ key: "draw", value: function(e3, t3) {
            var i2 = [{ x: 0, y: 0 }, { x: -1, y: 0.3 }, { x: -0.9, y: 0 }, { x: -1, y: -0.3 }];
            p.transform(i2, t3), p.drawPath(e3, i2);
          } }]), t2;
        }(p), g = function() {
          function e2() {
            (0, u.default)(this, e2);
          }
          return (0, f.default)(e2, null, [{ key: "draw", value: function(e3, t2) {
            var i2 = { x: -0.4, y: 0 };
            p.transform(i2, t2), e3.circle(i2.x, i2.y, 0.4 * t2.length);
          } }]), e2;
        }(), y = function() {
          function e2() {
            (0, u.default)(this, e2);
          }
          return (0, f.default)(e2, null, [{ key: "draw", value: function(e3, t2) {
            var i2 = [{ x: 0, y: 0.5 }, { x: 0, y: -0.5 }, { x: -0.15, y: -0.5 }, { x: -0.15, y: 0.5 }];
            p.transform(i2, t2), p.drawPath(e3, i2);
          } }]), e2;
        }(), m = function() {
          function e2() {
            (0, u.default)(this, e2);
          }
          return (0, f.default)(e2, null, [{ key: "draw", value: function(e3, t2) {
            var i2;
            switch (t2.type && (i2 = t2.type.toLowerCase()), i2) {
              case "circle":
                g.draw(e3, t2);
                break;
              case "bar":
                y.draw(e3, t2);
                break;
              case "arrow":
              default:
                v.draw(e3, t2);
            }
          } }]), e2;
        }();
        t.default = m;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(0), s = n(o), r = i(1), a = n(r), d = function() {
          function e2(t2, i2, n2) {
            (0, s.default)(this, e2), this.body = t2, this.physicsBody = i2, this.barnesHutTree, this.setOptions(n2), this.randomSeed = 5;
          }
          return (0, a.default)(e2, [{ key: "setOptions", value: function(e3) {
            this.options = e3, this.thetaInversed = 1 / this.options.theta, this.overlapAvoidanceFactor = 1 - Math.max(0, Math.min(1, this.options.avoidOverlap));
          } }, { key: "seededRandom", value: function() {
            var e3 = 1e4 * Math.sin(this.randomSeed++);
            return e3 - Math.floor(e3);
          } }, { key: "solve", value: function() {
            if (0 !== this.options.gravitationalConstant && this.physicsBody.physicsNodeIndices.length > 0) {
              var e3 = void 0, t2 = this.body.nodes, i2 = this.physicsBody.physicsNodeIndices, n2 = i2.length, o2 = this._formBarnesHutTree(t2, i2);
              this.barnesHutTree = o2;
              for (var s2 = 0; s2 < n2; s2++)
                e3 = t2[i2[s2]], e3.options.mass > 0 && this._getForceContributions(o2.root, e3);
            }
          } }, { key: "_getForceContributions", value: function(e3, t2) {
            this._getForceContribution(e3.children.NW, t2), this._getForceContribution(e3.children.NE, t2), this._getForceContribution(e3.children.SW, t2), this._getForceContribution(e3.children.SE, t2);
          } }, { key: "_getForceContribution", value: function(e3, t2) {
            if (e3.childrenCount > 0) {
              var i2 = void 0, n2 = void 0, o2 = void 0;
              i2 = e3.centerOfMass.x - t2.x, n2 = e3.centerOfMass.y - t2.y, o2 = Math.sqrt(i2 * i2 + n2 * n2), o2 * e3.calcSize > this.thetaInversed ? this._calculateForces(o2, i2, n2, t2, e3) : 4 === e3.childrenCount ? this._getForceContributions(e3, t2) : e3.children.data.id != t2.id && this._calculateForces(o2, i2, n2, t2, e3);
            }
          } }, { key: "_calculateForces", value: function(e3, t2, i2, n2, o2) {
            0 === e3 && (e3 = 0.1, t2 = e3), this.overlapAvoidanceFactor < 1 && n2.shape.radius && (e3 = Math.max(0.1 + this.overlapAvoidanceFactor * n2.shape.radius, e3 - n2.shape.radius));
            var s2 = this.options.gravitationalConstant * o2.mass * n2.options.mass / Math.pow(e3, 3), r2 = t2 * s2, a2 = i2 * s2;
            this.physicsBody.forces[n2.id].x += r2, this.physicsBody.forces[n2.id].y += a2;
          } }, { key: "_formBarnesHutTree", value: function(e3, t2) {
            for (var i2 = void 0, n2 = t2.length, o2 = e3[t2[0]].x, s2 = e3[t2[0]].y, r2 = e3[t2[0]].x, a2 = e3[t2[0]].y, d2 = 1; d2 < n2; d2++) {
              var h = e3[t2[d2]], l = h.x, u = h.y;
              h.options.mass > 0 && (l < o2 && (o2 = l), l > r2 && (r2 = l), u < s2 && (s2 = u), u > a2 && (a2 = u));
            }
            var c = Math.abs(r2 - o2) - Math.abs(a2 - s2);
            c > 0 ? (s2 -= 0.5 * c, a2 += 0.5 * c) : (o2 += 0.5 * c, r2 -= 0.5 * c);
            var f = Math.max(1e-5, Math.abs(r2 - o2)), p = 0.5 * f, v = 0.5 * (o2 + r2), g = 0.5 * (s2 + a2), y = { root: { centerOfMass: { x: 0, y: 0 }, mass: 0, range: { minX: v - p, maxX: v + p, minY: g - p, maxY: g + p }, size: f, calcSize: 1 / f, children: { data: null }, maxWidth: 0, level: 0, childrenCount: 4 } };
            this._splitBranch(y.root);
            for (var m = 0; m < n2; m++)
              i2 = e3[t2[m]], i2.options.mass > 0 && this._placeInTree(y.root, i2);
            return y;
          } }, { key: "_updateBranchMass", value: function(e3, t2) {
            var i2 = e3.centerOfMass, n2 = e3.mass + t2.options.mass, o2 = 1 / n2;
            i2.x = i2.x * e3.mass + t2.x * t2.options.mass, i2.x *= o2, i2.y = i2.y * e3.mass + t2.y * t2.options.mass, i2.y *= o2, e3.mass = n2;
            var s2 = Math.max(Math.max(t2.height, t2.radius), t2.width);
            e3.maxWidth = e3.maxWidth < s2 ? s2 : e3.maxWidth;
          } }, { key: "_placeInTree", value: function(e3, t2, i2) {
            1 == i2 && void 0 !== i2 || this._updateBranchMass(e3, t2);
            var n2 = e3.children.NW.range, o2 = void 0;
            o2 = n2.maxX > t2.x ? n2.maxY > t2.y ? "NW" : "SW" : n2.maxY > t2.y ? "NE" : "SE", this._placeInRegion(e3, t2, o2);
          } }, { key: "_placeInRegion", value: function(e3, t2, i2) {
            var n2 = e3.children[i2];
            switch (n2.childrenCount) {
              case 0:
                n2.children.data = t2, n2.childrenCount = 1, this._updateBranchMass(n2, t2);
                break;
              case 1:
                n2.children.data.x === t2.x && n2.children.data.y === t2.y ? (t2.x += this.seededRandom(), t2.y += this.seededRandom()) : (this._splitBranch(n2), this._placeInTree(n2, t2));
                break;
              case 4:
                this._placeInTree(n2, t2);
            }
          } }, { key: "_splitBranch", value: function(e3) {
            var t2 = null;
            1 === e3.childrenCount && (t2 = e3.children.data, e3.mass = 0, e3.centerOfMass.x = 0, e3.centerOfMass.y = 0), e3.childrenCount = 4, e3.children.data = null, this._insertRegion(e3, "NW"), this._insertRegion(e3, "NE"), this._insertRegion(e3, "SW"), this._insertRegion(e3, "SE"), null != t2 && this._placeInTree(e3, t2);
          } }, { key: "_insertRegion", value: function(e3, t2) {
            var i2 = void 0, n2 = void 0, o2 = void 0, s2 = void 0, r2 = 0.5 * e3.size;
            switch (t2) {
              case "NW":
                i2 = e3.range.minX, n2 = e3.range.minX + r2, o2 = e3.range.minY, s2 = e3.range.minY + r2;
                break;
              case "NE":
                i2 = e3.range.minX + r2, n2 = e3.range.maxX, o2 = e3.range.minY, s2 = e3.range.minY + r2;
                break;
              case "SW":
                i2 = e3.range.minX, n2 = e3.range.minX + r2, o2 = e3.range.minY + r2, s2 = e3.range.maxY;
                break;
              case "SE":
                i2 = e3.range.minX + r2, n2 = e3.range.maxX, o2 = e3.range.minY + r2, s2 = e3.range.maxY;
            }
            e3.children[t2] = { centerOfMass: { x: 0, y: 0 }, mass: 0, range: { minX: i2, maxX: n2, minY: o2, maxY: s2 }, size: 0.5 * e3.size, calcSize: 2 * e3.calcSize, children: { data: null }, maxWidth: 0, level: e3.level + 1, childrenCount: 0 };
          } }, { key: "_debug", value: function(e3, t2) {
            void 0 !== this.barnesHutTree && (e3.lineWidth = 1, this._drawBranch(this.barnesHutTree.root, e3, t2));
          } }, { key: "_drawBranch", value: function(e3, t2, i2) {
            void 0 === i2 && (i2 = "#FF0000"), 4 === e3.childrenCount && (this._drawBranch(e3.children.NW, t2), this._drawBranch(e3.children.NE, t2), this._drawBranch(e3.children.SE, t2), this._drawBranch(e3.children.SW, t2)), t2.strokeStyle = i2, t2.beginPath(), t2.moveTo(e3.range.minX, e3.range.minY), t2.lineTo(e3.range.maxX, e3.range.minY), t2.stroke(), t2.beginPath(), t2.moveTo(e3.range.maxX, e3.range.minY), t2.lineTo(e3.range.maxX, e3.range.maxY), t2.stroke(), t2.beginPath(), t2.moveTo(e3.range.maxX, e3.range.maxY), t2.lineTo(e3.range.minX, e3.range.maxY), t2.stroke(), t2.beginPath(), t2.moveTo(e3.range.minX, e3.range.maxY), t2.lineTo(e3.range.minX, e3.range.minY), t2.stroke();
          } }]), e2;
        }();
        t.default = d;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(0), s = n(o), r = i(1), a = n(r), d = function() {
          function e2(t2, i2, n2) {
            (0, s.default)(this, e2), this.body = t2, this.physicsBody = i2, this.setOptions(n2);
          }
          return (0, a.default)(e2, [{ key: "setOptions", value: function(e3) {
            this.options = e3;
          } }, { key: "solve", value: function() {
            for (var e3 = void 0, t2 = void 0, i2 = void 0, n2 = void 0, o2 = this.body.nodes, s2 = this.physicsBody.physicsNodeIndices, r2 = this.physicsBody.forces, a2 = 0; a2 < s2.length; a2++) {
              n2 = o2[s2[a2]], e3 = -n2.x, t2 = -n2.y, i2 = Math.sqrt(e3 * e3 + t2 * t2), this._calculateForces(i2, e3, t2, r2, n2);
            }
          } }, { key: "_calculateForces", value: function(e3, t2, i2, n2, o2) {
            var s2 = 0 === e3 ? 0 : this.options.centralGravity / e3;
            n2[o2.id].x = t2 * s2, n2[o2.id].y = i2 * s2;
          } }]), e2;
        }();
        t.default = d;
      }, function(e, t, i) {
        Object.defineProperty(t, "__esModule", { value: true });
        var n = "string", o = "boolean", s = "number", r = "object", a = ["arrow", "circle", "bar"], d = { configure: { enabled: { boolean: o }, filter: { boolean: o, string: n, array: "array", function: "function" }, container: { dom: "dom" }, showButton: { boolean: o }, __type__: { object: r, boolean: o, string: n, array: "array", function: "function" } }, edges: { arrows: { to: { enabled: { boolean: o }, scaleFactor: { number: s }, type: { string: a }, __type__: { object: r, boolean: o } }, middle: { enabled: { boolean: o }, scaleFactor: { number: s }, type: { string: a }, __type__: { object: r, boolean: o } }, from: { enabled: { boolean: o }, scaleFactor: { number: s }, type: { string: a }, __type__: { object: r, boolean: o } }, __type__: { string: ["from", "to", "middle"], object: r } }, arrowStrikethrough: { boolean: o }, chosen: { label: { boolean: o, function: "function" }, edge: { boolean: o, function: "function" }, __type__: { object: r, boolean: o } }, color: { color: { string: n }, highlight: { string: n }, hover: { string: n }, inherit: { string: ["from", "to", "both"], boolean: o }, opacity: { number: s }, __type__: { object: r, string: n } }, dashes: { boolean: o, array: "array" }, font: { color: { string: n }, size: { number: s }, face: { string: n }, background: { string: n }, strokeWidth: { number: s }, strokeColor: { string: n }, align: { string: ["horizontal", "top", "middle", "bottom"] }, vadjust: { number: s }, multi: { boolean: o, string: n }, bold: { color: { string: n }, size: { number: s }, face: { string: n }, mod: { string: n }, vadjust: { number: s }, __type__: { object: r, string: n } }, boldital: { color: { string: n }, size: { number: s }, face: { string: n }, mod: { string: n }, vadjust: { number: s }, __type__: { object: r, string: n } }, ital: { color: { string: n }, size: { number: s }, face: { string: n }, mod: { string: n }, vadjust: { number: s }, __type__: { object: r, string: n } }, mono: { color: { string: n }, size: { number: s }, face: { string: n }, mod: { string: n }, vadjust: { number: s }, __type__: { object: r, string: n } }, __type__: { object: r, string: n } }, hidden: { boolean: o }, hoverWidth: { function: "function", number: s }, label: { string: n, undefined: "undefined" }, labelHighlightBold: { boolean: o }, length: { number: s, undefined: "undefined" }, physics: { boolean: o }, scaling: { min: { number: s }, max: { number: s }, label: { enabled: { boolean: o }, min: { number: s }, max: { number: s }, maxVisible: { number: s }, drawThreshold: { number: s }, __type__: { object: r, boolean: o } }, customScalingFunction: { function: "function" }, __type__: { object: r } }, selectionWidth: { function: "function", number: s }, selfReferenceSize: { number: s }, shadow: { enabled: { boolean: o }, color: { string: n }, size: { number: s }, x: { number: s }, y: { number: s }, __type__: { object: r, boolean: o } }, smooth: { enabled: { boolean: o }, type: { string: ["dynamic", "continuous", "discrete", "diagonalCross", "straightCross", "horizontal", "vertical", "curvedCW", "curvedCCW", "cubicBezier"] }, roundness: { number: s }, forceDirection: { string: ["horizontal", "vertical", "none"], boolean: o }, __type__: { object: r, boolean: o } }, title: { string: n, undefined: "undefined" }, width: { number: s }, widthConstraint: { maximum: { number: s }, __type__: { object: r, boolean: o, number: s } }, value: { number: s, undefined: "undefined" }, __type__: { object: r } }, groups: { useDefaultGroups: { boolean: o }, __any__: "get from nodes, will be overwritten below", __type__: { object: r } }, interaction: { dragNodes: { boolean: o }, dragView: { boolean: o }, hideEdgesOnDrag: { boolean: o }, hideNodesOnDrag: { boolean: o }, hover: { boolean: o }, keyboard: { enabled: { boolean: o }, speed: { x: { number: s }, y: { number: s }, zoom: { number: s }, __type__: { object: r } }, bindToWindow: { boolean: o }, __type__: { object: r, boolean: o } }, multiselect: { boolean: o }, navigationButtons: { boolean: o }, selectable: { boolean: o }, selectConnectedEdges: { boolean: o }, hoverConnectedEdges: { boolean: o }, tooltipDelay: { number: s }, zoomView: { boolean: o }, __type__: { object: r } }, layout: { randomSeed: { undefined: "undefined", number: s }, improvedLayout: { boolean: o }, hierarchical: { enabled: { boolean: o }, levelSeparation: { number: s }, nodeSpacing: { number: s }, treeSpacing: { number: s }, blockShifting: { boolean: o }, edgeMinimization: { boolean: o }, parentCentralization: { boolean: o }, direction: { string: ["UD", "DU", "LR", "RL"] }, sortMethod: { string: ["hubsize", "directed"] }, __type__: { object: r, boolean: o } }, __type__: { object: r } }, manipulation: { enabled: { boolean: o }, initiallyActive: { boolean: o }, addNode: { boolean: o, function: "function" }, addEdge: { boolean: o, function: "function" }, editNode: { function: "function" }, editEdge: { editWithoutDrag: { function: "function" }, __type__: { object: r, boolean: o, function: "function" } }, deleteNode: { boolean: o, function: "function" }, deleteEdge: { boolean: o, function: "function" }, controlNodeStyle: "get from nodes, will be overwritten below", __type__: { object: r, boolean: o } }, nodes: { borderWidth: { number: s }, borderWidthSelected: { number: s, undefined: "undefined" }, brokenImage: { string: n, undefined: "undefined" }, chosen: { label: { boolean: o, function: "function" }, node: { boolean: o, function: "function" }, __type__: { object: r, boolean: o } }, color: { border: { string: n }, background: { string: n }, highlight: { border: { string: n }, background: { string: n }, __type__: { object: r, string: n } }, hover: { border: { string: n }, background: { string: n }, __type__: { object: r, string: n } }, __type__: { object: r, string: n } }, fixed: { x: { boolean: o }, y: { boolean: o }, __type__: { object: r, boolean: o } }, font: { align: { string: n }, color: { string: n }, size: { number: s }, face: { string: n }, background: { string: n }, strokeWidth: { number: s }, strokeColor: { string: n }, vadjust: { number: s }, multi: { boolean: o, string: n }, bold: { color: { string: n }, size: { number: s }, face: { string: n }, mod: { string: n }, vadjust: { number: s }, __type__: { object: r, string: n } }, boldital: { color: { string: n }, size: { number: s }, face: { string: n }, mod: { string: n }, vadjust: { number: s }, __type__: { object: r, string: n } }, ital: { color: { string: n }, size: { number: s }, face: { string: n }, mod: { string: n }, vadjust: { number: s }, __type__: { object: r, string: n } }, mono: { color: { string: n }, size: { number: s }, face: { string: n }, mod: { string: n }, vadjust: { number: s }, __type__: { object: r, string: n } }, __type__: { object: r, string: n } }, group: { string: n, number: s, undefined: "undefined" }, heightConstraint: { minimum: { number: s }, valign: { string: n }, __type__: { object: r, boolean: o, number: s } }, hidden: { boolean: o }, icon: { face: { string: n }, code: { string: n }, size: { number: s }, color: { string: n }, __type__: { object: r } }, id: { string: n, number: s }, image: { selected: { string: n, undefined: "undefined" }, unselected: { string: n, undefined: "undefined" }, __type__: { object: r, string: n } }, label: { string: n, undefined: "undefined" }, labelHighlightBold: { boolean: o }, level: { number: s, undefined: "undefined" }, margin: { top: { number: s }, right: { number: s }, bottom: { number: s }, left: { number: s }, __type__: { object: r, number: s } }, mass: { number: s }, physics: { boolean: o }, scaling: { min: { number: s }, max: { number: s }, label: { enabled: { boolean: o }, min: { number: s }, max: { number: s }, maxVisible: { number: s }, drawThreshold: { number: s }, __type__: { object: r, boolean: o } }, customScalingFunction: { function: "function" }, __type__: { object: r } }, shadow: { enabled: { boolean: o }, color: { string: n }, size: { number: s }, x: { number: s }, y: { number: s }, __type__: { object: r, boolean: o } }, shape: { string: ["ellipse", "circle", "database", "box", "text", "image", "circularImage", "diamond", "dot", "star", "triangle", "triangleDown", "square", "icon", "hexagon"] }, shapeProperties: { borderDashes: { boolean: o, array: "array" }, borderRadius: { number: s }, interpolation: { boolean: o }, useImageSize: { boolean: o }, useBorderWithImage: { boolean: o }, __type__: { object: r } }, size: { number: s }, title: { string: n, dom: "dom", undefined: "undefined" }, value: { number: s, undefined: "undefined" }, widthConstraint: { minimum: { number: s }, maximum: { number: s }, __type__: { object: r, boolean: o, number: s } }, x: { number: s }, y: { number: s }, __type__: { object: r } }, physics: { enabled: { boolean: o }, barnesHut: { gravitationalConstant: { number: s }, centralGravity: { number: s }, springLength: { number: s }, springConstant: { number: s }, damping: { number: s }, avoidOverlap: { number: s }, __type__: { object: r } }, forceAtlas2Based: { gravitationalConstant: { number: s }, centralGravity: { number: s }, springLength: { number: s }, springConstant: { number: s }, damping: { number: s }, avoidOverlap: { number: s }, __type__: { object: r } }, repulsion: { centralGravity: { number: s }, springLength: { number: s }, springConstant: { number: s }, nodeDistance: { number: s }, damping: { number: s }, __type__: { object: r } }, hierarchicalRepulsion: { centralGravity: { number: s }, springLength: { number: s }, springConstant: { number: s }, nodeDistance: { number: s }, damping: { number: s }, __type__: { object: r } }, maxVelocity: { number: s }, minVelocity: { number: s }, solver: { string: ["barnesHut", "repulsion", "hierarchicalRepulsion", "forceAtlas2Based"] }, stabilization: { enabled: { boolean: o }, iterations: { number: s }, updateInterval: { number: s }, onlyDynamicEdges: { boolean: o }, fit: { boolean: o }, __type__: { object: r, boolean: o } }, timestep: { number: s }, adaptiveTimestep: { boolean: o }, __type__: { object: r, boolean: o } }, autoResize: { boolean: o }, clickToUse: { boolean: o }, locale: { string: n }, locales: { __any__: { any: "any" }, __type__: { object: r } }, height: { string: n }, width: { string: n }, __type__: { object: r } };
        d.groups.__any__ = d.nodes, d.manipulation.controlNodeStyle = d.nodes;
        var h = { nodes: { borderWidth: [1, 0, 10, 1], borderWidthSelected: [2, 0, 10, 1], color: { border: ["color", "#2B7CE9"], background: ["color", "#97C2FC"], highlight: { border: ["color", "#2B7CE9"], background: ["color", "#D2E5FF"] }, hover: { border: ["color", "#2B7CE9"], background: ["color", "#D2E5FF"] } }, fixed: { x: false, y: false }, font: { color: ["color", "#343434"], size: [14, 0, 100, 1], face: ["arial", "verdana", "tahoma"], background: ["color", "none"], strokeWidth: [0, 0, 50, 1], strokeColor: ["color", "#ffffff"] }, hidden: false, labelHighlightBold: true, physics: true, scaling: { min: [10, 0, 200, 1], max: [30, 0, 200, 1], label: { enabled: false, min: [14, 0, 200, 1], max: [30, 0, 200, 1], maxVisible: [30, 0, 200, 1], drawThreshold: [5, 0, 20, 1] } }, shadow: { enabled: false, color: "rgba(0,0,0,0.5)", size: [10, 0, 20, 1], x: [5, -30, 30, 1], y: [5, -30, 30, 1] }, shape: ["ellipse", "box", "circle", "database", "diamond", "dot", "square", "star", "text", "triangle", "triangleDown", "hexagon"], shapeProperties: { borderDashes: false, borderRadius: [6, 0, 20, 1], interpolation: true, useImageSize: false }, size: [25, 0, 200, 1] }, edges: { arrows: { to: { enabled: false, scaleFactor: [1, 0, 3, 0.05], type: "arrow" }, middle: { enabled: false, scaleFactor: [1, 0, 3, 0.05], type: "arrow" }, from: { enabled: false, scaleFactor: [1, 0, 3, 0.05], type: "arrow" } }, arrowStrikethrough: true, color: { color: ["color", "#848484"], highlight: ["color", "#848484"], hover: ["color", "#848484"], inherit: ["from", "to", "both", true, false], opacity: [1, 0, 1, 0.05] }, dashes: false, font: { color: ["color", "#343434"], size: [14, 0, 100, 1], face: ["arial", "verdana", "tahoma"], background: ["color", "none"], strokeWidth: [2, 0, 50, 1], strokeColor: ["color", "#ffffff"], align: ["horizontal", "top", "middle", "bottom"] }, hidden: false, hoverWidth: [1.5, 0, 5, 0.1], labelHighlightBold: true, physics: true, scaling: { min: [1, 0, 100, 1], max: [15, 0, 100, 1], label: { enabled: true, min: [14, 0, 200, 1], max: [30, 0, 200, 1], maxVisible: [30, 0, 200, 1], drawThreshold: [5, 0, 20, 1] } }, selectionWidth: [1.5, 0, 5, 0.1], selfReferenceSize: [20, 0, 200, 1], shadow: { enabled: false, color: "rgba(0,0,0,0.5)", size: [10, 0, 20, 1], x: [5, -30, 30, 1], y: [5, -30, 30, 1] }, smooth: { enabled: true, type: ["dynamic", "continuous", "discrete", "diagonalCross", "straightCross", "horizontal", "vertical", "curvedCW", "curvedCCW", "cubicBezier"], forceDirection: ["horizontal", "vertical", "none"], roundness: [0.5, 0, 1, 0.05] }, width: [1, 0, 30, 1] }, layout: { hierarchical: { enabled: false, levelSeparation: [150, 20, 500, 5], nodeSpacing: [100, 20, 500, 5], treeSpacing: [200, 20, 500, 5], blockShifting: true, edgeMinimization: true, parentCentralization: true, direction: ["UD", "DU", "LR", "RL"], sortMethod: ["hubsize", "directed"] } }, interaction: { dragNodes: true, dragView: true, hideEdgesOnDrag: false, hideNodesOnDrag: false, hover: false, keyboard: { enabled: false, speed: { x: [10, 0, 40, 1], y: [10, 0, 40, 1], zoom: [0.02, 0, 0.1, 5e-3] }, bindToWindow: true }, multiselect: false, navigationButtons: false, selectable: true, selectConnectedEdges: true, hoverConnectedEdges: true, tooltipDelay: [300, 0, 1e3, 25], zoomView: true }, manipulation: { enabled: false, initiallyActive: false }, physics: { enabled: true, barnesHut: { gravitationalConstant: [-2e3, -3e4, 0, 50], centralGravity: [0.3, 0, 10, 0.05], springLength: [95, 0, 500, 5], springConstant: [0.04, 0, 1.2, 5e-3], damping: [0.09, 0, 1, 0.01], avoidOverlap: [0, 0, 1, 0.01] }, forceAtlas2Based: { gravitationalConstant: [-50, -500, 0, 1], centralGravity: [0.01, 0, 1, 5e-3], springLength: [95, 0, 500, 5], springConstant: [0.08, 0, 1.2, 5e-3], damping: [0.4, 0, 1, 0.01], avoidOverlap: [0, 0, 1, 0.01] }, repulsion: { centralGravity: [0.2, 0, 10, 0.05], springLength: [200, 0, 500, 5], springConstant: [0.05, 0, 1.2, 5e-3], nodeDistance: [100, 0, 500, 5], damping: [0.09, 0, 1, 0.01] }, hierarchicalRepulsion: { centralGravity: [0.2, 0, 10, 0.05], springLength: [100, 0, 500, 5], springConstant: [0.01, 0, 1.2, 5e-3], nodeDistance: [120, 0, 500, 5], damping: [0.09, 0, 1, 0.01] }, maxVelocity: [50, 0, 150, 1], minVelocity: [0.1, 0.01, 0.5, 0.01], solver: ["barnesHut", "forceAtlas2Based", "repulsion", "hierarchicalRepulsion"], timestep: [0.5, 0.01, 1, 0.01] } };
        t.allOptions = d, t.configureOptions = h;
      }, function(e, t, i) {
        t.util = i(5), t.DOMutil = i(119), t.DataSet = i(32), t.DataView = i(51), t.Queue = i(72), t.Network = i(121), t.network = { Images: i(76), dotparser: i(74), gephiParser: i(75), allOptions: i(82) }, t.network.convertDot = function(e2) {
          return t.network.dotparser.DOTToGraph(e2);
        }, t.network.convertGephi = function(e2, i2) {
          return t.network.gephiParser.parseGephi(e2, i2);
        }, t.moment = i(71), t.Hammer = i(22), t.keycharm = i(52);
      }, function(e, t, i) {
        i(36), i(47), e.exports = i(96);
      }, function(e, t, i) {
        var n = i(86), o = i(87), s = i(24), r = i(17);
        e.exports = i(60)(Array, "Array", function(e2, t2) {
          this._t = r(e2), this._i = 0, this._k = t2;
        }, function() {
          var e2 = this._t, t2 = this._k, i2 = this._i++;
          return !e2 || i2 >= e2.length ? (this._t = void 0, o(1)) : "keys" == t2 ? o(0, i2) : "values" == t2 ? o(0, e2[i2]) : o(0, [i2, e2[i2]]);
        }, "values"), s.Arguments = s.Array, n("keys"), n("values"), n("entries");
      }, function(e, t) {
        e.exports = function() {
        };
      }, function(e, t) {
        e.exports = function(e2, t2) {
          return { value: t2, done: !!e2 };
        };
      }, function(e, t) {
        e.exports = function(e2) {
          if ("function" != typeof e2)
            throw TypeError(e2 + " is not a function!");
          return e2;
        };
      }, function(e, t, i) {
        var n = i(41), o = i(27), s = i(46), r = {};
        i(18)(r, i(8)("iterator"), function() {
          return this;
        }), e.exports = function(e2, t2, i2) {
          e2.prototype = n(r, { next: o(1, i2) }), s(e2, t2 + " Iterator");
        };
      }, function(e, t, i) {
        var n = i(12), o = i(19), s = i(26);
        e.exports = i(13) ? Object.defineProperties : function(e2, t2) {
          o(e2);
          for (var i2, r = s(t2), a = r.length, d = 0; a > d; )
            n.f(e2, i2 = r[d++], t2[i2]);
          return e2;
        };
      }, function(e, t, i) {
        var n = i(17), o = i(92), s = i(93);
        e.exports = function(e2) {
          return function(t2, i2, r) {
            var a, d = n(t2), h = o(d.length), l = s(r, h);
            if (e2 && i2 != i2) {
              for (; h > l; )
                if ((a = d[l++]) != a)
                  return true;
            } else
              for (; h > l; l++)
                if ((e2 || l in d) && d[l] === i2)
                  return e2 || l || 0;
            return !e2 && -1;
          };
        };
      }, function(e, t, i) {
        var n = i(42), o = Math.min;
        e.exports = function(e2) {
          return e2 > 0 ? o(n(e2), 9007199254740991) : 0;
        };
      }, function(e, t, i) {
        var n = i(42), o = Math.max, s = Math.min;
        e.exports = function(e2, t2) {
          return e2 = n(e2), e2 < 0 ? o(e2 + t2, 0) : s(e2, t2);
        };
      }, function(e, t, i) {
        var n = i(9).document;
        e.exports = n && n.documentElement;
      }, function(e, t, i) {
        var n = i(42), o = i(38);
        e.exports = function(e2) {
          return function(t2, i2) {
            var s, r, a = String(o(t2)), d = n(i2), h = a.length;
            return d < 0 || d >= h ? e2 ? "" : void 0 : (s = a.charCodeAt(d), s < 55296 || s > 56319 || d + 1 === h || (r = a.charCodeAt(d + 1)) < 56320 || r > 57343 ? e2 ? a.charAt(d) : s : e2 ? a.slice(d, d + 2) : r - 56320 + (s - 55296 << 10) + 65536);
          };
        };
      }, function(e, t, i) {
        var n = i(19), o = i(97);
        e.exports = i(6).getIterator = function(e2) {
          var t2 = o(e2);
          if ("function" != typeof t2)
            throw TypeError(e2 + " is not iterable!");
          return n(t2.call(e2));
        };
      }, function(e, t, i) {
        var n = i(67), o = i(8)("iterator"), s = i(24);
        e.exports = i(6).getIteratorMethod = function(e2) {
          if (void 0 != e2)
            return e2[o] || e2["@@iterator"] || s[n(e2)];
        };
      }, function(e, t, i) {
        i(99);
        var n = i(6).Object;
        e.exports = function(e2, t2) {
          return n.create(e2, t2);
        };
      }, function(e, t, i) {
        var n = i(11);
        n(n.S, "Object", { create: i(41) });
      }, function(e, t, i) {
        i(101), e.exports = i(6).Object.keys;
      }, function(e, t, i) {
        var n = i(29), o = i(26);
        i(68)("keys", function() {
          return function(e2) {
            return o(n(e2));
          };
        });
      }, function(e, t, i) {
        e.exports = { default: i(103), __esModule: true };
      }, function(e, t, i) {
        i(47), i(36), e.exports = i(48).f("iterator");
      }, function(e, t, i) {
        e.exports = { default: i(105), __esModule: true };
      }, function(e, t, i) {
        i(106), i(111), i(112), i(113), e.exports = i(6).Symbol;
      }, function(e, t, i) {
        var n = i(9), o = i(14), s = i(13), r = i(11), a = i(64), d = i(107).KEY, h = i(20), l = i(44), u = i(46), c = i(28), f = i(8), p = i(48), v = i(49), g = i(108), y = i(109), m = i(19), b = i(17), _ = i(40), w = i(27), k = i(41), x = i(110), O = i(70), M = i(12), E = i(26), S = O.f, D = M.f, C = x.f, T = n.Symbol, P = n.JSON, I = P && P.stringify, F = f("_hidden"), N = f("toPrimitive"), B = {}.propertyIsEnumerable, z = l("symbol-registry"), R = l("symbols"), A = l("op-symbols"), j = Object.prototype, L = "function" == typeof T, H = n.QObject, W = !H || !H.prototype || !H.prototype.findChild, Y = s && h(function() {
          return 7 != k(D({}, "a", { get: function() {
            return D(this, "a", { value: 7 }).a;
          } })).a;
        }) ? function(e2, t2, i2) {
          var n2 = S(j, t2);
          n2 && delete j[t2], D(e2, t2, i2), n2 && e2 !== j && D(j, t2, n2);
        } : D, V = function(e2) {
          var t2 = R[e2] = k(T.prototype);
          return t2._k = e2, t2;
        }, U = L && "symbol" == typeof T.iterator ? function(e2) {
          return "symbol" == typeof e2;
        } : function(e2) {
          return e2 instanceof T;
        }, q = function(e2, t2, i2) {
          return e2 === j && q(A, t2, i2), m(e2), t2 = _(t2, true), m(i2), o(R, t2) ? (i2.enumerable ? (o(e2, F) && e2[F][t2] && (e2[F][t2] = false), i2 = k(i2, { enumerable: w(0, false) })) : (o(e2, F) || D(e2, F, w(1, {})), e2[F][t2] = true), Y(e2, t2, i2)) : D(e2, t2, i2);
        }, G = function(e2, t2) {
          m(e2);
          for (var i2, n2 = g(t2 = b(t2)), o2 = 0, s2 = n2.length; s2 > o2; )
            q(e2, i2 = n2[o2++], t2[i2]);
          return e2;
        }, X = function(e2, t2) {
          return void 0 === t2 ? k(e2) : G(k(e2), t2);
        }, K = function(e2) {
          var t2 = B.call(this, e2 = _(e2, true));
          return !(this === j && o(R, e2) && !o(A, e2)) && (!(t2 || !o(this, e2) || !o(R, e2) || o(this, F) && this[F][e2]) || t2);
        }, Z = function(e2, t2) {
          if (e2 = b(e2), t2 = _(t2, true), e2 !== j || !o(R, t2) || o(A, t2)) {
            var i2 = S(e2, t2);
            return !i2 || !o(R, t2) || o(e2, F) && e2[F][t2] || (i2.enumerable = true), i2;
          }
        }, $ = function(e2) {
          for (var t2, i2 = C(b(e2)), n2 = [], s2 = 0; i2.length > s2; )
            o(R, t2 = i2[s2++]) || t2 == F || t2 == d || n2.push(t2);
          return n2;
        }, Q = function(e2) {
          for (var t2, i2 = e2 === j, n2 = C(i2 ? A : b(e2)), s2 = [], r2 = 0; n2.length > r2; )
            !o(R, t2 = n2[r2++]) || i2 && !o(j, t2) || s2.push(R[t2]);
          return s2;
        };
        L || (T = function() {
          if (this instanceof T)
            throw TypeError("Symbol is not a constructor!");
          var e2 = c(arguments.length > 0 ? arguments[0] : void 0), t2 = function(i2) {
            this === j && t2.call(A, i2), o(this, F) && o(this[F], e2) && (this[F][e2] = false), Y(this, e2, w(1, i2));
          };
          return s && W && Y(j, e2, { configurable: true, set: t2 }), V(e2);
        }, a(T.prototype, "toString", function() {
          return this._k;
        }), O.f = Z, M.f = q, i(69).f = x.f = $, i(31).f = K, i(50).f = Q, s && !i(39) && a(j, "propertyIsEnumerable", K, true), p.f = function(e2) {
          return V(f(e2));
        }), r(r.G + r.W + r.F * !L, { Symbol: T });
        for (var J = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), ee = 0; J.length > ee; )
          f(J[ee++]);
        for (var te = E(f.store), ie = 0; te.length > ie; )
          v(te[ie++]);
        r(r.S + r.F * !L, "Symbol", { for: function(e2) {
          return o(z, e2 += "") ? z[e2] : z[e2] = T(e2);
        }, keyFor: function(e2) {
          if (!U(e2))
            throw TypeError(e2 + " is not a symbol!");
          for (var t2 in z)
            if (z[t2] === e2)
              return t2;
        }, useSetter: function() {
          W = true;
        }, useSimple: function() {
          W = false;
        } }), r(r.S + r.F * !L, "Object", { create: X, defineProperty: q, defineProperties: G, getOwnPropertyDescriptor: Z, getOwnPropertyNames: $, getOwnPropertySymbols: Q }), P && r(r.S + r.F * (!L || h(function() {
          var e2 = T();
          return "[null]" != I([e2]) || "{}" != I({ a: e2 }) || "{}" != I(Object(e2));
        })), "JSON", { stringify: function(e2) {
          if (void 0 !== e2 && !U(e2)) {
            for (var t2, i2, n2 = [e2], o2 = 1; arguments.length > o2; )
              n2.push(arguments[o2++]);
            return t2 = n2[1], "function" == typeof t2 && (i2 = t2), !i2 && y(t2) || (t2 = function(e3, t3) {
              if (i2 && (t3 = i2.call(this, e3, t3)), !U(t3))
                return t3;
            }), n2[1] = t2, I.apply(P, n2);
          }
        } }), T.prototype[N] || i(18)(T.prototype, N, T.prototype.valueOf), u(T, "Symbol"), u(Math, "Math", true), u(n.JSON, "JSON", true);
      }, function(e, t, i) {
        var n = i(28)("meta"), o = i(25), s = i(14), r = i(12).f, a = 0, d = Object.isExtensible || function() {
          return true;
        }, h = !i(20)(function() {
          return d(Object.preventExtensions({}));
        }), l = function(e2) {
          r(e2, n, { value: { i: "O" + ++a, w: {} } });
        }, u = function(e2, t2) {
          if (!o(e2))
            return "symbol" == typeof e2 ? e2 : ("string" == typeof e2 ? "S" : "P") + e2;
          if (!s(e2, n)) {
            if (!d(e2))
              return "F";
            if (!t2)
              return "E";
            l(e2);
          }
          return e2[n].i;
        }, c = function(e2, t2) {
          if (!s(e2, n)) {
            if (!d(e2))
              return true;
            if (!t2)
              return false;
            l(e2);
          }
          return e2[n].w;
        }, f = function(e2) {
          return h && p.NEED && d(e2) && !s(e2, n) && l(e2), e2;
        }, p = e.exports = { KEY: n, NEED: false, fastKey: u, getWeak: c, onFreeze: f };
      }, function(e, t, i) {
        var n = i(26), o = i(50), s = i(31);
        e.exports = function(e2) {
          var t2 = n(e2), i2 = o.f;
          if (i2)
            for (var r, a = i2(e2), d = s.f, h = 0; a.length > h; )
              d.call(e2, r = a[h++]) && t2.push(r);
          return t2;
        };
      }, function(e, t, i) {
        var n = i(37);
        e.exports = Array.isArray || function(e2) {
          return "Array" == n(e2);
        };
      }, function(e, t, i) {
        var n = i(17), o = i(69).f, s = {}.toString, r = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [], a = function(e2) {
          try {
            return o(e2);
          } catch (e3) {
            return r.slice();
          }
        };
        e.exports.f = function(e2) {
          return r && "[object Window]" == s.call(e2) ? a(e2) : o(n(e2));
        };
      }, function(e, t) {
      }, function(e, t, i) {
        i(49)("asyncIterator");
      }, function(e, t, i) {
        i(49)("observable");
      }, function(e, t, i) {
        (function(e2) {
          !function(t2, i2) {
            e2.exports = i2();
          }(0, function() {
            function t2() {
              return Sn.apply(null, arguments);
            }
            function i2(e3) {
              return e3 instanceof Array || "[object Array]" === Object.prototype.toString.call(e3);
            }
            function n(e3) {
              return null != e3 && "[object Object]" === Object.prototype.toString.call(e3);
            }
            function o(e3) {
              if (Object.getOwnPropertyNames)
                return 0 === Object.getOwnPropertyNames(e3).length;
              var t3;
              for (t3 in e3)
                if (e3.hasOwnProperty(t3))
                  return false;
              return true;
            }
            function s(e3) {
              return void 0 === e3;
            }
            function r(e3) {
              return "number" == typeof e3 || "[object Number]" === Object.prototype.toString.call(e3);
            }
            function a(e3) {
              return e3 instanceof Date || "[object Date]" === Object.prototype.toString.call(e3);
            }
            function d(e3, t3) {
              var i3, n2 = [];
              for (i3 = 0; i3 < e3.length; ++i3)
                n2.push(t3(e3[i3], i3));
              return n2;
            }
            function h(e3, t3) {
              return Object.prototype.hasOwnProperty.call(e3, t3);
            }
            function l(e3, t3) {
              for (var i3 in t3)
                h(t3, i3) && (e3[i3] = t3[i3]);
              return h(t3, "toString") && (e3.toString = t3.toString), h(t3, "valueOf") && (e3.valueOf = t3.valueOf), e3;
            }
            function u(e3, t3, i3, n2) {
              return Ot(e3, t3, i3, n2, true).utc();
            }
            function c() {
              return { empty: false, unusedTokens: [], unusedInput: [], overflow: -2, charsLeftOver: 0, nullInput: false, invalidMonth: null, invalidFormat: false, userInvalidated: false, iso: false, parsedDateParts: [], meridiem: null, rfc2822: false, weekdayMismatch: false };
            }
            function f(e3) {
              return null == e3._pf && (e3._pf = c()), e3._pf;
            }
            function p(e3) {
              if (null == e3._isValid) {
                var t3 = f(e3), i3 = Dn.call(t3.parsedDateParts, function(e4) {
                  return null != e4;
                }), n2 = !isNaN(e3._d.getTime()) && t3.overflow < 0 && !t3.empty && !t3.invalidMonth && !t3.invalidWeekday && !t3.weekdayMismatch && !t3.nullInput && !t3.invalidFormat && !t3.userInvalidated && (!t3.meridiem || t3.meridiem && i3);
                if (e3._strict && (n2 = n2 && 0 === t3.charsLeftOver && 0 === t3.unusedTokens.length && void 0 === t3.bigHour), null != Object.isFrozen && Object.isFrozen(e3))
                  return n2;
                e3._isValid = n2;
              }
              return e3._isValid;
            }
            function v(e3) {
              var t3 = u(NaN);
              return null != e3 ? l(f(t3), e3) : f(t3).userInvalidated = true, t3;
            }
            function g(e3, t3) {
              var i3, n2, o2;
              if (s(t3._isAMomentObject) || (e3._isAMomentObject = t3._isAMomentObject), s(t3._i) || (e3._i = t3._i), s(t3._f) || (e3._f = t3._f), s(t3._l) || (e3._l = t3._l), s(t3._strict) || (e3._strict = t3._strict), s(t3._tzm) || (e3._tzm = t3._tzm), s(t3._isUTC) || (e3._isUTC = t3._isUTC), s(t3._offset) || (e3._offset = t3._offset), s(t3._pf) || (e3._pf = f(t3)), s(t3._locale) || (e3._locale = t3._locale), Cn.length > 0)
                for (i3 = 0; i3 < Cn.length; i3++)
                  n2 = Cn[i3], o2 = t3[n2], s(o2) || (e3[n2] = o2);
              return e3;
            }
            function y(e3) {
              g(this, e3), this._d = new Date(null != e3._d ? e3._d.getTime() : NaN), this.isValid() || (this._d = new Date(NaN)), false === Tn && (Tn = true, t2.updateOffset(this), Tn = false);
            }
            function m(e3) {
              return e3 instanceof y || null != e3 && null != e3._isAMomentObject;
            }
            function b(e3) {
              return e3 < 0 ? Math.ceil(e3) || 0 : Math.floor(e3);
            }
            function _(e3) {
              var t3 = +e3, i3 = 0;
              return 0 !== t3 && isFinite(t3) && (i3 = b(t3)), i3;
            }
            function w(e3, t3, i3) {
              var n2, o2 = Math.min(e3.length, t3.length), s2 = Math.abs(e3.length - t3.length), r2 = 0;
              for (n2 = 0; n2 < o2; n2++)
                (i3 && e3[n2] !== t3[n2] || !i3 && _(e3[n2]) !== _(t3[n2])) && r2++;
              return r2 + s2;
            }
            function k(e3) {
              false === t2.suppressDeprecationWarnings && "undefined" != typeof console && console.warn && console.warn("Deprecation warning: " + e3);
            }
            function x(e3, i3) {
              var n2 = true;
              return l(function() {
                if (null != t2.deprecationHandler && t2.deprecationHandler(null, e3), n2) {
                  for (var o2, s2 = [], r2 = 0; r2 < arguments.length; r2++) {
                    if (o2 = "", "object" == typeof arguments[r2]) {
                      o2 += "\n[" + r2 + "] ";
                      for (var a2 in arguments[0])
                        o2 += a2 + ": " + arguments[0][a2] + ", ";
                      o2 = o2.slice(0, -2);
                    } else
                      o2 = arguments[r2];
                    s2.push(o2);
                  }
                  k(e3 + "\nArguments: " + Array.prototype.slice.call(s2).join("") + "\n" + new Error().stack), n2 = false;
                }
                return i3.apply(this, arguments);
              }, i3);
            }
            function O(e3, i3) {
              null != t2.deprecationHandler && t2.deprecationHandler(e3, i3), Pn[e3] || (k(i3), Pn[e3] = true);
            }
            function M(e3) {
              return e3 instanceof Function || "[object Function]" === Object.prototype.toString.call(e3);
            }
            function E(e3) {
              var t3, i3;
              for (i3 in e3)
                t3 = e3[i3], M(t3) ? this[i3] = t3 : this["_" + i3] = t3;
              this._config = e3, this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source);
            }
            function S(e3, t3) {
              var i3, o2 = l({}, e3);
              for (i3 in t3)
                h(t3, i3) && (n(e3[i3]) && n(t3[i3]) ? (o2[i3] = {}, l(o2[i3], e3[i3]), l(o2[i3], t3[i3])) : null != t3[i3] ? o2[i3] = t3[i3] : delete o2[i3]);
              for (i3 in e3)
                h(e3, i3) && !h(t3, i3) && n(e3[i3]) && (o2[i3] = l({}, o2[i3]));
              return o2;
            }
            function D(e3) {
              null != e3 && this.set(e3);
            }
            function C(e3, t3, i3) {
              var n2 = this._calendar[e3] || this._calendar.sameElse;
              return M(n2) ? n2.call(t3, i3) : n2;
            }
            function T(e3) {
              var t3 = this._longDateFormat[e3], i3 = this._longDateFormat[e3.toUpperCase()];
              return t3 || !i3 ? t3 : (this._longDateFormat[e3] = i3.replace(/MMMM|MM|DD|dddd/g, function(e4) {
                return e4.slice(1);
              }), this._longDateFormat[e3]);
            }
            function P() {
              return this._invalidDate;
            }
            function I(e3) {
              return this._ordinal.replace("%d", e3);
            }
            function F(e3, t3, i3, n2) {
              var o2 = this._relativeTime[i3];
              return M(o2) ? o2(e3, t3, i3, n2) : o2.replace(/%d/i, e3);
            }
            function N(e3, t3) {
              var i3 = this._relativeTime[e3 > 0 ? "future" : "past"];
              return M(i3) ? i3(t3) : i3.replace(/%s/i, t3);
            }
            function B(e3, t3) {
              var i3 = e3.toLowerCase();
              Rn[i3] = Rn[i3 + "s"] = Rn[t3] = e3;
            }
            function z(e3) {
              return "string" == typeof e3 ? Rn[e3] || Rn[e3.toLowerCase()] : void 0;
            }
            function R(e3) {
              var t3, i3, n2 = {};
              for (i3 in e3)
                h(e3, i3) && (t3 = z(i3)) && (n2[t3] = e3[i3]);
              return n2;
            }
            function A(e3, t3) {
              An[e3] = t3;
            }
            function j(e3) {
              var t3 = [];
              for (var i3 in e3)
                t3.push({ unit: i3, priority: An[i3] });
              return t3.sort(function(e4, t4) {
                return e4.priority - t4.priority;
              }), t3;
            }
            function L(e3, t3, i3) {
              var n2 = "" + Math.abs(e3), o2 = t3 - n2.length;
              return (e3 >= 0 ? i3 ? "+" : "" : "-") + Math.pow(10, Math.max(0, o2)).toString().substr(1) + n2;
            }
            function H(e3, t3, i3, n2) {
              var o2 = n2;
              "string" == typeof n2 && (o2 = function() {
                return this[n2]();
              }), e3 && (Wn[e3] = o2), t3 && (Wn[t3[0]] = function() {
                return L(o2.apply(this, arguments), t3[1], t3[2]);
              }), i3 && (Wn[i3] = function() {
                return this.localeData().ordinal(o2.apply(this, arguments), e3);
              });
            }
            function W(e3) {
              return e3.match(/\[[\s\S]/) ? e3.replace(/^\[|\]$/g, "") : e3.replace(/\\/g, "");
            }
            function Y(e3) {
              var t3, i3, n2 = e3.match(jn);
              for (t3 = 0, i3 = n2.length; t3 < i3; t3++)
                Wn[n2[t3]] ? n2[t3] = Wn[n2[t3]] : n2[t3] = W(n2[t3]);
              return function(t4) {
                var o2, s2 = "";
                for (o2 = 0; o2 < i3; o2++)
                  s2 += M(n2[o2]) ? n2[o2].call(t4, e3) : n2[o2];
                return s2;
              };
            }
            function V(e3, t3) {
              return e3.isValid() ? (t3 = U(t3, e3.localeData()), Hn[t3] = Hn[t3] || Y(t3), Hn[t3](e3)) : e3.localeData().invalidDate();
            }
            function U(e3, t3) {
              function i3(e4) {
                return t3.longDateFormat(e4) || e4;
              }
              var n2 = 5;
              for (Ln.lastIndex = 0; n2 >= 0 && Ln.test(e3); )
                e3 = e3.replace(Ln, i3), Ln.lastIndex = 0, n2 -= 1;
              return e3;
            }
            function q(e3, t3, i3) {
              ro[e3] = M(t3) ? t3 : function(e4, n2) {
                return e4 && i3 ? i3 : t3;
              };
            }
            function G(e3, t3) {
              return h(ro, e3) ? ro[e3](t3._strict, t3._locale) : new RegExp(X(e3));
            }
            function X(e3) {
              return K(e3.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(e4, t3, i3, n2, o2) {
                return t3 || i3 || n2 || o2;
              }));
            }
            function K(e3) {
              return e3.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
            }
            function Z(e3, t3) {
              var i3, n2 = t3;
              for ("string" == typeof e3 && (e3 = [e3]), r(t3) && (n2 = function(e4, i4) {
                i4[t3] = _(e4);
              }), i3 = 0; i3 < e3.length; i3++)
                ao[e3[i3]] = n2;
            }
            function $(e3, t3) {
              Z(e3, function(e4, i3, n2, o2) {
                n2._w = n2._w || {}, t3(e4, n2._w, n2, o2);
              });
            }
            function Q(e3, t3, i3) {
              null != t3 && h(ao, e3) && ao[e3](t3, i3._a, i3, e3);
            }
            function J(e3) {
              return ee(e3) ? 366 : 365;
            }
            function ee(e3) {
              return e3 % 4 == 0 && e3 % 100 != 0 || e3 % 400 == 0;
            }
            function te() {
              return ee(this.year());
            }
            function ie(e3, i3) {
              return function(n2) {
                return null != n2 ? (oe(this, e3, n2), t2.updateOffset(this, i3), this) : ne(this, e3);
              };
            }
            function ne(e3, t3) {
              return e3.isValid() ? e3._d["get" + (e3._isUTC ? "UTC" : "") + t3]() : NaN;
            }
            function oe(e3, t3, i3) {
              e3.isValid() && !isNaN(i3) && ("FullYear" === t3 && ee(e3.year()) ? e3._d["set" + (e3._isUTC ? "UTC" : "") + t3](i3, e3.month(), de(i3, e3.month())) : e3._d["set" + (e3._isUTC ? "UTC" : "") + t3](i3));
            }
            function se(e3) {
              return e3 = z(e3), M(this[e3]) ? this[e3]() : this;
            }
            function re(e3, t3) {
              if ("object" == typeof e3) {
                e3 = R(e3);
                for (var i3 = j(e3), n2 = 0; n2 < i3.length; n2++)
                  this[i3[n2].unit](e3[i3[n2].unit]);
              } else if (e3 = z(e3), M(this[e3]))
                return this[e3](t3);
              return this;
            }
            function ae(e3, t3) {
              return (e3 % t3 + t3) % t3;
            }
            function de(e3, t3) {
              if (isNaN(e3) || isNaN(t3))
                return NaN;
              var i3 = ae(t3, 12);
              return e3 += (t3 - i3) / 12, 1 === i3 ? ee(e3) ? 29 : 28 : 31 - i3 % 7 % 2;
            }
            function he(e3, t3) {
              return e3 ? i2(this._months) ? this._months[e3.month()] : this._months[(this._months.isFormat || _o).test(t3) ? "format" : "standalone"][e3.month()] : i2(this._months) ? this._months : this._months.standalone;
            }
            function le(e3, t3) {
              return e3 ? i2(this._monthsShort) ? this._monthsShort[e3.month()] : this._monthsShort[_o.test(t3) ? "format" : "standalone"][e3.month()] : i2(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone;
            }
            function ue(e3, t3, i3) {
              var n2, o2, s2, r2 = e3.toLocaleLowerCase();
              if (!this._monthsParse)
                for (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = [], n2 = 0; n2 < 12; ++n2)
                  s2 = u([2e3, n2]), this._shortMonthsParse[n2] = this.monthsShort(s2, "").toLocaleLowerCase(), this._longMonthsParse[n2] = this.months(s2, "").toLocaleLowerCase();
              return i3 ? "MMM" === t3 ? (o2 = mo.call(this._shortMonthsParse, r2), -1 !== o2 ? o2 : null) : (o2 = mo.call(this._longMonthsParse, r2), -1 !== o2 ? o2 : null) : "MMM" === t3 ? -1 !== (o2 = mo.call(this._shortMonthsParse, r2)) ? o2 : (o2 = mo.call(this._longMonthsParse, r2), -1 !== o2 ? o2 : null) : -1 !== (o2 = mo.call(this._longMonthsParse, r2)) ? o2 : (o2 = mo.call(this._shortMonthsParse, r2), -1 !== o2 ? o2 : null);
            }
            function ce(e3, t3, i3) {
              var n2, o2, s2;
              if (this._monthsParseExact)
                return ue.call(this, e3, t3, i3);
              for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), n2 = 0; n2 < 12; n2++) {
                if (o2 = u([2e3, n2]), i3 && !this._longMonthsParse[n2] && (this._longMonthsParse[n2] = new RegExp("^" + this.months(o2, "").replace(".", "") + "$", "i"), this._shortMonthsParse[n2] = new RegExp("^" + this.monthsShort(o2, "").replace(".", "") + "$", "i")), i3 || this._monthsParse[n2] || (s2 = "^" + this.months(o2, "") + "|^" + this.monthsShort(o2, ""), this._monthsParse[n2] = new RegExp(s2.replace(".", ""), "i")), i3 && "MMMM" === t3 && this._longMonthsParse[n2].test(e3))
                  return n2;
                if (i3 && "MMM" === t3 && this._shortMonthsParse[n2].test(e3))
                  return n2;
                if (!i3 && this._monthsParse[n2].test(e3))
                  return n2;
              }
            }
            function fe(e3, t3) {
              var i3;
              if (!e3.isValid())
                return e3;
              if ("string" == typeof t3) {
                if (/^\d+$/.test(t3))
                  t3 = _(t3);
                else if (t3 = e3.localeData().monthsParse(t3), !r(t3))
                  return e3;
              }
              return i3 = Math.min(e3.date(), de(e3.year(), t3)), e3._d["set" + (e3._isUTC ? "UTC" : "") + "Month"](t3, i3), e3;
            }
            function pe(e3) {
              return null != e3 ? (fe(this, e3), t2.updateOffset(this, true), this) : ne(this, "Month");
            }
            function ve() {
              return de(this.year(), this.month());
            }
            function ge(e3) {
              return this._monthsParseExact ? (h(this, "_monthsRegex") || me.call(this), e3 ? this._monthsShortStrictRegex : this._monthsShortRegex) : (h(this, "_monthsShortRegex") || (this._monthsShortRegex = xo), this._monthsShortStrictRegex && e3 ? this._monthsShortStrictRegex : this._monthsShortRegex);
            }
            function ye(e3) {
              return this._monthsParseExact ? (h(this, "_monthsRegex") || me.call(this), e3 ? this._monthsStrictRegex : this._monthsRegex) : (h(this, "_monthsRegex") || (this._monthsRegex = Oo), this._monthsStrictRegex && e3 ? this._monthsStrictRegex : this._monthsRegex);
            }
            function me() {
              function e3(e4, t4) {
                return t4.length - e4.length;
              }
              var t3, i3, n2 = [], o2 = [], s2 = [];
              for (t3 = 0; t3 < 12; t3++)
                i3 = u([2e3, t3]), n2.push(this.monthsShort(i3, "")), o2.push(this.months(i3, "")), s2.push(this.months(i3, "")), s2.push(this.monthsShort(i3, ""));
              for (n2.sort(e3), o2.sort(e3), s2.sort(e3), t3 = 0; t3 < 12; t3++)
                n2[t3] = K(n2[t3]), o2[t3] = K(o2[t3]);
              for (t3 = 0; t3 < 24; t3++)
                s2[t3] = K(s2[t3]);
              this._monthsRegex = new RegExp("^(" + s2.join("|") + ")", "i"), this._monthsShortRegex = this._monthsRegex, this._monthsStrictRegex = new RegExp("^(" + o2.join("|") + ")", "i"), this._monthsShortStrictRegex = new RegExp("^(" + n2.join("|") + ")", "i");
            }
            function be(e3, t3, i3, n2, o2, s2, r2) {
              var a2 = new Date(e3, t3, i3, n2, o2, s2, r2);
              return e3 < 100 && e3 >= 0 && isFinite(a2.getFullYear()) && a2.setFullYear(e3), a2;
            }
            function _e(e3) {
              var t3 = new Date(Date.UTC.apply(null, arguments));
              return e3 < 100 && e3 >= 0 && isFinite(t3.getUTCFullYear()) && t3.setUTCFullYear(e3), t3;
            }
            function we(e3, t3, i3) {
              var n2 = 7 + t3 - i3;
              return -(7 + _e(e3, 0, n2).getUTCDay() - t3) % 7 + n2 - 1;
            }
            function ke(e3, t3, i3, n2, o2) {
              var s2, r2, a2 = (7 + i3 - n2) % 7, d2 = we(e3, n2, o2), h2 = 1 + 7 * (t3 - 1) + a2 + d2;
              return h2 <= 0 ? (s2 = e3 - 1, r2 = J(s2) + h2) : h2 > J(e3) ? (s2 = e3 + 1, r2 = h2 - J(e3)) : (s2 = e3, r2 = h2), { year: s2, dayOfYear: r2 };
            }
            function xe(e3, t3, i3) {
              var n2, o2, s2 = we(e3.year(), t3, i3), r2 = Math.floor((e3.dayOfYear() - s2 - 1) / 7) + 1;
              return r2 < 1 ? (o2 = e3.year() - 1, n2 = r2 + Oe(o2, t3, i3)) : r2 > Oe(e3.year(), t3, i3) ? (n2 = r2 - Oe(e3.year(), t3, i3), o2 = e3.year() + 1) : (o2 = e3.year(), n2 = r2), { week: n2, year: o2 };
            }
            function Oe(e3, t3, i3) {
              var n2 = we(e3, t3, i3), o2 = we(e3 + 1, t3, i3);
              return (J(e3) - n2 + o2) / 7;
            }
            function Me(e3) {
              return xe(e3, this._week.dow, this._week.doy).week;
            }
            function Ee() {
              return this._week.dow;
            }
            function Se() {
              return this._week.doy;
            }
            function De(e3) {
              var t3 = this.localeData().week(this);
              return null == e3 ? t3 : this.add(7 * (e3 - t3), "d");
            }
            function Ce(e3) {
              var t3 = xe(this, 1, 4).week;
              return null == e3 ? t3 : this.add(7 * (e3 - t3), "d");
            }
            function Te(e3, t3) {
              return "string" != typeof e3 ? e3 : isNaN(e3) ? (e3 = t3.weekdaysParse(e3), "number" == typeof e3 ? e3 : null) : parseInt(e3, 10);
            }
            function Pe(e3, t3) {
              return "string" == typeof e3 ? t3.weekdaysParse(e3) % 7 || 7 : isNaN(e3) ? null : e3;
            }
            function Ie(e3, t3) {
              return e3 ? i2(this._weekdays) ? this._weekdays[e3.day()] : this._weekdays[this._weekdays.isFormat.test(t3) ? "format" : "standalone"][e3.day()] : i2(this._weekdays) ? this._weekdays : this._weekdays.standalone;
            }
            function Fe(e3) {
              return e3 ? this._weekdaysShort[e3.day()] : this._weekdaysShort;
            }
            function Ne(e3) {
              return e3 ? this._weekdaysMin[e3.day()] : this._weekdaysMin;
            }
            function Be(e3, t3, i3) {
              var n2, o2, s2, r2 = e3.toLocaleLowerCase();
              if (!this._weekdaysParse)
                for (this._weekdaysParse = [], this._shortWeekdaysParse = [], this._minWeekdaysParse = [], n2 = 0; n2 < 7; ++n2)
                  s2 = u([2e3, 1]).day(n2), this._minWeekdaysParse[n2] = this.weekdaysMin(s2, "").toLocaleLowerCase(), this._shortWeekdaysParse[n2] = this.weekdaysShort(s2, "").toLocaleLowerCase(), this._weekdaysParse[n2] = this.weekdays(s2, "").toLocaleLowerCase();
              return i3 ? "dddd" === t3 ? (o2 = mo.call(this._weekdaysParse, r2), -1 !== o2 ? o2 : null) : "ddd" === t3 ? (o2 = mo.call(this._shortWeekdaysParse, r2), -1 !== o2 ? o2 : null) : (o2 = mo.call(this._minWeekdaysParse, r2), -1 !== o2 ? o2 : null) : "dddd" === t3 ? -1 !== (o2 = mo.call(this._weekdaysParse, r2)) ? o2 : -1 !== (o2 = mo.call(this._shortWeekdaysParse, r2)) ? o2 : (o2 = mo.call(this._minWeekdaysParse, r2), -1 !== o2 ? o2 : null) : "ddd" === t3 ? -1 !== (o2 = mo.call(this._shortWeekdaysParse, r2)) ? o2 : -1 !== (o2 = mo.call(this._weekdaysParse, r2)) ? o2 : (o2 = mo.call(this._minWeekdaysParse, r2), -1 !== o2 ? o2 : null) : -1 !== (o2 = mo.call(this._minWeekdaysParse, r2)) ? o2 : -1 !== (o2 = mo.call(this._weekdaysParse, r2)) ? o2 : (o2 = mo.call(this._shortWeekdaysParse, r2), -1 !== o2 ? o2 : null);
            }
            function ze(e3, t3, i3) {
              var n2, o2, s2;
              if (this._weekdaysParseExact)
                return Be.call(this, e3, t3, i3);
              for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), n2 = 0; n2 < 7; n2++) {
                if (o2 = u([2e3, 1]).day(n2), i3 && !this._fullWeekdaysParse[n2] && (this._fullWeekdaysParse[n2] = new RegExp("^" + this.weekdays(o2, "").replace(".", ".?") + "$", "i"), this._shortWeekdaysParse[n2] = new RegExp("^" + this.weekdaysShort(o2, "").replace(".", ".?") + "$", "i"), this._minWeekdaysParse[n2] = new RegExp("^" + this.weekdaysMin(o2, "").replace(".", ".?") + "$", "i")), this._weekdaysParse[n2] || (s2 = "^" + this.weekdays(o2, "") + "|^" + this.weekdaysShort(o2, "") + "|^" + this.weekdaysMin(o2, ""), this._weekdaysParse[n2] = new RegExp(s2.replace(".", ""), "i")), i3 && "dddd" === t3 && this._fullWeekdaysParse[n2].test(e3))
                  return n2;
                if (i3 && "ddd" === t3 && this._shortWeekdaysParse[n2].test(e3))
                  return n2;
                if (i3 && "dd" === t3 && this._minWeekdaysParse[n2].test(e3))
                  return n2;
                if (!i3 && this._weekdaysParse[n2].test(e3))
                  return n2;
              }
            }
            function Re(e3) {
              if (!this.isValid())
                return null != e3 ? this : NaN;
              var t3 = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
              return null != e3 ? (e3 = Te(e3, this.localeData()), this.add(e3 - t3, "d")) : t3;
            }
            function Ae(e3) {
              if (!this.isValid())
                return null != e3 ? this : NaN;
              var t3 = (this.day() + 7 - this.localeData()._week.dow) % 7;
              return null == e3 ? t3 : this.add(e3 - t3, "d");
            }
            function je(e3) {
              if (!this.isValid())
                return null != e3 ? this : NaN;
              if (null != e3) {
                var t3 = Pe(e3, this.localeData());
                return this.day(this.day() % 7 ? t3 : t3 - 7);
              }
              return this.day() || 7;
            }
            function Le(e3) {
              return this._weekdaysParseExact ? (h(this, "_weekdaysRegex") || Ye.call(this), e3 ? this._weekdaysStrictRegex : this._weekdaysRegex) : (h(this, "_weekdaysRegex") || (this._weekdaysRegex = Co), this._weekdaysStrictRegex && e3 ? this._weekdaysStrictRegex : this._weekdaysRegex);
            }
            function He(e3) {
              return this._weekdaysParseExact ? (h(this, "_weekdaysRegex") || Ye.call(this), e3 ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (h(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = To), this._weekdaysShortStrictRegex && e3 ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex);
            }
            function We(e3) {
              return this._weekdaysParseExact ? (h(this, "_weekdaysRegex") || Ye.call(this), e3 ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (h(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = Po), this._weekdaysMinStrictRegex && e3 ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex);
            }
            function Ye() {
              function e3(e4, t4) {
                return t4.length - e4.length;
              }
              var t3, i3, n2, o2, s2, r2 = [], a2 = [], d2 = [], h2 = [];
              for (t3 = 0; t3 < 7; t3++)
                i3 = u([2e3, 1]).day(t3), n2 = this.weekdaysMin(i3, ""), o2 = this.weekdaysShort(i3, ""), s2 = this.weekdays(i3, ""), r2.push(n2), a2.push(o2), d2.push(s2), h2.push(n2), h2.push(o2), h2.push(s2);
              for (r2.sort(e3), a2.sort(e3), d2.sort(e3), h2.sort(e3), t3 = 0; t3 < 7; t3++)
                a2[t3] = K(a2[t3]), d2[t3] = K(d2[t3]), h2[t3] = K(h2[t3]);
              this._weekdaysRegex = new RegExp("^(" + h2.join("|") + ")", "i"), this._weekdaysShortRegex = this._weekdaysRegex, this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp("^(" + d2.join("|") + ")", "i"), this._weekdaysShortStrictRegex = new RegExp("^(" + a2.join("|") + ")", "i"), this._weekdaysMinStrictRegex = new RegExp("^(" + r2.join("|") + ")", "i");
            }
            function Ve() {
              return this.hours() % 12 || 12;
            }
            function Ue() {
              return this.hours() || 24;
            }
            function qe(e3, t3) {
              H(e3, 0, 0, function() {
                return this.localeData().meridiem(this.hours(), this.minutes(), t3);
              });
            }
            function Ge(e3, t3) {
              return t3._meridiemParse;
            }
            function Xe(e3) {
              return "p" === (e3 + "").toLowerCase().charAt(0);
            }
            function Ke(e3, t3, i3) {
              return e3 > 11 ? i3 ? "pm" : "PM" : i3 ? "am" : "AM";
            }
            function Ze(e3) {
              return e3 ? e3.toLowerCase().replace("_", "-") : e3;
            }
            function $e(e3) {
              for (var t3, i3, n2, o2, s2 = 0; s2 < e3.length; ) {
                for (o2 = Ze(e3[s2]).split("-"), t3 = o2.length, i3 = Ze(e3[s2 + 1]), i3 = i3 ? i3.split("-") : null; t3 > 0; ) {
                  if (n2 = Qe(o2.slice(0, t3).join("-")))
                    return n2;
                  if (i3 && i3.length >= t3 && w(o2, i3, true) >= t3 - 1)
                    break;
                  t3--;
                }
                s2++;
              }
              return null;
            }
            function Qe(t3) {
              var i3 = null;
              if (!zo[t3] && void 0 !== e2 && e2 && e2.exports)
                try {
                  i3 = Io._abbr;
                  !function() {
                    var e3 = new Error('Cannot find module "./locale"');
                    throw e3.code = "MODULE_NOT_FOUND", e3;
                  }(), Je(i3);
                } catch (e3) {
                }
              return zo[t3];
            }
            function Je(e3, t3) {
              var i3;
              return e3 && (i3 = s(t3) ? it(e3) : et(e3, t3)) && (Io = i3), Io._abbr;
            }
            function et(e3, t3) {
              if (null !== t3) {
                var i3 = Bo;
                if (t3.abbr = e3, null != zo[e3])
                  O("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."), i3 = zo[e3]._config;
                else if (null != t3.parentLocale) {
                  if (null == zo[t3.parentLocale])
                    return Ro[t3.parentLocale] || (Ro[t3.parentLocale] = []), Ro[t3.parentLocale].push({ name: e3, config: t3 }), null;
                  i3 = zo[t3.parentLocale]._config;
                }
                return zo[e3] = new D(S(i3, t3)), Ro[e3] && Ro[e3].forEach(function(e4) {
                  et(e4.name, e4.config);
                }), Je(e3), zo[e3];
              }
              return delete zo[e3], null;
            }
            function tt(e3, t3) {
              if (null != t3) {
                var i3, n2 = Bo;
                null != zo[e3] && (n2 = zo[e3]._config), t3 = S(n2, t3), i3 = new D(t3), i3.parentLocale = zo[e3], zo[e3] = i3, Je(e3);
              } else
                null != zo[e3] && (null != zo[e3].parentLocale ? zo[e3] = zo[e3].parentLocale : null != zo[e3] && delete zo[e3]);
              return zo[e3];
            }
            function it(e3) {
              var t3;
              if (e3 && e3._locale && e3._locale._abbr && (e3 = e3._locale._abbr), !e3)
                return Io;
              if (!i2(e3)) {
                if (t3 = Qe(e3))
                  return t3;
                e3 = [e3];
              }
              return $e(e3);
            }
            function nt() {
              return In(zo);
            }
            function ot(e3) {
              var t3, i3 = e3._a;
              return i3 && -2 === f(e3).overflow && (t3 = i3[lo] < 0 || i3[lo] > 11 ? lo : i3[uo] < 1 || i3[uo] > de(i3[ho], i3[lo]) ? uo : i3[co] < 0 || i3[co] > 24 || 24 === i3[co] && (0 !== i3[fo] || 0 !== i3[po] || 0 !== i3[vo]) ? co : i3[fo] < 0 || i3[fo] > 59 ? fo : i3[po] < 0 || i3[po] > 59 ? po : i3[vo] < 0 || i3[vo] > 999 ? vo : -1, f(e3)._overflowDayOfYear && (t3 < ho || t3 > uo) && (t3 = uo), f(e3)._overflowWeeks && -1 === t3 && (t3 = go), f(e3)._overflowWeekday && -1 === t3 && (t3 = yo), f(e3).overflow = t3), e3;
            }
            function st(e3, t3, i3) {
              return null != e3 ? e3 : null != t3 ? t3 : i3;
            }
            function rt(e3) {
              var i3 = new Date(t2.now());
              return e3._useUTC ? [i3.getUTCFullYear(), i3.getUTCMonth(), i3.getUTCDate()] : [i3.getFullYear(), i3.getMonth(), i3.getDate()];
            }
            function at(e3) {
              var t3, i3, n2, o2, s2 = [];
              if (!e3._d) {
                for (n2 = rt(e3), e3._w && null == e3._a[uo] && null == e3._a[lo] && dt(e3), null != e3._dayOfYear && (o2 = st(e3._a[ho], n2[ho]), (e3._dayOfYear > J(o2) || 0 === e3._dayOfYear) && (f(e3)._overflowDayOfYear = true), i3 = _e(o2, 0, e3._dayOfYear), e3._a[lo] = i3.getUTCMonth(), e3._a[uo] = i3.getUTCDate()), t3 = 0; t3 < 3 && null == e3._a[t3]; ++t3)
                  e3._a[t3] = s2[t3] = n2[t3];
                for (; t3 < 7; t3++)
                  e3._a[t3] = s2[t3] = null == e3._a[t3] ? 2 === t3 ? 1 : 0 : e3._a[t3];
                24 === e3._a[co] && 0 === e3._a[fo] && 0 === e3._a[po] && 0 === e3._a[vo] && (e3._nextDay = true, e3._a[co] = 0), e3._d = (e3._useUTC ? _e : be).apply(null, s2), null != e3._tzm && e3._d.setUTCMinutes(e3._d.getUTCMinutes() - e3._tzm), e3._nextDay && (e3._a[co] = 24), e3._w && void 0 !== e3._w.d && e3._w.d !== e3._d.getDay() && (f(e3).weekdayMismatch = true);
              }
            }
            function dt(e3) {
              var t3, i3, n2, o2, s2, r2, a2, d2;
              if (t3 = e3._w, null != t3.GG || null != t3.W || null != t3.E)
                s2 = 1, r2 = 4, i3 = st(t3.GG, e3._a[ho], xe(Mt(), 1, 4).year), n2 = st(t3.W, 1), ((o2 = st(t3.E, 1)) < 1 || o2 > 7) && (d2 = true);
              else {
                s2 = e3._locale._week.dow, r2 = e3._locale._week.doy;
                var h2 = xe(Mt(), s2, r2);
                i3 = st(t3.gg, e3._a[ho], h2.year), n2 = st(t3.w, h2.week), null != t3.d ? ((o2 = t3.d) < 0 || o2 > 6) && (d2 = true) : null != t3.e ? (o2 = t3.e + s2, (t3.e < 0 || t3.e > 6) && (d2 = true)) : o2 = s2;
              }
              n2 < 1 || n2 > Oe(i3, s2, r2) ? f(e3)._overflowWeeks = true : null != d2 ? f(e3)._overflowWeekday = true : (a2 = ke(i3, n2, o2, s2, r2), e3._a[ho] = a2.year, e3._dayOfYear = a2.dayOfYear);
            }
            function ht(e3) {
              var t3, i3, n2, o2, s2, r2, a2 = e3._i, d2 = Ao.exec(a2) || jo.exec(a2);
              if (d2) {
                for (f(e3).iso = true, t3 = 0, i3 = Ho.length; t3 < i3; t3++)
                  if (Ho[t3][1].exec(d2[1])) {
                    o2 = Ho[t3][0], n2 = false !== Ho[t3][2];
                    break;
                  }
                if (null == o2)
                  return void (e3._isValid = false);
                if (d2[3]) {
                  for (t3 = 0, i3 = Wo.length; t3 < i3; t3++)
                    if (Wo[t3][1].exec(d2[3])) {
                      s2 = (d2[2] || " ") + Wo[t3][0];
                      break;
                    }
                  if (null == s2)
                    return void (e3._isValid = false);
                }
                if (!n2 && null != s2)
                  return void (e3._isValid = false);
                if (d2[4]) {
                  if (!Lo.exec(d2[4]))
                    return void (e3._isValid = false);
                  r2 = "Z";
                }
                e3._f = o2 + (s2 || "") + (r2 || ""), yt(e3);
              } else
                e3._isValid = false;
            }
            function lt(e3, t3, i3, n2, o2, s2) {
              var r2 = [ut(e3), ko.indexOf(t3), parseInt(i3, 10), parseInt(n2, 10), parseInt(o2, 10)];
              return s2 && r2.push(parseInt(s2, 10)), r2;
            }
            function ut(e3) {
              var t3 = parseInt(e3, 10);
              return t3 <= 49 ? 2e3 + t3 : t3 <= 999 ? 1900 + t3 : t3;
            }
            function ct(e3) {
              return e3.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
            }
            function ft(e3, t3, i3) {
              if (e3) {
                if (So.indexOf(e3) !== new Date(t3[0], t3[1], t3[2]).getDay())
                  return f(i3).weekdayMismatch = true, i3._isValid = false, false;
              }
              return true;
            }
            function pt(e3, t3, i3) {
              if (e3)
                return Uo[e3];
              if (t3)
                return 0;
              var n2 = parseInt(i3, 10), o2 = n2 % 100;
              return (n2 - o2) / 100 * 60 + o2;
            }
            function vt(e3) {
              var t3 = Vo.exec(ct(e3._i));
              if (t3) {
                var i3 = lt(t3[4], t3[3], t3[2], t3[5], t3[6], t3[7]);
                if (!ft(t3[1], i3, e3))
                  return;
                e3._a = i3, e3._tzm = pt(t3[8], t3[9], t3[10]), e3._d = _e.apply(null, e3._a), e3._d.setUTCMinutes(e3._d.getUTCMinutes() - e3._tzm), f(e3).rfc2822 = true;
              } else
                e3._isValid = false;
            }
            function gt(e3) {
              var i3 = Yo.exec(e3._i);
              if (null !== i3)
                return void (e3._d = new Date(+i3[1]));
              ht(e3), false === e3._isValid && (delete e3._isValid, vt(e3), false === e3._isValid && (delete e3._isValid, t2.createFromInputFallback(e3)));
            }
            function yt(e3) {
              if (e3._f === t2.ISO_8601)
                return void ht(e3);
              if (e3._f === t2.RFC_2822)
                return void vt(e3);
              e3._a = [], f(e3).empty = true;
              var i3, n2, o2, s2, r2, a2 = "" + e3._i, d2 = a2.length, h2 = 0;
              for (o2 = U(e3._f, e3._locale).match(jn) || [], i3 = 0; i3 < o2.length; i3++)
                s2 = o2[i3], n2 = (a2.match(G(s2, e3)) || [])[0], n2 && (r2 = a2.substr(0, a2.indexOf(n2)), r2.length > 0 && f(e3).unusedInput.push(r2), a2 = a2.slice(a2.indexOf(n2) + n2.length), h2 += n2.length), Wn[s2] ? (n2 ? f(e3).empty = false : f(e3).unusedTokens.push(s2), Q(s2, n2, e3)) : e3._strict && !n2 && f(e3).unusedTokens.push(s2);
              f(e3).charsLeftOver = d2 - h2, a2.length > 0 && f(e3).unusedInput.push(a2), e3._a[co] <= 12 && true === f(e3).bigHour && e3._a[co] > 0 && (f(e3).bigHour = void 0), f(e3).parsedDateParts = e3._a.slice(0), f(e3).meridiem = e3._meridiem, e3._a[co] = mt(e3._locale, e3._a[co], e3._meridiem), at(e3), ot(e3);
            }
            function mt(e3, t3, i3) {
              var n2;
              return null == i3 ? t3 : null != e3.meridiemHour ? e3.meridiemHour(t3, i3) : null != e3.isPM ? (n2 = e3.isPM(i3), n2 && t3 < 12 && (t3 += 12), n2 || 12 !== t3 || (t3 = 0), t3) : t3;
            }
            function bt(e3) {
              var t3, i3, n2, o2, s2;
              if (0 === e3._f.length)
                return f(e3).invalidFormat = true, void (e3._d = new Date(NaN));
              for (o2 = 0; o2 < e3._f.length; o2++)
                s2 = 0, t3 = g({}, e3), null != e3._useUTC && (t3._useUTC = e3._useUTC), t3._f = e3._f[o2], yt(t3), p(t3) && (s2 += f(t3).charsLeftOver, s2 += 10 * f(t3).unusedTokens.length, f(t3).score = s2, (null == n2 || s2 < n2) && (n2 = s2, i3 = t3));
              l(e3, i3 || t3);
            }
            function _t(e3) {
              if (!e3._d) {
                var t3 = R(e3._i);
                e3._a = d([t3.year, t3.month, t3.day || t3.date, t3.hour, t3.minute, t3.second, t3.millisecond], function(e4) {
                  return e4 && parseInt(e4, 10);
                }), at(e3);
              }
            }
            function wt(e3) {
              var t3 = new y(ot(kt(e3)));
              return t3._nextDay && (t3.add(1, "d"), t3._nextDay = void 0), t3;
            }
            function kt(e3) {
              var t3 = e3._i, n2 = e3._f;
              return e3._locale = e3._locale || it(e3._l), null === t3 || void 0 === n2 && "" === t3 ? v({ nullInput: true }) : ("string" == typeof t3 && (e3._i = t3 = e3._locale.preparse(t3)), m(t3) ? new y(ot(t3)) : (a(t3) ? e3._d = t3 : i2(n2) ? bt(e3) : n2 ? yt(e3) : xt(e3), p(e3) || (e3._d = null), e3));
            }
            function xt(e3) {
              var o2 = e3._i;
              s(o2) ? e3._d = new Date(t2.now()) : a(o2) ? e3._d = new Date(o2.valueOf()) : "string" == typeof o2 ? gt(e3) : i2(o2) ? (e3._a = d(o2.slice(0), function(e4) {
                return parseInt(e4, 10);
              }), at(e3)) : n(o2) ? _t(e3) : r(o2) ? e3._d = new Date(o2) : t2.createFromInputFallback(e3);
            }
            function Ot(e3, t3, s2, r2, a2) {
              var d2 = {};
              return true !== s2 && false !== s2 || (r2 = s2, s2 = void 0), (n(e3) && o(e3) || i2(e3) && 0 === e3.length) && (e3 = void 0), d2._isAMomentObject = true, d2._useUTC = d2._isUTC = a2, d2._l = s2, d2._i = e3, d2._f = t3, d2._strict = r2, wt(d2);
            }
            function Mt(e3, t3, i3, n2) {
              return Ot(e3, t3, i3, n2, false);
            }
            function Et(e3, t3) {
              var n2, o2;
              if (1 === t3.length && i2(t3[0]) && (t3 = t3[0]), !t3.length)
                return Mt();
              for (n2 = t3[0], o2 = 1; o2 < t3.length; ++o2)
                t3[o2].isValid() && !t3[o2][e3](n2) || (n2 = t3[o2]);
              return n2;
            }
            function St() {
              return Et("isBefore", [].slice.call(arguments, 0));
            }
            function Dt() {
              return Et("isAfter", [].slice.call(arguments, 0));
            }
            function Ct(e3) {
              for (var t3 in e3)
                if (-1 === mo.call(Ko, t3) || null != e3[t3] && isNaN(e3[t3]))
                  return false;
              for (var i3 = false, n2 = 0; n2 < Ko.length; ++n2)
                if (e3[Ko[n2]]) {
                  if (i3)
                    return false;
                  parseFloat(e3[Ko[n2]]) !== _(e3[Ko[n2]]) && (i3 = true);
                }
              return true;
            }
            function Tt() {
              return this._isValid;
            }
            function Pt() {
              return Zt(NaN);
            }
            function It(e3) {
              var t3 = R(e3), i3 = t3.year || 0, n2 = t3.quarter || 0, o2 = t3.month || 0, s2 = t3.week || 0, r2 = t3.day || 0, a2 = t3.hour || 0, d2 = t3.minute || 0, h2 = t3.second || 0, l2 = t3.millisecond || 0;
              this._isValid = Ct(t3), this._milliseconds = +l2 + 1e3 * h2 + 6e4 * d2 + 1e3 * a2 * 60 * 60, this._days = +r2 + 7 * s2, this._months = +o2 + 3 * n2 + 12 * i3, this._data = {}, this._locale = it(), this._bubble();
            }
            function Ft(e3) {
              return e3 instanceof It;
            }
            function Nt(e3) {
              return e3 < 0 ? -1 * Math.round(-1 * e3) : Math.round(e3);
            }
            function Bt(e3, t3) {
              H(e3, 0, 0, function() {
                var e4 = this.utcOffset(), i3 = "+";
                return e4 < 0 && (e4 = -e4, i3 = "-"), i3 + L(~~(e4 / 60), 2) + t3 + L(~~e4 % 60, 2);
              });
            }
            function zt(e3, t3) {
              var i3 = (t3 || "").match(e3);
              if (null === i3)
                return null;
              var n2 = i3[i3.length - 1] || [], o2 = (n2 + "").match(Zo) || ["-", 0, 0], s2 = 60 * o2[1] + _(o2[2]);
              return 0 === s2 ? 0 : "+" === o2[0] ? s2 : -s2;
            }
            function Rt(e3, i3) {
              var n2, o2;
              return i3._isUTC ? (n2 = i3.clone(), o2 = (m(e3) || a(e3) ? e3.valueOf() : Mt(e3).valueOf()) - n2.valueOf(), n2._d.setTime(n2._d.valueOf() + o2), t2.updateOffset(n2, false), n2) : Mt(e3).local();
            }
            function At(e3) {
              return 15 * -Math.round(e3._d.getTimezoneOffset() / 15);
            }
            function jt(e3, i3, n2) {
              var o2, s2 = this._offset || 0;
              if (!this.isValid())
                return null != e3 ? this : NaN;
              if (null != e3) {
                if ("string" == typeof e3) {
                  if (null === (e3 = zt(no, e3)))
                    return this;
                } else
                  Math.abs(e3) < 16 && !n2 && (e3 *= 60);
                return !this._isUTC && i3 && (o2 = At(this)), this._offset = e3, this._isUTC = true, null != o2 && this.add(o2, "m"), s2 !== e3 && (!i3 || this._changeInProgress ? ti(this, Zt(e3 - s2, "m"), 1, false) : this._changeInProgress || (this._changeInProgress = true, t2.updateOffset(this, true), this._changeInProgress = null)), this;
              }
              return this._isUTC ? s2 : At(this);
            }
            function Lt(e3, t3) {
              return null != e3 ? ("string" != typeof e3 && (e3 = -e3), this.utcOffset(e3, t3), this) : -this.utcOffset();
            }
            function Ht(e3) {
              return this.utcOffset(0, e3);
            }
            function Wt(e3) {
              return this._isUTC && (this.utcOffset(0, e3), this._isUTC = false, e3 && this.subtract(At(this), "m")), this;
            }
            function Yt() {
              if (null != this._tzm)
                this.utcOffset(this._tzm, false, true);
              else if ("string" == typeof this._i) {
                var e3 = zt(io, this._i);
                null != e3 ? this.utcOffset(e3) : this.utcOffset(0, true);
              }
              return this;
            }
            function Vt(e3) {
              return !!this.isValid() && (e3 = e3 ? Mt(e3).utcOffset() : 0, (this.utcOffset() - e3) % 60 == 0);
            }
            function Ut() {
              return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
            }
            function qt() {
              if (!s(this._isDSTShifted))
                return this._isDSTShifted;
              var e3 = {};
              if (g(e3, this), e3 = kt(e3), e3._a) {
                var t3 = e3._isUTC ? u(e3._a) : Mt(e3._a);
                this._isDSTShifted = this.isValid() && w(e3._a, t3.toArray()) > 0;
              } else
                this._isDSTShifted = false;
              return this._isDSTShifted;
            }
            function Gt() {
              return !!this.isValid() && !this._isUTC;
            }
            function Xt() {
              return !!this.isValid() && this._isUTC;
            }
            function Kt() {
              return !!this.isValid() && (this._isUTC && 0 === this._offset);
            }
            function Zt(e3, t3) {
              var i3, n2, o2, s2 = e3, a2 = null;
              return Ft(e3) ? s2 = { ms: e3._milliseconds, d: e3._days, M: e3._months } : r(e3) ? (s2 = {}, t3 ? s2[t3] = e3 : s2.milliseconds = e3) : (a2 = $o.exec(e3)) ? (i3 = "-" === a2[1] ? -1 : 1, s2 = { y: 0, d: _(a2[uo]) * i3, h: _(a2[co]) * i3, m: _(a2[fo]) * i3, s: _(a2[po]) * i3, ms: _(Nt(1e3 * a2[vo])) * i3 }) : (a2 = Qo.exec(e3)) ? (i3 = "-" === a2[1] ? -1 : (a2[1], 1), s2 = { y: $t(a2[2], i3), M: $t(a2[3], i3), w: $t(a2[4], i3), d: $t(a2[5], i3), h: $t(a2[6], i3), m: $t(a2[7], i3), s: $t(a2[8], i3) }) : null == s2 ? s2 = {} : "object" == typeof s2 && ("from" in s2 || "to" in s2) && (o2 = Jt(Mt(s2.from), Mt(s2.to)), s2 = {}, s2.ms = o2.milliseconds, s2.M = o2.months), n2 = new It(s2), Ft(e3) && h(e3, "_locale") && (n2._locale = e3._locale), n2;
            }
            function $t(e3, t3) {
              var i3 = e3 && parseFloat(e3.replace(",", "."));
              return (isNaN(i3) ? 0 : i3) * t3;
            }
            function Qt(e3, t3) {
              var i3 = { milliseconds: 0, months: 0 };
              return i3.months = t3.month() - e3.month() + 12 * (t3.year() - e3.year()), e3.clone().add(i3.months, "M").isAfter(t3) && --i3.months, i3.milliseconds = +t3 - +e3.clone().add(i3.months, "M"), i3;
            }
            function Jt(e3, t3) {
              var i3;
              return e3.isValid() && t3.isValid() ? (t3 = Rt(t3, e3), e3.isBefore(t3) ? i3 = Qt(e3, t3) : (i3 = Qt(t3, e3), i3.milliseconds = -i3.milliseconds, i3.months = -i3.months), i3) : { milliseconds: 0, months: 0 };
            }
            function ei(e3, t3) {
              return function(i3, n2) {
                var o2, s2;
                return null === n2 || isNaN(+n2) || (O(t3, "moment()." + t3 + "(period, number) is deprecated. Please use moment()." + t3 + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."), s2 = i3, i3 = n2, n2 = s2), i3 = "string" == typeof i3 ? +i3 : i3, o2 = Zt(i3, n2), ti(this, o2, e3), this;
              };
            }
            function ti(e3, i3, n2, o2) {
              var s2 = i3._milliseconds, r2 = Nt(i3._days), a2 = Nt(i3._months);
              e3.isValid() && (o2 = null == o2 || o2, a2 && fe(e3, ne(e3, "Month") + a2 * n2), r2 && oe(e3, "Date", ne(e3, "Date") + r2 * n2), s2 && e3._d.setTime(e3._d.valueOf() + s2 * n2), o2 && t2.updateOffset(e3, r2 || a2));
            }
            function ii(e3, t3) {
              var i3 = e3.diff(t3, "days", true);
              return i3 < -6 ? "sameElse" : i3 < -1 ? "lastWeek" : i3 < 0 ? "lastDay" : i3 < 1 ? "sameDay" : i3 < 2 ? "nextDay" : i3 < 7 ? "nextWeek" : "sameElse";
            }
            function ni(e3, i3) {
              var n2 = e3 || Mt(), o2 = Rt(n2, this).startOf("day"), s2 = t2.calendarFormat(this, o2) || "sameElse", r2 = i3 && (M(i3[s2]) ? i3[s2].call(this, n2) : i3[s2]);
              return this.format(r2 || this.localeData().calendar(s2, this, Mt(n2)));
            }
            function oi() {
              return new y(this);
            }
            function si(e3, t3) {
              var i3 = m(e3) ? e3 : Mt(e3);
              return !(!this.isValid() || !i3.isValid()) && (t3 = z(s(t3) ? "millisecond" : t3), "millisecond" === t3 ? this.valueOf() > i3.valueOf() : i3.valueOf() < this.clone().startOf(t3).valueOf());
            }
            function ri(e3, t3) {
              var i3 = m(e3) ? e3 : Mt(e3);
              return !(!this.isValid() || !i3.isValid()) && (t3 = z(s(t3) ? "millisecond" : t3), "millisecond" === t3 ? this.valueOf() < i3.valueOf() : this.clone().endOf(t3).valueOf() < i3.valueOf());
            }
            function ai(e3, t3, i3, n2) {
              return n2 = n2 || "()", ("(" === n2[0] ? this.isAfter(e3, i3) : !this.isBefore(e3, i3)) && (")" === n2[1] ? this.isBefore(t3, i3) : !this.isAfter(t3, i3));
            }
            function di(e3, t3) {
              var i3, n2 = m(e3) ? e3 : Mt(e3);
              return !(!this.isValid() || !n2.isValid()) && (t3 = z(t3 || "millisecond"), "millisecond" === t3 ? this.valueOf() === n2.valueOf() : (i3 = n2.valueOf(), this.clone().startOf(t3).valueOf() <= i3 && i3 <= this.clone().endOf(t3).valueOf()));
            }
            function hi(e3, t3) {
              return this.isSame(e3, t3) || this.isAfter(e3, t3);
            }
            function li(e3, t3) {
              return this.isSame(e3, t3) || this.isBefore(e3, t3);
            }
            function ui(e3, t3, i3) {
              var n2, o2, s2;
              if (!this.isValid())
                return NaN;
              if (n2 = Rt(e3, this), !n2.isValid())
                return NaN;
              switch (o2 = 6e4 * (n2.utcOffset() - this.utcOffset()), t3 = z(t3)) {
                case "year":
                  s2 = ci(this, n2) / 12;
                  break;
                case "month":
                  s2 = ci(this, n2);
                  break;
                case "quarter":
                  s2 = ci(this, n2) / 3;
                  break;
                case "second":
                  s2 = (this - n2) / 1e3;
                  break;
                case "minute":
                  s2 = (this - n2) / 6e4;
                  break;
                case "hour":
                  s2 = (this - n2) / 36e5;
                  break;
                case "day":
                  s2 = (this - n2 - o2) / 864e5;
                  break;
                case "week":
                  s2 = (this - n2 - o2) / 6048e5;
                  break;
                default:
                  s2 = this - n2;
              }
              return i3 ? s2 : b(s2);
            }
            function ci(e3, t3) {
              var i3, n2, o2 = 12 * (t3.year() - e3.year()) + (t3.month() - e3.month()), s2 = e3.clone().add(o2, "months");
              return t3 - s2 < 0 ? (i3 = e3.clone().add(o2 - 1, "months"), n2 = (t3 - s2) / (s2 - i3)) : (i3 = e3.clone().add(o2 + 1, "months"), n2 = (t3 - s2) / (i3 - s2)), -(o2 + n2) || 0;
            }
            function fi() {
              return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
            }
            function pi() {
              if (!this.isValid())
                return null;
              var e3 = this.clone().utc();
              return e3.year() < 0 || e3.year() > 9999 ? V(e3, "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]") : M(Date.prototype.toISOString) ? this.toDate().toISOString() : V(e3, "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]");
            }
            function vi() {
              if (!this.isValid())
                return "moment.invalid(/* " + this._i + " */)";
              var e3 = "moment", t3 = "";
              this.isLocal() || (e3 = 0 === this.utcOffset() ? "moment.utc" : "moment.parseZone", t3 = "Z");
              var i3 = "[" + e3 + '("]', n2 = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY", o2 = t3 + '[")]';
              return this.format(i3 + n2 + "-MM-DD[T]HH:mm:ss.SSS" + o2);
            }
            function gi(e3) {
              e3 || (e3 = this.isUtc() ? t2.defaultFormatUtc : t2.defaultFormat);
              var i3 = V(this, e3);
              return this.localeData().postformat(i3);
            }
            function yi(e3, t3) {
              return this.isValid() && (m(e3) && e3.isValid() || Mt(e3).isValid()) ? Zt({ to: this, from: e3 }).locale(this.locale()).humanize(!t3) : this.localeData().invalidDate();
            }
            function mi(e3) {
              return this.from(Mt(), e3);
            }
            function bi(e3, t3) {
              return this.isValid() && (m(e3) && e3.isValid() || Mt(e3).isValid()) ? Zt({ from: this, to: e3 }).locale(this.locale()).humanize(!t3) : this.localeData().invalidDate();
            }
            function _i(e3) {
              return this.to(Mt(), e3);
            }
            function wi(e3) {
              var t3;
              return void 0 === e3 ? this._locale._abbr : (t3 = it(e3), null != t3 && (this._locale = t3), this);
            }
            function ki() {
              return this._locale;
            }
            function xi(e3) {
              switch (e3 = z(e3)) {
                case "year":
                  this.month(0);
                case "quarter":
                case "month":
                  this.date(1);
                case "week":
                case "isoWeek":
                case "day":
                case "date":
                  this.hours(0);
                case "hour":
                  this.minutes(0);
                case "minute":
                  this.seconds(0);
                case "second":
                  this.milliseconds(0);
              }
              return "week" === e3 && this.weekday(0), "isoWeek" === e3 && this.isoWeekday(1), "quarter" === e3 && this.month(3 * Math.floor(this.month() / 3)), this;
            }
            function Oi(e3) {
              return void 0 === (e3 = z(e3)) || "millisecond" === e3 ? this : ("date" === e3 && (e3 = "day"), this.startOf(e3).add(1, "isoWeek" === e3 ? "week" : e3).subtract(1, "ms"));
            }
            function Mi() {
              return this._d.valueOf() - 6e4 * (this._offset || 0);
            }
            function Ei() {
              return Math.floor(this.valueOf() / 1e3);
            }
            function Si() {
              return new Date(this.valueOf());
            }
            function Di() {
              var e3 = this;
              return [e3.year(), e3.month(), e3.date(), e3.hour(), e3.minute(), e3.second(), e3.millisecond()];
            }
            function Ci() {
              var e3 = this;
              return { years: e3.year(), months: e3.month(), date: e3.date(), hours: e3.hours(), minutes: e3.minutes(), seconds: e3.seconds(), milliseconds: e3.milliseconds() };
            }
            function Ti() {
              return this.isValid() ? this.toISOString() : null;
            }
            function Pi() {
              return p(this);
            }
            function Ii() {
              return l({}, f(this));
            }
            function Fi() {
              return f(this).overflow;
            }
            function Ni() {
              return { input: this._i, format: this._f, locale: this._locale, isUTC: this._isUTC, strict: this._strict };
            }
            function Bi(e3, t3) {
              H(0, [e3, e3.length], 0, t3);
            }
            function zi(e3) {
              return Li.call(this, e3, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
            }
            function Ri(e3) {
              return Li.call(this, e3, this.isoWeek(), this.isoWeekday(), 1, 4);
            }
            function Ai() {
              return Oe(this.year(), 1, 4);
            }
            function ji() {
              var e3 = this.localeData()._week;
              return Oe(this.year(), e3.dow, e3.doy);
            }
            function Li(e3, t3, i3, n2, o2) {
              var s2;
              return null == e3 ? xe(this, n2, o2).year : (s2 = Oe(e3, n2, o2), t3 > s2 && (t3 = s2), Hi.call(this, e3, t3, i3, n2, o2));
            }
            function Hi(e3, t3, i3, n2, o2) {
              var s2 = ke(e3, t3, i3, n2, o2), r2 = _e(s2.year, 0, s2.dayOfYear);
              return this.year(r2.getUTCFullYear()), this.month(r2.getUTCMonth()), this.date(r2.getUTCDate()), this;
            }
            function Wi(e3) {
              return null == e3 ? Math.ceil((this.month() + 1) / 3) : this.month(3 * (e3 - 1) + this.month() % 3);
            }
            function Yi(e3) {
              var t3 = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
              return null == e3 ? t3 : this.add(e3 - t3, "d");
            }
            function Vi(e3, t3) {
              t3[vo] = _(1e3 * ("0." + e3));
            }
            function Ui() {
              return this._isUTC ? "UTC" : "";
            }
            function qi() {
              return this._isUTC ? "Coordinated Universal Time" : "";
            }
            function Gi(e3) {
              return Mt(1e3 * e3);
            }
            function Xi() {
              return Mt.apply(null, arguments).parseZone();
            }
            function Ki(e3) {
              return e3;
            }
            function Zi(e3, t3, i3, n2) {
              var o2 = it(), s2 = u().set(n2, t3);
              return o2[i3](s2, e3);
            }
            function $i(e3, t3, i3) {
              if (r(e3) && (t3 = e3, e3 = void 0), e3 = e3 || "", null != t3)
                return Zi(e3, t3, i3, "month");
              var n2, o2 = [];
              for (n2 = 0; n2 < 12; n2++)
                o2[n2] = Zi(e3, n2, i3, "month");
              return o2;
            }
            function Qi(e3, t3, i3, n2) {
              "boolean" == typeof e3 ? (r(t3) && (i3 = t3, t3 = void 0), t3 = t3 || "") : (t3 = e3, i3 = t3, e3 = false, r(t3) && (i3 = t3, t3 = void 0), t3 = t3 || "");
              var o2 = it(), s2 = e3 ? o2._week.dow : 0;
              if (null != i3)
                return Zi(t3, (i3 + s2) % 7, n2, "day");
              var a2, d2 = [];
              for (a2 = 0; a2 < 7; a2++)
                d2[a2] = Zi(t3, (a2 + s2) % 7, n2, "day");
              return d2;
            }
            function Ji(e3, t3) {
              return $i(e3, t3, "months");
            }
            function en(e3, t3) {
              return $i(e3, t3, "monthsShort");
            }
            function tn(e3, t3, i3) {
              return Qi(e3, t3, i3, "weekdays");
            }
            function nn(e3, t3, i3) {
              return Qi(e3, t3, i3, "weekdaysShort");
            }
            function on(e3, t3, i3) {
              return Qi(e3, t3, i3, "weekdaysMin");
            }
            function sn() {
              var e3 = this._data;
              return this._milliseconds = hs(this._milliseconds), this._days = hs(this._days), this._months = hs(this._months), e3.milliseconds = hs(e3.milliseconds), e3.seconds = hs(e3.seconds), e3.minutes = hs(e3.minutes), e3.hours = hs(e3.hours), e3.months = hs(e3.months), e3.years = hs(e3.years), this;
            }
            function rn(e3, t3, i3, n2) {
              var o2 = Zt(t3, i3);
              return e3._milliseconds += n2 * o2._milliseconds, e3._days += n2 * o2._days, e3._months += n2 * o2._months, e3._bubble();
            }
            function an(e3, t3) {
              return rn(this, e3, t3, 1);
            }
            function dn(e3, t3) {
              return rn(this, e3, t3, -1);
            }
            function hn(e3) {
              return e3 < 0 ? Math.floor(e3) : Math.ceil(e3);
            }
            function ln() {
              var e3, t3, i3, n2, o2, s2 = this._milliseconds, r2 = this._days, a2 = this._months, d2 = this._data;
              return s2 >= 0 && r2 >= 0 && a2 >= 0 || s2 <= 0 && r2 <= 0 && a2 <= 0 || (s2 += 864e5 * hn(cn(a2) + r2), r2 = 0, a2 = 0), d2.milliseconds = s2 % 1e3, e3 = b(s2 / 1e3), d2.seconds = e3 % 60, t3 = b(e3 / 60), d2.minutes = t3 % 60, i3 = b(t3 / 60), d2.hours = i3 % 24, r2 += b(i3 / 24), o2 = b(un(r2)), a2 += o2, r2 -= hn(cn(o2)), n2 = b(a2 / 12), a2 %= 12, d2.days = r2, d2.months = a2, d2.years = n2, this;
            }
            function un(e3) {
              return 4800 * e3 / 146097;
            }
            function cn(e3) {
              return 146097 * e3 / 4800;
            }
            function fn(e3) {
              if (!this.isValid())
                return NaN;
              var t3, i3, n2 = this._milliseconds;
              if ("month" === (e3 = z(e3)) || "year" === e3)
                return t3 = this._days + n2 / 864e5, i3 = this._months + un(t3), "month" === e3 ? i3 : i3 / 12;
              switch (t3 = this._days + Math.round(cn(this._months)), e3) {
                case "week":
                  return t3 / 7 + n2 / 6048e5;
                case "day":
                  return t3 + n2 / 864e5;
                case "hour":
                  return 24 * t3 + n2 / 36e5;
                case "minute":
                  return 1440 * t3 + n2 / 6e4;
                case "second":
                  return 86400 * t3 + n2 / 1e3;
                case "millisecond":
                  return Math.floor(864e5 * t3) + n2;
                default:
                  throw new Error("Unknown unit " + e3);
              }
            }
            function pn() {
              return this.isValid() ? this._milliseconds + 864e5 * this._days + this._months % 12 * 2592e6 + 31536e6 * _(this._months / 12) : NaN;
            }
            function vn(e3) {
              return function() {
                return this.as(e3);
              };
            }
            function gn() {
              return Zt(this);
            }
            function yn(e3) {
              return e3 = z(e3), this.isValid() ? this[e3 + "s"]() : NaN;
            }
            function mn(e3) {
              return function() {
                return this.isValid() ? this._data[e3] : NaN;
              };
            }
            function bn() {
              return b(this.days() / 7);
            }
            function _n(e3, t3, i3, n2, o2) {
              return o2.relativeTime(t3 || 1, !!i3, e3, n2);
            }
            function wn(e3, t3, i3) {
              var n2 = Zt(e3).abs(), o2 = Ms(n2.as("s")), s2 = Ms(n2.as("m")), r2 = Ms(n2.as("h")), a2 = Ms(n2.as("d")), d2 = Ms(n2.as("M")), h2 = Ms(n2.as("y")), l2 = o2 <= Es.ss && ["s", o2] || o2 < Es.s && ["ss", o2] || s2 <= 1 && ["m"] || s2 < Es.m && ["mm", s2] || r2 <= 1 && ["h"] || r2 < Es.h && ["hh", r2] || a2 <= 1 && ["d"] || a2 < Es.d && ["dd", a2] || d2 <= 1 && ["M"] || d2 < Es.M && ["MM", d2] || h2 <= 1 && ["y"] || ["yy", h2];
              return l2[2] = t3, l2[3] = +e3 > 0, l2[4] = i3, _n.apply(null, l2);
            }
            function kn(e3) {
              return void 0 === e3 ? Ms : "function" == typeof e3 && (Ms = e3, true);
            }
            function xn(e3, t3) {
              return void 0 !== Es[e3] && (void 0 === t3 ? Es[e3] : (Es[e3] = t3, "s" === e3 && (Es.ss = t3 - 1), true));
            }
            function On(e3) {
              if (!this.isValid())
                return this.localeData().invalidDate();
              var t3 = this.localeData(), i3 = wn(this, !e3, t3);
              return e3 && (i3 = t3.pastFuture(+this, i3)), t3.postformat(i3);
            }
            function Mn(e3) {
              return (e3 > 0) - (e3 < 0) || +e3;
            }
            function En() {
              if (!this.isValid())
                return this.localeData().invalidDate();
              var e3, t3, i3, n2 = Ss(this._milliseconds) / 1e3, o2 = Ss(this._days), s2 = Ss(this._months);
              e3 = b(n2 / 60), t3 = b(e3 / 60), n2 %= 60, e3 %= 60, i3 = b(s2 / 12), s2 %= 12;
              var r2 = i3, a2 = s2, d2 = o2, h2 = t3, l2 = e3, u2 = n2 ? n2.toFixed(3).replace(/\.?0+$/, "") : "", c2 = this.asSeconds();
              if (!c2)
                return "P0D";
              var f2 = c2 < 0 ? "-" : "", p2 = Mn(this._months) !== Mn(c2) ? "-" : "", v2 = Mn(this._days) !== Mn(c2) ? "-" : "", g2 = Mn(this._milliseconds) !== Mn(c2) ? "-" : "";
              return f2 + "P" + (r2 ? p2 + r2 + "Y" : "") + (a2 ? p2 + a2 + "M" : "") + (d2 ? v2 + d2 + "D" : "") + (h2 || l2 || u2 ? "T" : "") + (h2 ? g2 + h2 + "H" : "") + (l2 ? g2 + l2 + "M" : "") + (u2 ? g2 + u2 + "S" : "");
            }
            var Sn, Dn;
            Dn = Array.prototype.some ? Array.prototype.some : function(e3) {
              for (var t3 = Object(this), i3 = t3.length >>> 0, n2 = 0; n2 < i3; n2++)
                if (n2 in t3 && e3.call(this, t3[n2], n2, t3))
                  return true;
              return false;
            };
            var Cn = t2.momentProperties = [], Tn = false, Pn = {};
            t2.suppressDeprecationWarnings = false, t2.deprecationHandler = null;
            var In;
            In = Object.keys ? Object.keys : function(e3) {
              var t3, i3 = [];
              for (t3 in e3)
                h(e3, t3) && i3.push(t3);
              return i3;
            };
            var Fn = { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" }, Nn = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, Bn = /\d{1,2}/, zn = { future: "in %s", past: "%s ago", s: "a few seconds", ss: "%d seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" }, Rn = {}, An = {}, jn = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, Ln = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, Hn = {}, Wn = {}, Yn = /\d/, Vn = /\d\d/, Un = /\d{3}/, qn = /\d{4}/, Gn = /[+-]?\d{6}/, Xn = /\d\d?/, Kn = /\d\d\d\d?/, Zn = /\d\d\d\d\d\d?/, $n = /\d{1,3}/, Qn = /\d{1,4}/, Jn = /[+-]?\d{1,6}/, eo = /\d+/, to = /[+-]?\d+/, io = /Z|[+-]\d\d:?\d\d/gi, no = /Z|[+-]\d\d(?::?\d\d)?/gi, oo = /[+-]?\d+(\.\d{1,3})?/, so = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, ro = {}, ao = {}, ho = 0, lo = 1, uo = 2, co = 3, fo = 4, po = 5, vo = 6, go = 7, yo = 8;
            H("Y", 0, 0, function() {
              var e3 = this.year();
              return e3 <= 9999 ? "" + e3 : "+" + e3;
            }), H(0, ["YY", 2], 0, function() {
              return this.year() % 100;
            }), H(0, ["YYYY", 4], 0, "year"), H(0, ["YYYYY", 5], 0, "year"), H(0, ["YYYYYY", 6, true], 0, "year"), B("year", "y"), A("year", 1), q("Y", to), q("YY", Xn, Vn), q("YYYY", Qn, qn), q("YYYYY", Jn, Gn), q("YYYYYY", Jn, Gn), Z(["YYYYY", "YYYYYY"], ho), Z("YYYY", function(e3, i3) {
              i3[ho] = 2 === e3.length ? t2.parseTwoDigitYear(e3) : _(e3);
            }), Z("YY", function(e3, i3) {
              i3[ho] = t2.parseTwoDigitYear(e3);
            }), Z("Y", function(e3, t3) {
              t3[ho] = parseInt(e3, 10);
            }), t2.parseTwoDigitYear = function(e3) {
              return _(e3) + (_(e3) > 68 ? 1900 : 2e3);
            };
            var mo, bo = ie("FullYear", true);
            mo = Array.prototype.indexOf ? Array.prototype.indexOf : function(e3) {
              var t3;
              for (t3 = 0; t3 < this.length; ++t3)
                if (this[t3] === e3)
                  return t3;
              return -1;
            }, H("M", ["MM", 2], "Mo", function() {
              return this.month() + 1;
            }), H("MMM", 0, 0, function(e3) {
              return this.localeData().monthsShort(this, e3);
            }), H("MMMM", 0, 0, function(e3) {
              return this.localeData().months(this, e3);
            }), B("month", "M"), A("month", 8), q("M", Xn), q("MM", Xn, Vn), q("MMM", function(e3, t3) {
              return t3.monthsShortRegex(e3);
            }), q("MMMM", function(e3, t3) {
              return t3.monthsRegex(e3);
            }), Z(["M", "MM"], function(e3, t3) {
              t3[lo] = _(e3) - 1;
            }), Z(["MMM", "MMMM"], function(e3, t3, i3, n2) {
              var o2 = i3._locale.monthsParse(e3, n2, i3._strict);
              null != o2 ? t3[lo] = o2 : f(i3).invalidMonth = e3;
            });
            var _o = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, wo = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ko = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), xo = so, Oo = so;
            H("w", ["ww", 2], "wo", "week"), H("W", ["WW", 2], "Wo", "isoWeek"), B("week", "w"), B("isoWeek", "W"), A("week", 5), A("isoWeek", 5), q("w", Xn), q("ww", Xn, Vn), q("W", Xn), q("WW", Xn, Vn), $(["w", "ww", "W", "WW"], function(e3, t3, i3, n2) {
              t3[n2.substr(0, 1)] = _(e3);
            });
            var Mo = { dow: 0, doy: 6 };
            H("d", 0, "do", "day"), H("dd", 0, 0, function(e3) {
              return this.localeData().weekdaysMin(this, e3);
            }), H("ddd", 0, 0, function(e3) {
              return this.localeData().weekdaysShort(this, e3);
            }), H("dddd", 0, 0, function(e3) {
              return this.localeData().weekdays(this, e3);
            }), H("e", 0, 0, "weekday"), H("E", 0, 0, "isoWeekday"), B("day", "d"), B("weekday", "e"), B("isoWeekday", "E"), A("day", 11), A("weekday", 11), A("isoWeekday", 11), q("d", Xn), q("e", Xn), q("E", Xn), q("dd", function(e3, t3) {
              return t3.weekdaysMinRegex(e3);
            }), q("ddd", function(e3, t3) {
              return t3.weekdaysShortRegex(e3);
            }), q("dddd", function(e3, t3) {
              return t3.weekdaysRegex(e3);
            }), $(["dd", "ddd", "dddd"], function(e3, t3, i3, n2) {
              var o2 = i3._locale.weekdaysParse(e3, n2, i3._strict);
              null != o2 ? t3.d = o2 : f(i3).invalidWeekday = e3;
            }), $(["d", "e", "E"], function(e3, t3, i3, n2) {
              t3[n2] = _(e3);
            });
            var Eo = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), So = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), Do = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), Co = so, To = so, Po = so;
            H("H", ["HH", 2], 0, "hour"), H("h", ["hh", 2], 0, Ve), H("k", ["kk", 2], 0, Ue), H("hmm", 0, 0, function() {
              return "" + Ve.apply(this) + L(this.minutes(), 2);
            }), H("hmmss", 0, 0, function() {
              return "" + Ve.apply(this) + L(this.minutes(), 2) + L(this.seconds(), 2);
            }), H("Hmm", 0, 0, function() {
              return "" + this.hours() + L(this.minutes(), 2);
            }), H("Hmmss", 0, 0, function() {
              return "" + this.hours() + L(this.minutes(), 2) + L(this.seconds(), 2);
            }), qe("a", true), qe("A", false), B("hour", "h"), A("hour", 13), q("a", Ge), q("A", Ge), q("H", Xn), q("h", Xn), q("k", Xn), q("HH", Xn, Vn), q("hh", Xn, Vn), q("kk", Xn, Vn), q("hmm", Kn), q("hmmss", Zn), q("Hmm", Kn), q("Hmmss", Zn), Z(["H", "HH"], co), Z(["k", "kk"], function(e3, t3, i3) {
              var n2 = _(e3);
              t3[co] = 24 === n2 ? 0 : n2;
            }), Z(["a", "A"], function(e3, t3, i3) {
              i3._isPm = i3._locale.isPM(e3), i3._meridiem = e3;
            }), Z(["h", "hh"], function(e3, t3, i3) {
              t3[co] = _(e3), f(i3).bigHour = true;
            }), Z("hmm", function(e3, t3, i3) {
              var n2 = e3.length - 2;
              t3[co] = _(e3.substr(0, n2)), t3[fo] = _(e3.substr(n2)), f(i3).bigHour = true;
            }), Z("hmmss", function(e3, t3, i3) {
              var n2 = e3.length - 4, o2 = e3.length - 2;
              t3[co] = _(e3.substr(0, n2)), t3[fo] = _(e3.substr(n2, 2)), t3[po] = _(e3.substr(o2)), f(i3).bigHour = true;
            }), Z("Hmm", function(e3, t3, i3) {
              var n2 = e3.length - 2;
              t3[co] = _(e3.substr(0, n2)), t3[fo] = _(e3.substr(n2));
            }), Z("Hmmss", function(e3, t3, i3) {
              var n2 = e3.length - 4, o2 = e3.length - 2;
              t3[co] = _(e3.substr(0, n2)), t3[fo] = _(e3.substr(n2, 2)), t3[po] = _(e3.substr(o2));
            });
            var Io, Fo = /[ap]\.?m?\.?/i, No = ie("Hours", true), Bo = { calendar: Fn, longDateFormat: Nn, invalidDate: "Invalid date", ordinal: "%d", dayOfMonthOrdinalParse: Bn, relativeTime: zn, months: wo, monthsShort: ko, week: Mo, weekdays: Eo, weekdaysMin: Do, weekdaysShort: So, meridiemParse: Fo }, zo = {}, Ro = {}, Ao = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/, jo = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/, Lo = /Z|[+-]\d\d(?::?\d\d)?/, Ho = [["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/], ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/], ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/], ["GGGG-[W]WW", /\d{4}-W\d\d/, false], ["YYYY-DDD", /\d{4}-\d{3}/], ["YYYY-MM", /\d{4}-\d\d/, false], ["YYYYYYMMDD", /[+-]\d{10}/], ["YYYYMMDD", /\d{8}/], ["GGGG[W]WWE", /\d{4}W\d{3}/], ["GGGG[W]WW", /\d{4}W\d{2}/, false], ["YYYYDDD", /\d{7}/]], Wo = [["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/], ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/], ["HH:mm:ss", /\d\d:\d\d:\d\d/], ["HH:mm", /\d\d:\d\d/], ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/], ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/], ["HHmmss", /\d\d\d\d\d\d/], ["HHmm", /\d\d\d\d/], ["HH", /\d\d/]], Yo = /^\/?Date\((\-?\d+)/i, Vo = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, Uo = { UT: 0, GMT: 0, EDT: -240, EST: -300, CDT: -300, CST: -360, MDT: -360, MST: -420, PDT: -420, PST: -480 };
            t2.createFromInputFallback = x("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged and will be removed in an upcoming major release. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function(e3) {
              e3._d = new Date(e3._i + (e3._useUTC ? " UTC" : ""));
            }), t2.ISO_8601 = function() {
            }, t2.RFC_2822 = function() {
            };
            var qo = x("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
              var e3 = Mt.apply(null, arguments);
              return this.isValid() && e3.isValid() ? e3 < this ? this : e3 : v();
            }), Go = x("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
              var e3 = Mt.apply(null, arguments);
              return this.isValid() && e3.isValid() ? e3 > this ? this : e3 : v();
            }), Xo = function() {
              return Date.now ? Date.now() : +new Date();
            }, Ko = ["year", "quarter", "month", "week", "day", "hour", "minute", "second", "millisecond"];
            Bt("Z", ":"), Bt("ZZ", ""), q("Z", no), q("ZZ", no), Z(["Z", "ZZ"], function(e3, t3, i3) {
              i3._useUTC = true, i3._tzm = zt(no, e3);
            });
            var Zo = /([\+\-]|\d\d)/gi;
            t2.updateOffset = function() {
            };
            var $o = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/, Qo = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
            Zt.fn = It.prototype, Zt.invalid = Pt;
            var Jo = ei(1, "add"), es = ei(-1, "subtract");
            t2.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ", t2.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
            var ts = x("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(e3) {
              return void 0 === e3 ? this.localeData() : this.locale(e3);
            });
            H(0, ["gg", 2], 0, function() {
              return this.weekYear() % 100;
            }), H(0, ["GG", 2], 0, function() {
              return this.isoWeekYear() % 100;
            }), Bi("gggg", "weekYear"), Bi("ggggg", "weekYear"), Bi("GGGG", "isoWeekYear"), Bi("GGGGG", "isoWeekYear"), B("weekYear", "gg"), B("isoWeekYear", "GG"), A("weekYear", 1), A("isoWeekYear", 1), q("G", to), q("g", to), q("GG", Xn, Vn), q("gg", Xn, Vn), q("GGGG", Qn, qn), q("gggg", Qn, qn), q("GGGGG", Jn, Gn), q("ggggg", Jn, Gn), $(["gggg", "ggggg", "GGGG", "GGGGG"], function(e3, t3, i3, n2) {
              t3[n2.substr(0, 2)] = _(e3);
            }), $(["gg", "GG"], function(e3, i3, n2, o2) {
              i3[o2] = t2.parseTwoDigitYear(e3);
            }), H("Q", 0, "Qo", "quarter"), B("quarter", "Q"), A("quarter", 7), q("Q", Yn), Z("Q", function(e3, t3) {
              t3[lo] = 3 * (_(e3) - 1);
            }), H("D", ["DD", 2], "Do", "date"), B("date", "D"), A("date", 9), q("D", Xn), q("DD", Xn, Vn), q("Do", function(e3, t3) {
              return e3 ? t3._dayOfMonthOrdinalParse || t3._ordinalParse : t3._dayOfMonthOrdinalParseLenient;
            }), Z(["D", "DD"], uo), Z("Do", function(e3, t3) {
              t3[uo] = _(e3.match(Xn)[0], 10);
            });
            var is = ie("Date", true);
            H("DDD", ["DDDD", 3], "DDDo", "dayOfYear"), B("dayOfYear", "DDD"), A("dayOfYear", 4), q("DDD", $n), q("DDDD", Un), Z(["DDD", "DDDD"], function(e3, t3, i3) {
              i3._dayOfYear = _(e3);
            }), H("m", ["mm", 2], 0, "minute"), B("minute", "m"), A("minute", 14), q("m", Xn), q("mm", Xn, Vn), Z(["m", "mm"], fo);
            var ns = ie("Minutes", false);
            H("s", ["ss", 2], 0, "second"), B("second", "s"), A("second", 15), q("s", Xn), q("ss", Xn, Vn), Z(["s", "ss"], po);
            var os = ie("Seconds", false);
            H("S", 0, 0, function() {
              return ~~(this.millisecond() / 100);
            }), H(0, ["SS", 2], 0, function() {
              return ~~(this.millisecond() / 10);
            }), H(0, ["SSS", 3], 0, "millisecond"), H(0, ["SSSS", 4], 0, function() {
              return 10 * this.millisecond();
            }), H(0, ["SSSSS", 5], 0, function() {
              return 100 * this.millisecond();
            }), H(0, ["SSSSSS", 6], 0, function() {
              return 1e3 * this.millisecond();
            }), H(0, ["SSSSSSS", 7], 0, function() {
              return 1e4 * this.millisecond();
            }), H(0, ["SSSSSSSS", 8], 0, function() {
              return 1e5 * this.millisecond();
            }), H(0, ["SSSSSSSSS", 9], 0, function() {
              return 1e6 * this.millisecond();
            }), B("millisecond", "ms"), A("millisecond", 16), q("S", $n, Yn), q("SS", $n, Vn), q("SSS", $n, Un);
            var ss;
            for (ss = "SSSS"; ss.length <= 9; ss += "S")
              q(ss, eo);
            for (ss = "S"; ss.length <= 9; ss += "S")
              Z(ss, Vi);
            var rs = ie("Milliseconds", false);
            H("z", 0, 0, "zoneAbbr"), H("zz", 0, 0, "zoneName");
            var as = y.prototype;
            as.add = Jo, as.calendar = ni, as.clone = oi, as.diff = ui, as.endOf = Oi, as.format = gi, as.from = yi, as.fromNow = mi, as.to = bi, as.toNow = _i, as.get = se, as.invalidAt = Fi, as.isAfter = si, as.isBefore = ri, as.isBetween = ai, as.isSame = di, as.isSameOrAfter = hi, as.isSameOrBefore = li, as.isValid = Pi, as.lang = ts, as.locale = wi, as.localeData = ki, as.max = Go, as.min = qo, as.parsingFlags = Ii, as.set = re, as.startOf = xi, as.subtract = es, as.toArray = Di, as.toObject = Ci, as.toDate = Si, as.toISOString = pi, as.inspect = vi, as.toJSON = Ti, as.toString = fi, as.unix = Ei, as.valueOf = Mi, as.creationData = Ni, as.year = bo, as.isLeapYear = te, as.weekYear = zi, as.isoWeekYear = Ri, as.quarter = as.quarters = Wi, as.month = pe, as.daysInMonth = ve, as.week = as.weeks = De, as.isoWeek = as.isoWeeks = Ce, as.weeksInYear = ji, as.isoWeeksInYear = Ai, as.date = is, as.day = as.days = Re, as.weekday = Ae, as.isoWeekday = je, as.dayOfYear = Yi, as.hour = as.hours = No, as.minute = as.minutes = ns, as.second = as.seconds = os, as.millisecond = as.milliseconds = rs, as.utcOffset = jt, as.utc = Ht, as.local = Wt, as.parseZone = Yt, as.hasAlignedHourOffset = Vt, as.isDST = Ut, as.isLocal = Gt, as.isUtcOffset = Xt, as.isUtc = Kt, as.isUTC = Kt, as.zoneAbbr = Ui, as.zoneName = qi, as.dates = x("dates accessor is deprecated. Use date instead.", is), as.months = x("months accessor is deprecated. Use month instead", pe), as.years = x("years accessor is deprecated. Use year instead", bo), as.zone = x("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", Lt), as.isDSTShifted = x("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", qt);
            var ds = D.prototype;
            ds.calendar = C, ds.longDateFormat = T, ds.invalidDate = P, ds.ordinal = I, ds.preparse = Ki, ds.postformat = Ki, ds.relativeTime = F, ds.pastFuture = N, ds.set = E, ds.months = he, ds.monthsShort = le, ds.monthsParse = ce, ds.monthsRegex = ye, ds.monthsShortRegex = ge, ds.week = Me, ds.firstDayOfYear = Se, ds.firstDayOfWeek = Ee, ds.weekdays = Ie, ds.weekdaysMin = Ne, ds.weekdaysShort = Fe, ds.weekdaysParse = ze, ds.weekdaysRegex = Le, ds.weekdaysShortRegex = He, ds.weekdaysMinRegex = We, ds.isPM = Xe, ds.meridiem = Ke, Je("en", { dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/, ordinal: function(e3) {
              var t3 = e3 % 10;
              return e3 + (1 === _(e3 % 100 / 10) ? "th" : 1 === t3 ? "st" : 2 === t3 ? "nd" : 3 === t3 ? "rd" : "th");
            } }), t2.lang = x("moment.lang is deprecated. Use moment.locale instead.", Je), t2.langData = x("moment.langData is deprecated. Use moment.localeData instead.", it);
            var hs = Math.abs, ls = vn("ms"), us = vn("s"), cs = vn("m"), fs = vn("h"), ps = vn("d"), vs = vn("w"), gs = vn("M"), ys = vn("y"), ms = mn("milliseconds"), bs = mn("seconds"), _s = mn("minutes"), ws = mn("hours"), ks = mn("days"), xs = mn("months"), Os = mn("years"), Ms = Math.round, Es = { ss: 44, s: 45, m: 45, h: 22, d: 26, M: 11 }, Ss = Math.abs, Ds = It.prototype;
            return Ds.isValid = Tt, Ds.abs = sn, Ds.add = an, Ds.subtract = dn, Ds.as = fn, Ds.asMilliseconds = ls, Ds.asSeconds = us, Ds.asMinutes = cs, Ds.asHours = fs, Ds.asDays = ps, Ds.asWeeks = vs, Ds.asMonths = gs, Ds.asYears = ys, Ds.valueOf = pn, Ds._bubble = ln, Ds.clone = gn, Ds.get = yn, Ds.milliseconds = ms, Ds.seconds = bs, Ds.minutes = _s, Ds.hours = ws, Ds.days = ks, Ds.weeks = bn, Ds.months = xs, Ds.years = Os, Ds.humanize = On, Ds.toISOString = En, Ds.toString = En, Ds.toJSON = En, Ds.locale = wi, Ds.localeData = ki, Ds.toIsoString = x("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", En), Ds.lang = ts, H("X", 0, 0, "unix"), H("x", 0, 0, "valueOf"), q("x", to), q("X", oo), Z("X", function(e3, t3, i3) {
              i3._d = new Date(1e3 * parseFloat(e3, 10));
            }), Z("x", function(e3, t3, i3) {
              i3._d = new Date(_(e3));
            }), t2.version = "2.19.1", function(e3) {
              Sn = e3;
            }(Mt), t2.fn = as, t2.min = St, t2.max = Dt, t2.now = Xo, t2.utc = u, t2.unix = Gi, t2.months = Ji, t2.isDate = a, t2.locale = Je, t2.invalid = v, t2.duration = Zt, t2.isMoment = m, t2.weekdays = tn, t2.parseZone = Xi, t2.localeData = it, t2.isDuration = Ft, t2.monthsShort = en, t2.weekdaysMin = on, t2.defineLocale = et, t2.updateLocale = tt, t2.locales = nt, t2.weekdaysShort = nn, t2.normalizeUnits = z, t2.relativeTimeRounding = kn, t2.relativeTimeThreshold = xn, t2.calendarFormat = ii, t2.prototype = as, t2;
          });
        }).call(t, i(115)(e));
      }, function(e, t) {
        e.exports = function(e2) {
          return e2.webpackPolyfill || (e2.deprecate = function() {
          }, e2.paths = [], e2.children || (e2.children = []), Object.defineProperty(e2, "loaded", { enumerable: true, get: function() {
            return e2.l;
          } }), Object.defineProperty(e2, "id", { enumerable: true, get: function() {
            return e2.i;
          } }), e2.webpackPolyfill = 1), e2;
        };
      }, function(e, t) {
        function i(e2) {
          throw new Error("Cannot find module '" + e2 + "'.");
        }
        i.keys = function() {
          return [];
        }, i.resolve = i, e.exports = i, i.id = 116;
      }, function(e, t, i) {
        (function(t2) {
          function i2(e2, t3, i3) {
            var n2 = t3 && i3 || 0, o2 = 0;
            for (t3 = t3 || [], e2.toLowerCase().replace(/[0-9a-f]{2}/g, function(e3) {
              o2 < 16 && (t3[n2 + o2++] = u[e3]);
            }); o2 < 16; )
              t3[n2 + o2++] = 0;
            return t3;
          }
          function n(e2, t3) {
            var i3 = t3 || 0, n2 = l;
            return n2[e2[i3++]] + n2[e2[i3++]] + n2[e2[i3++]] + n2[e2[i3++]] + "-" + n2[e2[i3++]] + n2[e2[i3++]] + "-" + n2[e2[i3++]] + n2[e2[i3++]] + "-" + n2[e2[i3++]] + n2[e2[i3++]] + "-" + n2[e2[i3++]] + n2[e2[i3++]] + n2[e2[i3++]] + n2[e2[i3++]] + n2[e2[i3++]] + n2[e2[i3++]];
          }
          function o(e2, t3, i3) {
            var o2 = t3 && i3 || 0, s2 = t3 || [];
            e2 = e2 || {};
            var r2 = void 0 !== e2.clockseq ? e2.clockseq : v, a2 = void 0 !== e2.msecs ? e2.msecs : new Date().getTime(), d2 = void 0 !== e2.nsecs ? e2.nsecs : y + 1, h2 = a2 - g + (d2 - y) / 1e4;
            if (h2 < 0 && void 0 === e2.clockseq && (r2 = r2 + 1 & 16383), (h2 < 0 || a2 > g) && void 0 === e2.nsecs && (d2 = 0), d2 >= 1e4)
              throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
            g = a2, y = d2, v = r2, a2 += 122192928e5;
            var l2 = (1e4 * (268435455 & a2) + d2) % 4294967296;
            s2[o2++] = l2 >>> 24 & 255, s2[o2++] = l2 >>> 16 & 255, s2[o2++] = l2 >>> 8 & 255, s2[o2++] = 255 & l2;
            var u2 = a2 / 4294967296 * 1e4 & 268435455;
            s2[o2++] = u2 >>> 8 & 255, s2[o2++] = 255 & u2, s2[o2++] = u2 >>> 24 & 15 | 16, s2[o2++] = u2 >>> 16 & 255, s2[o2++] = r2 >>> 8 | 128, s2[o2++] = 255 & r2;
            for (var c2 = e2.node || p, f2 = 0; f2 < 6; f2++)
              s2[o2 + f2] = c2[f2];
            return t3 || n(s2);
          }
          function s(e2, t3, i3) {
            var o2 = t3 && i3 || 0;
            "string" == typeof e2 && (t3 = "binary" == e2 ? new Array(16) : null, e2 = null), e2 = e2 || {};
            var s2 = e2.random || (e2.rng || r)();
            if (s2[6] = 15 & s2[6] | 64, s2[8] = 63 & s2[8] | 128, t3)
              for (var a2 = 0; a2 < 16; a2++)
                t3[o2 + a2] = s2[a2];
            return t3 || n(s2);
          }
          var r, a = "undefined" != typeof window ? window : void 0 !== t2 ? t2 : null;
          if (a && a.crypto && crypto.getRandomValues) {
            var d = new Uint8Array(16);
            r = function() {
              return crypto.getRandomValues(d), d;
            };
          }
          if (!r) {
            var h = new Array(16);
            r = function() {
              for (var e2, t3 = 0; t3 < 16; t3++)
                0 == (3 & t3) && (e2 = 4294967296 * Math.random()), h[t3] = e2 >>> ((3 & t3) << 3) & 255;
              return h;
            };
          }
          for (var l = [], u = {}, c = 0; c < 256; c++)
            l[c] = (c + 256).toString(16).substr(1), u[l[c]] = c;
          var f = r(), p = [1 | f[0], f[1], f[2], f[3], f[4], f[5]], v = 16383 & (f[6] << 8 | f[7]), g = 0, y = 0, m = s;
          m.v1 = o, m.v4 = s, m.parse = i2, m.unparse = n, e.exports = m;
        }).call(t, i(118));
      }, function(e, t) {
        var i;
        i = function() {
          return this;
        }();
        try {
          i = i || Function("return this")() || (0, eval)("this");
        } catch (e2) {
          "object" == typeof window && (i = window);
        }
        e.exports = i;
      }, function(e, t, i) {
        t.prepareElements = function(e2) {
          for (var t2 in e2)
            e2.hasOwnProperty(t2) && (e2[t2].redundant = e2[t2].used, e2[t2].used = []);
        }, t.cleanupElements = function(e2) {
          for (var t2 in e2)
            if (e2.hasOwnProperty(t2) && e2[t2].redundant) {
              for (var i2 = 0; i2 < e2[t2].redundant.length; i2++)
                e2[t2].redundant[i2].parentNode.removeChild(e2[t2].redundant[i2]);
              e2[t2].redundant = [];
            }
        }, t.resetElements = function(e2) {
          t.prepareElements(e2), t.cleanupElements(e2), t.prepareElements(e2);
        }, t.getSVGElement = function(e2, t2, i2) {
          var n;
          return t2.hasOwnProperty(e2) ? t2[e2].redundant.length > 0 ? (n = t2[e2].redundant[0], t2[e2].redundant.shift()) : (n = document.createElementNS("http://www.w3.org/2000/svg", e2), i2.appendChild(n)) : (n = document.createElementNS("http://www.w3.org/2000/svg", e2), t2[e2] = { used: [], redundant: [] }, i2.appendChild(n)), t2[e2].used.push(n), n;
        }, t.getDOMElement = function(e2, t2, i2, n) {
          var o;
          return t2.hasOwnProperty(e2) ? t2[e2].redundant.length > 0 ? (o = t2[e2].redundant[0], t2[e2].redundant.shift()) : (o = document.createElement(e2), void 0 !== n ? i2.insertBefore(o, n) : i2.appendChild(o)) : (o = document.createElement(e2), t2[e2] = { used: [], redundant: [] }, void 0 !== n ? i2.insertBefore(o, n) : i2.appendChild(o)), t2[e2].used.push(o), o;
        }, t.drawPoint = function(e2, i2, n, o, s, r) {
          var a;
          if ("circle" == n.style ? (a = t.getSVGElement("circle", o, s), a.setAttributeNS(null, "cx", e2), a.setAttributeNS(null, "cy", i2), a.setAttributeNS(null, "r", 0.5 * n.size)) : (a = t.getSVGElement("rect", o, s), a.setAttributeNS(null, "x", e2 - 0.5 * n.size), a.setAttributeNS(null, "y", i2 - 0.5 * n.size), a.setAttributeNS(null, "width", n.size), a.setAttributeNS(null, "height", n.size)), void 0 !== n.styles && a.setAttributeNS(null, "style", n.styles), a.setAttributeNS(null, "class", n.className + " vis-point"), r) {
            var d = t.getSVGElement("text", o, s);
            r.xOffset && (e2 += r.xOffset), r.yOffset && (i2 += r.yOffset), r.content && (d.textContent = r.content), r.className && d.setAttributeNS(null, "class", r.className + " vis-label"), d.setAttributeNS(null, "x", e2), d.setAttributeNS(null, "y", i2);
          }
          return a;
        }, t.drawBar = function(e2, i2, n, o, s, r, a, d) {
          if (0 != o) {
            o < 0 && (o *= -1, i2 -= o);
            var h = t.getSVGElement("rect", r, a);
            h.setAttributeNS(null, "x", e2 - 0.5 * n), h.setAttributeNS(null, "y", i2), h.setAttributeNS(null, "width", n), h.setAttributeNS(null, "height", o), h.setAttributeNS(null, "class", s), d && h.setAttributeNS(null, "style", d);
          }
        };
      }, function(e, t, i) {
        var n = i(6), o = n.JSON || (n.JSON = { stringify: JSON.stringify });
        e.exports = function(e2) {
          return o.stringify.apply(o, arguments);
        };
      }, function(e, t, i) {
        function n(e2, t2, i2) {
          var o2 = this;
          if (!(this instanceof n))
            throw new SyntaxError("Constructor must be called with the new operator");
          this.options = {}, this.defaultOptions = { locale: "en", locales: h, clickToUse: false }, s.extend(this.options, this.defaultOptions), this.body = { container: e2, nodes: {}, nodeIndices: [], edges: {}, edgeIndices: [], emitter: { on: this.on.bind(this), off: this.off.bind(this), emit: this.emit.bind(this), once: this.once.bind(this) }, eventListeners: { onTap: function() {
          }, onTouch: function() {
          }, onDoubleTap: function() {
          }, onHold: function() {
          }, onDragStart: function() {
          }, onDrag: function() {
          }, onDragEnd: function() {
          }, onMouseWheel: function() {
          }, onPinch: function() {
          }, onMouseMove: function() {
          }, onRelease: function() {
          }, onContext: function() {
          } }, data: { nodes: null, edges: null }, functions: { createNode: function() {
          }, createEdge: function() {
          }, getPointer: function() {
          } }, modules: {}, view: { scale: 1, translation: { x: 0, y: 0 } } }, this.bindEventListeners(), this.images = new l(function() {
            return o2.body.emitter.emit("_requestRedraw");
          }), this.groups = new u(), this.canvas = new y(this.body), this.selectionHandler = new _(this.body, this.canvas), this.interactionHandler = new b(this.body, this.canvas, this.selectionHandler), this.view = new m(this.body, this.canvas), this.renderer = new g(this.body, this.canvas), this.physics = new p(this.body), this.layoutEngine = new w(this.body), this.clustering = new v(this.body), this.manipulation = new k(this.body, this.canvas, this.selectionHandler), this.nodesHandler = new c(this.body, this.images, this.groups, this.layoutEngine), this.edgesHandler = new f(this.body, this.images, this.groups), this.body.modules.kamadaKawai = new T(this.body, 150, 0.05), this.body.modules.clustering = this.clustering, this.canvas._create(), this.setOptions(i2), this.setData(t2);
        }
        i(122);
        var o = i(73), s = i(5), r = i(74), a = i(75), d = i(123), h = i(126), l = i(76).default, u = i(131).default, c = i(132).default, f = i(163).default, p = i(169).default, v = i(176).default, g = i(178).default, y = i(179).default, m = i(180).default, b = i(181).default, _ = i(184).default, w = i(185).default, k = i(187).default, x = i(188).default, O = i(54).default, M = i(54), E = M.printStyle, S = i(82), D = S.allOptions, C = S.configureOptions, T = i(190).default;
        o(n.prototype), n.prototype.setOptions = function(e2) {
          var t2 = this;
          if (void 0 !== e2) {
            true === O.validate(e2, D) && console.log("%cErrors have been found in the supplied options object.", E);
            var i2 = ["locale", "locales", "clickToUse"];
            if (s.selectiveDeepExtend(i2, this.options, e2), e2 = this.layoutEngine.setOptions(e2.layout, e2), this.canvas.setOptions(e2), this.groups.setOptions(e2.groups), this.nodesHandler.setOptions(e2.nodes), this.edgesHandler.setOptions(e2.edges), this.physics.setOptions(e2.physics), this.manipulation.setOptions(e2.manipulation, e2, this.options), this.interactionHandler.setOptions(e2.interaction), this.renderer.setOptions(e2.interaction), this.selectionHandler.setOptions(e2.interaction), void 0 !== e2.groups && this.body.emitter.emit("refreshNodes"), "configure" in e2 && (this.configurator || (this.configurator = new x(this, this.body.container, C, this.canvas.pixelRatio)), this.configurator.setOptions(e2.configure)), this.configurator && true === this.configurator.options.enabled) {
              var n2 = { nodes: {}, edges: {}, layout: {}, interaction: {}, manipulation: {}, physics: {}, global: {} };
              s.deepExtend(n2.nodes, this.nodesHandler.options), s.deepExtend(n2.edges, this.edgesHandler.options), s.deepExtend(n2.layout, this.layoutEngine.options), s.deepExtend(n2.interaction, this.selectionHandler.options), s.deepExtend(n2.interaction, this.renderer.options), s.deepExtend(n2.interaction, this.interactionHandler.options), s.deepExtend(n2.manipulation, this.manipulation.options), s.deepExtend(n2.physics, this.physics.options), s.deepExtend(n2.global, this.canvas.options), s.deepExtend(n2.global, this.options), this.configurator.setModuleOptions(n2);
            }
            void 0 !== e2.clickToUse ? true === e2.clickToUse ? void 0 === this.activator && (this.activator = new d(this.canvas.frame), this.activator.on("change", function() {
              t2.body.emitter.emit("activate");
            })) : (void 0 !== this.activator && (this.activator.destroy(), delete this.activator), this.body.emitter.emit("activate")) : this.body.emitter.emit("activate"), this.canvas.setSize(), this.body.emitter.emit("startSimulation");
          }
        }, n.prototype._updateVisibleIndices = function() {
          var e2 = this.body.nodes, t2 = this.body.edges;
          this.body.nodeIndices = [], this.body.edgeIndices = [];
          for (var i2 in e2)
            e2.hasOwnProperty(i2) && (this.clustering._isClusteredNode(i2) || false !== e2[i2].options.hidden || this.body.nodeIndices.push(e2[i2].id));
          for (var n2 in t2)
            if (t2.hasOwnProperty(n2)) {
              var o2 = t2[n2], s2 = e2[o2.fromId], r2 = e2[o2.toId], a2 = void 0 !== s2 && void 0 !== r2, d2 = !this.clustering._isClusteredEdge(n2) && false === o2.options.hidden && a2 && false === s2.options.hidden && false === r2.options.hidden;
              d2 && this.body.edgeIndices.push(o2.id);
            }
        }, n.prototype.bindEventListeners = function() {
          var e2 = this;
          this.body.emitter.on("_dataChanged", function() {
            e2.edgesHandler._updateState(), e2.body.emitter.emit("_dataUpdated");
          }), this.body.emitter.on("_dataUpdated", function() {
            e2.clustering._updateState(), e2._updateVisibleIndices(), e2._updateValueRange(e2.body.nodes), e2._updateValueRange(e2.body.edges), e2.body.emitter.emit("startSimulation"), e2.body.emitter.emit("_requestRedraw");
          });
        }, n.prototype.setData = function(e2) {
          if (this.body.emitter.emit("resetPhysics"), this.body.emitter.emit("_resetData"), this.selectionHandler.unselectAll(), e2 && e2.dot && (e2.nodes || e2.edges))
            throw new SyntaxError('Data must contain either parameter "dot" or  parameter pair "nodes" and "edges", but not both.');
          if (this.setOptions(e2 && e2.options), e2 && e2.dot) {
            console.log("The dot property has been deprecated. Please use the static convertDot method to convert DOT into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertDot(dotString);");
            var t2 = r.DOTToGraph(e2.dot);
            return void this.setData(t2);
          }
          if (e2 && e2.gephi) {
            console.log("The gephi property has been deprecated. Please use the static convertGephi method to convert gephi into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertGephi(gephiJson);");
            var i2 = a.parseGephi(e2.gephi);
            return void this.setData(i2);
          }
          this.nodesHandler.setData(e2 && e2.nodes, true), this.edgesHandler.setData(e2 && e2.edges, true), this.body.emitter.emit("_dataChanged"), this.body.emitter.emit("_dataLoaded"), this.body.emitter.emit("initPhysics");
        }, n.prototype.destroy = function() {
          this.body.emitter.emit("destroy"), this.body.emitter.off(), this.off(), delete this.groups, delete this.canvas, delete this.selectionHandler, delete this.interactionHandler, delete this.view, delete this.renderer, delete this.physics, delete this.layoutEngine, delete this.clustering, delete this.manipulation, delete this.nodesHandler, delete this.edgesHandler, delete this.configurator, delete this.images;
          for (var e2 in this.body.nodes)
            this.body.nodes.hasOwnProperty(e2) && delete this.body.nodes[e2];
          for (var t2 in this.body.edges)
            this.body.edges.hasOwnProperty(t2) && delete this.body.edges[t2];
          s.recursiveDOMDelete(this.body.container);
        }, n.prototype._updateValueRange = function(e2) {
          var t2, i2 = void 0, n2 = void 0, o2 = 0;
          for (t2 in e2)
            if (e2.hasOwnProperty(t2)) {
              var s2 = e2[t2].getValue();
              void 0 !== s2 && (i2 = void 0 === i2 ? s2 : Math.min(s2, i2), n2 = void 0 === n2 ? s2 : Math.max(s2, n2), o2 += s2);
            }
          if (void 0 !== i2 && void 0 !== n2)
            for (t2 in e2)
              e2.hasOwnProperty(t2) && e2[t2].setValueRange(i2, n2, o2);
        }, n.prototype.isActive = function() {
          return !this.activator || this.activator.active;
        }, n.prototype.setSize = function() {
          return this.canvas.setSize.apply(this.canvas, arguments);
        }, n.prototype.canvasToDOM = function() {
          return this.canvas.canvasToDOM.apply(this.canvas, arguments);
        }, n.prototype.DOMtoCanvas = function() {
          return this.canvas.DOMtoCanvas.apply(this.canvas, arguments);
        }, n.prototype.findNode = function() {
          return this.clustering.findNode.apply(this.clustering, arguments);
        }, n.prototype.isCluster = function() {
          return this.clustering.isCluster.apply(this.clustering, arguments);
        }, n.prototype.openCluster = function() {
          return this.clustering.openCluster.apply(this.clustering, arguments);
        }, n.prototype.cluster = function() {
          return this.clustering.cluster.apply(this.clustering, arguments);
        }, n.prototype.getNodesInCluster = function() {
          return this.clustering.getNodesInCluster.apply(this.clustering, arguments);
        }, n.prototype.clusterByConnection = function() {
          return this.clustering.clusterByConnection.apply(this.clustering, arguments);
        }, n.prototype.clusterByHubsize = function() {
          return this.clustering.clusterByHubsize.apply(this.clustering, arguments);
        }, n.prototype.clusterOutliers = function() {
          return this.clustering.clusterOutliers.apply(this.clustering, arguments);
        }, n.prototype.getSeed = function() {
          return this.layoutEngine.getSeed.apply(this.layoutEngine, arguments);
        }, n.prototype.enableEditMode = function() {
          return this.manipulation.enableEditMode.apply(this.manipulation, arguments);
        }, n.prototype.disableEditMode = function() {
          return this.manipulation.disableEditMode.apply(this.manipulation, arguments);
        }, n.prototype.addNodeMode = function() {
          return this.manipulation.addNodeMode.apply(this.manipulation, arguments);
        }, n.prototype.editNode = function() {
          return this.manipulation.editNode.apply(this.manipulation, arguments);
        }, n.prototype.editNodeMode = function() {
          return console.log("Deprecated: Please use editNode instead of editNodeMode."), this.manipulation.editNode.apply(this.manipulation, arguments);
        }, n.prototype.addEdgeMode = function() {
          return this.manipulation.addEdgeMode.apply(this.manipulation, arguments);
        }, n.prototype.editEdgeMode = function() {
          return this.manipulation.editEdgeMode.apply(this.manipulation, arguments);
        }, n.prototype.deleteSelected = function() {
          return this.manipulation.deleteSelected.apply(this.manipulation, arguments);
        }, n.prototype.getPositions = function() {
          return this.nodesHandler.getPositions.apply(this.nodesHandler, arguments);
        }, n.prototype.storePositions = function() {
          return this.nodesHandler.storePositions.apply(this.nodesHandler, arguments);
        }, n.prototype.moveNode = function() {
          return this.nodesHandler.moveNode.apply(this.nodesHandler, arguments);
        }, n.prototype.getBoundingBox = function() {
          return this.nodesHandler.getBoundingBox.apply(this.nodesHandler, arguments);
        }, n.prototype.getConnectedNodes = function(e2) {
          return void 0 !== this.body.nodes[e2] ? this.nodesHandler.getConnectedNodes.apply(this.nodesHandler, arguments) : this.edgesHandler.getConnectedNodes.apply(this.edgesHandler, arguments);
        }, n.prototype.getConnectedEdges = function() {
          return this.nodesHandler.getConnectedEdges.apply(this.nodesHandler, arguments);
        }, n.prototype.startSimulation = function() {
          return this.physics.startSimulation.apply(this.physics, arguments);
        }, n.prototype.stopSimulation = function() {
          return this.physics.stopSimulation.apply(this.physics, arguments);
        }, n.prototype.stabilize = function() {
          return this.physics.stabilize.apply(this.physics, arguments);
        }, n.prototype.getSelection = function() {
          return this.selectionHandler.getSelection.apply(this.selectionHandler, arguments);
        }, n.prototype.setSelection = function() {
          return this.selectionHandler.setSelection.apply(this.selectionHandler, arguments);
        }, n.prototype.getSelectedNodes = function() {
          return this.selectionHandler.getSelectedNodes.apply(this.selectionHandler, arguments);
        }, n.prototype.getSelectedEdges = function() {
          return this.selectionHandler.getSelectedEdges.apply(this.selectionHandler, arguments);
        }, n.prototype.getNodeAt = function() {
          var e2 = this.selectionHandler.getNodeAt.apply(this.selectionHandler, arguments);
          return void 0 !== e2 && void 0 !== e2.id ? e2.id : e2;
        }, n.prototype.getEdgeAt = function() {
          var e2 = this.selectionHandler.getEdgeAt.apply(this.selectionHandler, arguments);
          return void 0 !== e2 && void 0 !== e2.id ? e2.id : e2;
        }, n.prototype.selectNodes = function() {
          return this.selectionHandler.selectNodes.apply(this.selectionHandler, arguments);
        }, n.prototype.selectEdges = function() {
          return this.selectionHandler.selectEdges.apply(this.selectionHandler, arguments);
        }, n.prototype.unselectAll = function() {
          this.selectionHandler.unselectAll.apply(this.selectionHandler, arguments), this.redraw();
        }, n.prototype.redraw = function() {
          return this.renderer.redraw.apply(this.renderer, arguments);
        }, n.prototype.getScale = function() {
          return this.view.getScale.apply(this.view, arguments);
        }, n.prototype.getViewPosition = function() {
          return this.view.getViewPosition.apply(this.view, arguments);
        }, n.prototype.fit = function() {
          return this.view.fit.apply(this.view, arguments);
        }, n.prototype.moveTo = function() {
          return this.view.moveTo.apply(this.view, arguments);
        }, n.prototype.focus = function() {
          return this.view.focus.apply(this.view, arguments);
        }, n.prototype.releaseNode = function() {
          return this.view.releaseNode.apply(this.view, arguments);
        }, n.prototype.getOptionsFromConfigurator = function() {
          var e2 = {};
          return this.configurator && (e2 = this.configurator.getOptions.apply(this.configurator)), e2;
        }, e.exports = n;
      }, function(e, t, i) {
        "undefined" != typeof CanvasRenderingContext2D && (CanvasRenderingContext2D.prototype.circle = function(e2, t2, i2) {
          this.beginPath(), this.arc(e2, t2, i2, 0, 2 * Math.PI, false), this.closePath();
        }, CanvasRenderingContext2D.prototype.square = function(e2, t2, i2) {
          this.beginPath(), this.rect(e2 - i2, t2 - i2, 2 * i2, 2 * i2), this.closePath();
        }, CanvasRenderingContext2D.prototype.triangle = function(e2, t2, i2) {
          this.beginPath(), i2 *= 1.15, t2 += 0.275 * i2;
          var n = 2 * i2, o = n / 2, s = Math.sqrt(3) / 6 * n, r = Math.sqrt(n * n - o * o);
          this.moveTo(e2, t2 - (r - s)), this.lineTo(e2 + o, t2 + s), this.lineTo(e2 - o, t2 + s), this.lineTo(e2, t2 - (r - s)), this.closePath();
        }, CanvasRenderingContext2D.prototype.triangleDown = function(e2, t2, i2) {
          this.beginPath(), i2 *= 1.15, t2 -= 0.275 * i2;
          var n = 2 * i2, o = n / 2, s = Math.sqrt(3) / 6 * n, r = Math.sqrt(n * n - o * o);
          this.moveTo(e2, t2 + (r - s)), this.lineTo(e2 + o, t2 - s), this.lineTo(e2 - o, t2 - s), this.lineTo(e2, t2 + (r - s)), this.closePath();
        }, CanvasRenderingContext2D.prototype.star = function(e2, t2, i2) {
          this.beginPath(), i2 *= 0.82, t2 += 0.1 * i2;
          for (var n = 0; n < 10; n++) {
            var o = n % 2 == 0 ? 1.3 * i2 : 0.5 * i2;
            this.lineTo(e2 + o * Math.sin(2 * n * Math.PI / 10), t2 - o * Math.cos(2 * n * Math.PI / 10));
          }
          this.closePath();
        }, CanvasRenderingContext2D.prototype.diamond = function(e2, t2, i2) {
          this.beginPath(), this.lineTo(e2, t2 + i2), this.lineTo(e2 + i2, t2), this.lineTo(e2, t2 - i2), this.lineTo(e2 - i2, t2), this.closePath();
        }, CanvasRenderingContext2D.prototype.roundRect = function(e2, t2, i2, n, o) {
          var s = Math.PI / 180;
          i2 - 2 * o < 0 && (o = i2 / 2), n - 2 * o < 0 && (o = n / 2), this.beginPath(), this.moveTo(e2 + o, t2), this.lineTo(e2 + i2 - o, t2), this.arc(e2 + i2 - o, t2 + o, o, 270 * s, 360 * s, false), this.lineTo(e2 + i2, t2 + n - o), this.arc(e2 + i2 - o, t2 + n - o, o, 0, 90 * s, false), this.lineTo(e2 + o, t2 + n), this.arc(e2 + o, t2 + n - o, o, 90 * s, 180 * s, false), this.lineTo(e2, t2 + o), this.arc(e2 + o, t2 + o, o, 180 * s, 270 * s, false), this.closePath();
        }, CanvasRenderingContext2D.prototype.ellipse_vis = function(e2, t2, i2, n) {
          var o = i2 / 2 * 0.5522848, s = n / 2 * 0.5522848, r = e2 + i2, a = t2 + n, d = e2 + i2 / 2, h = t2 + n / 2;
          this.beginPath(), this.moveTo(e2, h), this.bezierCurveTo(e2, h - s, d - o, t2, d, t2), this.bezierCurveTo(d + o, t2, r, h - s, r, h), this.bezierCurveTo(r, h + s, d + o, a, d, a), this.bezierCurveTo(d - o, a, e2, h + s, e2, h), this.closePath();
        }, CanvasRenderingContext2D.prototype.database = function(e2, t2, i2, n) {
          var o = i2, s = n * (1 / 3), r = o / 2 * 0.5522848, a = s / 2 * 0.5522848, d = e2 + o, h = t2 + s, l = e2 + o / 2, u = t2 + s / 2, c = t2 + (n - s / 2), f = t2 + n;
          this.beginPath(), this.moveTo(d, u), this.bezierCurveTo(d, u + a, l + r, h, l, h), this.bezierCurveTo(l - r, h, e2, u + a, e2, u), this.bezierCurveTo(e2, u - a, l - r, t2, l, t2), this.bezierCurveTo(l + r, t2, d, u - a, d, u), this.lineTo(d, c), this.bezierCurveTo(d, c + a, l + r, f, l, f), this.bezierCurveTo(l - r, f, e2, c + a, e2, c), this.lineTo(e2, u);
        }, CanvasRenderingContext2D.prototype.dashedLine = function(e2, t2, i2, n, o) {
          this.beginPath(), this.moveTo(e2, t2);
          for (var s = o.length, r = i2 - e2, a = n - t2, d = a / r, h = Math.sqrt(r * r + a * a), l = 0, u = true, c = 0, f = o[0]; h >= 0.1; )
            f = o[l++ % s], f > h && (f = h), c = Math.sqrt(f * f / (1 + d * d)), c = r < 0 ? -c : c, e2 += c, t2 += d * c, true === u ? this.lineTo(e2, t2) : this.moveTo(e2, t2), h -= f, u = !u;
        }, CanvasRenderingContext2D.prototype.hexagon = function(e2, t2, i2) {
          this.beginPath();
          var n = 2 * Math.PI / 6;
          this.moveTo(e2 + i2, t2);
          for (var o = 1; o < 6; o++)
            this.lineTo(e2 + i2 * Math.cos(n * o), t2 + i2 * Math.sin(n * o));
          this.closePath();
        });
      }, function(e, t, i) {
        function n(e2) {
          this.active = false, this.dom = { container: e2 }, this.dom.overlay = document.createElement("div"), this.dom.overlay.className = "vis-overlay", this.dom.container.appendChild(this.dom.overlay), this.hammer = a(this.dom.overlay), this.hammer.on("tap", this._onTapOverlay.bind(this));
          var t2 = this;
          ["tap", "doubletap", "press", "pinch", "pan", "panstart", "panmove", "panend"].forEach(function(e3) {
            t2.hammer.on(e3, function(e4) {
              e4.stopPropagation();
            });
          }), document && document.body && (this.onClick = function(i2) {
            o(i2.target, e2) || t2.deactivate();
          }, document.body.addEventListener("click", this.onClick)), void 0 !== this.keycharm && this.keycharm.destroy(), this.keycharm = s(), this.escListener = this.deactivate.bind(this);
        }
        function o(e2, t2) {
          for (; e2; ) {
            if (e2 === t2)
              return true;
            e2 = e2.parentNode;
          }
          return false;
        }
        var s = i(52), r = i(73), a = i(22), d = i(5);
        r(n.prototype), n.current = null, n.prototype.destroy = function() {
          this.deactivate(), this.dom.overlay.parentNode.removeChild(this.dom.overlay), this.onClick && document.body.removeEventListener("click", this.onClick), this.hammer.destroy(), this.hammer = null;
        }, n.prototype.activate = function() {
          n.current && n.current.deactivate(), n.current = this, this.active = true, this.dom.overlay.style.display = "none", d.addClassName(this.dom.container, "vis-active"), this.emit("change"), this.emit("activate"), this.keycharm.bind("esc", this.escListener);
        }, n.prototype.deactivate = function() {
          this.active = false, this.dom.overlay.style.display = "", d.removeClassName(this.dom.container, "vis-active"), this.keycharm.unbind("esc", this.escListener), this.emit("change"), this.emit("deactivate");
        }, n.prototype._onTapOverlay = function(e2) {
          this.activate(), e2.stopPropagation();
        }, e.exports = n;
      }, function(e, t, i) {
        var n, o, s;
        !function(i2) {
          o = [], n = i2, void 0 !== (s = "function" == typeof n ? n.apply(t, o) : n) && (e.exports = s);
        }(function() {
          var e2 = null;
          return function t2(i2, n2) {
            function o2(e3) {
              return e3.match(/[^ ]+/g);
            }
            function s2(t3) {
              if ("hammer.input" !== t3.type) {
                if (t3.srcEvent._handled || (t3.srcEvent._handled = {}), t3.srcEvent._handled[t3.type])
                  return;
                t3.srcEvent._handled[t3.type] = true;
              }
              var i3 = false;
              t3.stopPropagation = function() {
                i3 = true;
              };
              var n3 = t3.srcEvent.stopPropagation.bind(t3.srcEvent);
              "function" == typeof n3 && (t3.srcEvent.stopPropagation = function() {
                n3(), t3.stopPropagation();
              }), t3.firstTarget = e2;
              for (var o3 = e2; o3 && !i3; ) {
                var s3 = o3.hammer;
                if (s3) {
                  for (var r2, a2 = 0; a2 < s3.length; a2++)
                    if (r2 = s3[a2]._handlers[t3.type])
                      for (var d2 = 0; d2 < r2.length && !i3; d2++)
                        r2[d2](t3);
                }
                o3 = o3.parentNode;
              }
            }
            var r = n2 || { preventDefault: false };
            if (i2.Manager) {
              var a = i2, d = function(e3, i3) {
                var n3 = Object.create(r);
                return i3 && a.assign(n3, i3), t2(new a(e3, n3), n3);
              };
              return a.assign(d, a), d.Manager = function(e3, i3) {
                var n3 = Object.create(r);
                return i3 && a.assign(n3, i3), t2(new a.Manager(e3, n3), n3);
              }, d;
            }
            var h = Object.create(i2), l = i2.element;
            return l.hammer || (l.hammer = []), l.hammer.push(h), i2.on("hammer.input", function(t3) {
              true !== r.preventDefault && r.preventDefault !== t3.pointerType || t3.preventDefault(), t3.isFirst && (e2 = t3.target);
            }), h._handlers = {}, h.on = function(e3, t3) {
              return o2(e3).forEach(function(e4) {
                var n3 = h._handlers[e4];
                n3 || (h._handlers[e4] = n3 = [], i2.on(e4, s2)), n3.push(t3);
              }), h;
            }, h.off = function(e3, t3) {
              return o2(e3).forEach(function(e4) {
                var n3 = h._handlers[e4];
                n3 && (n3 = t3 ? n3.filter(function(e5) {
                  return e5 !== t3;
                }) : [], n3.length > 0 ? h._handlers[e4] = n3 : (i2.off(e4, s2), delete h._handlers[e4]));
              }), h;
            }, h.emit = function(t3, n3) {
              e2 = n3.target, i2.emit(t3, n3);
            }, h.destroy = function() {
              var e3 = i2.element.hammer, t3 = e3.indexOf(h);
              -1 !== t3 && e3.splice(t3, 1), e3.length || delete i2.element.hammer, h._handlers = {}, i2.destroy();
            }, h;
          };
        });
      }, function(e, t, i) {
        var n;
        !function(o, s, r, a) {
          function d(e2, t2, i2) {
            return setTimeout(f(e2, i2), t2);
          }
          function h(e2, t2, i2) {
            return !!Array.isArray(e2) && (l(e2, i2[t2], i2), true);
          }
          function l(e2, t2, i2) {
            var n2;
            if (e2)
              if (e2.forEach)
                e2.forEach(t2, i2);
              else if (e2.length !== a)
                for (n2 = 0; n2 < e2.length; )
                  t2.call(i2, e2[n2], n2, e2), n2++;
              else
                for (n2 in e2)
                  e2.hasOwnProperty(n2) && t2.call(i2, e2[n2], n2, e2);
          }
          function u(e2, t2, i2) {
            var n2 = "DEPRECATED METHOD: " + t2 + "\n" + i2 + " AT \n";
            return function() {
              var t3 = new Error("get-stack-trace"), i3 = t3 && t3.stack ? t3.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace", s2 = o.console && (o.console.warn || o.console.log);
              return s2 && s2.call(o.console, n2, i3), e2.apply(this, arguments);
            };
          }
          function c(e2, t2, i2) {
            var n2, o2 = t2.prototype;
            n2 = e2.prototype = Object.create(o2), n2.constructor = e2, n2._super = o2, i2 && pe(n2, i2);
          }
          function f(e2, t2) {
            return function() {
              return e2.apply(t2, arguments);
            };
          }
          function p(e2, t2) {
            return typeof e2 == ye ? e2.apply(t2 ? t2[0] || a : a, t2) : e2;
          }
          function v(e2, t2) {
            return e2 === a ? t2 : e2;
          }
          function g(e2, t2, i2) {
            l(_(t2), function(t3) {
              e2.addEventListener(t3, i2, false);
            });
          }
          function y(e2, t2, i2) {
            l(_(t2), function(t3) {
              e2.removeEventListener(t3, i2, false);
            });
          }
          function m(e2, t2) {
            for (; e2; ) {
              if (e2 == t2)
                return true;
              e2 = e2.parentNode;
            }
            return false;
          }
          function b(e2, t2) {
            return e2.indexOf(t2) > -1;
          }
          function _(e2) {
            return e2.trim().split(/\s+/g);
          }
          function w(e2, t2, i2) {
            if (e2.indexOf && !i2)
              return e2.indexOf(t2);
            for (var n2 = 0; n2 < e2.length; ) {
              if (i2 && e2[n2][i2] == t2 || !i2 && e2[n2] === t2)
                return n2;
              n2++;
            }
            return -1;
          }
          function k(e2) {
            return Array.prototype.slice.call(e2, 0);
          }
          function x(e2, t2, i2) {
            for (var n2 = [], o2 = [], s2 = 0; s2 < e2.length; ) {
              var r2 = t2 ? e2[s2][t2] : e2[s2];
              w(o2, r2) < 0 && n2.push(e2[s2]), o2[s2] = r2, s2++;
            }
            return i2 && (n2 = t2 ? n2.sort(function(e3, i3) {
              return e3[t2] > i3[t2];
            }) : n2.sort()), n2;
          }
          function O(e2, t2) {
            for (var i2, n2, o2 = t2[0].toUpperCase() + t2.slice(1), s2 = 0; s2 < ve.length; ) {
              if (i2 = ve[s2], (n2 = i2 ? i2 + o2 : t2) in e2)
                return n2;
              s2++;
            }
            return a;
          }
          function M() {
            return xe++;
          }
          function E(e2) {
            var t2 = e2.ownerDocument || e2;
            return t2.defaultView || t2.parentWindow || o;
          }
          function S(e2, t2) {
            var i2 = this;
            this.manager = e2, this.callback = t2, this.element = e2.element, this.target = e2.options.inputTarget, this.domHandler = function(t3) {
              p(e2.options.enable, [e2]) && i2.handler(t3);
            }, this.init();
          }
          function D(e2) {
            var t2 = e2.options.inputClass;
            return new (t2 || (Ee ? W : Se ? U : Me ? G : H))(e2, C);
          }
          function C(e2, t2, i2) {
            var n2 = i2.pointers.length, o2 = i2.changedPointers.length, s2 = t2 & Ce && n2 - o2 == 0, r2 = t2 & (Pe | Ie) && n2 - o2 == 0;
            i2.isFirst = !!s2, i2.isFinal = !!r2, s2 && (e2.session = {}), i2.eventType = t2, T(e2, i2), e2.emit("hammer.input", i2), e2.recognize(i2), e2.session.prevInput = i2;
          }
          function T(e2, t2) {
            var i2 = e2.session, n2 = t2.pointers, o2 = n2.length;
            i2.firstInput || (i2.firstInput = F(t2)), o2 > 1 && !i2.firstMultiple ? i2.firstMultiple = F(t2) : 1 === o2 && (i2.firstMultiple = false);
            var s2 = i2.firstInput, r2 = i2.firstMultiple, a2 = r2 ? r2.center : s2.center, d2 = t2.center = N(n2);
            t2.timeStamp = _e(), t2.deltaTime = t2.timeStamp - s2.timeStamp, t2.angle = A(a2, d2), t2.distance = R(a2, d2), P(i2, t2), t2.offsetDirection = z(t2.deltaX, t2.deltaY);
            var h2 = B(t2.deltaTime, t2.deltaX, t2.deltaY);
            t2.overallVelocityX = h2.x, t2.overallVelocityY = h2.y, t2.overallVelocity = be(h2.x) > be(h2.y) ? h2.x : h2.y, t2.scale = r2 ? L(r2.pointers, n2) : 1, t2.rotation = r2 ? j(r2.pointers, n2) : 0, t2.maxPointers = i2.prevInput ? t2.pointers.length > i2.prevInput.maxPointers ? t2.pointers.length : i2.prevInput.maxPointers : t2.pointers.length, I(i2, t2);
            var l2 = e2.element;
            m(t2.srcEvent.target, l2) && (l2 = t2.srcEvent.target), t2.target = l2;
          }
          function P(e2, t2) {
            var i2 = t2.center, n2 = e2.offsetDelta || {}, o2 = e2.prevDelta || {}, s2 = e2.prevInput || {};
            t2.eventType !== Ce && s2.eventType !== Pe || (o2 = e2.prevDelta = { x: s2.deltaX || 0, y: s2.deltaY || 0 }, n2 = e2.offsetDelta = { x: i2.x, y: i2.y }), t2.deltaX = o2.x + (i2.x - n2.x), t2.deltaY = o2.y + (i2.y - n2.y);
          }
          function I(e2, t2) {
            var i2, n2, o2, s2, r2 = e2.lastInterval || t2, d2 = t2.timeStamp - r2.timeStamp;
            if (t2.eventType != Ie && (d2 > De || r2.velocity === a)) {
              var h2 = t2.deltaX - r2.deltaX, l2 = t2.deltaY - r2.deltaY, u2 = B(d2, h2, l2);
              n2 = u2.x, o2 = u2.y, i2 = be(u2.x) > be(u2.y) ? u2.x : u2.y, s2 = z(h2, l2), e2.lastInterval = t2;
            } else
              i2 = r2.velocity, n2 = r2.velocityX, o2 = r2.velocityY, s2 = r2.direction;
            t2.velocity = i2, t2.velocityX = n2, t2.velocityY = o2, t2.direction = s2;
          }
          function F(e2) {
            for (var t2 = [], i2 = 0; i2 < e2.pointers.length; )
              t2[i2] = { clientX: me(e2.pointers[i2].clientX), clientY: me(e2.pointers[i2].clientY) }, i2++;
            return { timeStamp: _e(), pointers: t2, center: N(t2), deltaX: e2.deltaX, deltaY: e2.deltaY };
          }
          function N(e2) {
            var t2 = e2.length;
            if (1 === t2)
              return { x: me(e2[0].clientX), y: me(e2[0].clientY) };
            for (var i2 = 0, n2 = 0, o2 = 0; o2 < t2; )
              i2 += e2[o2].clientX, n2 += e2[o2].clientY, o2++;
            return { x: me(i2 / t2), y: me(n2 / t2) };
          }
          function B(e2, t2, i2) {
            return { x: t2 / e2 || 0, y: i2 / e2 || 0 };
          }
          function z(e2, t2) {
            return e2 === t2 ? Fe : be(e2) >= be(t2) ? e2 < 0 ? Ne : Be : t2 < 0 ? ze : Re;
          }
          function R(e2, t2, i2) {
            i2 || (i2 = He);
            var n2 = t2[i2[0]] - e2[i2[0]], o2 = t2[i2[1]] - e2[i2[1]];
            return Math.sqrt(n2 * n2 + o2 * o2);
          }
          function A(e2, t2, i2) {
            i2 || (i2 = He);
            var n2 = t2[i2[0]] - e2[i2[0]], o2 = t2[i2[1]] - e2[i2[1]];
            return 180 * Math.atan2(o2, n2) / Math.PI;
          }
          function j(e2, t2) {
            return A(t2[1], t2[0], We) + A(e2[1], e2[0], We);
          }
          function L(e2, t2) {
            return R(t2[0], t2[1], We) / R(e2[0], e2[1], We);
          }
          function H() {
            this.evEl = Ve, this.evWin = Ue, this.pressed = false, S.apply(this, arguments);
          }
          function W() {
            this.evEl = Xe, this.evWin = Ke, S.apply(this, arguments), this.store = this.manager.session.pointerEvents = [];
          }
          function Y() {
            this.evTarget = $e, this.evWin = Qe, this.started = false, S.apply(this, arguments);
          }
          function V(e2, t2) {
            var i2 = k(e2.touches), n2 = k(e2.changedTouches);
            return t2 & (Pe | Ie) && (i2 = x(i2.concat(n2), "identifier", true)), [i2, n2];
          }
          function U() {
            this.evTarget = et, this.targetIds = {}, S.apply(this, arguments);
          }
          function q(e2, t2) {
            var i2 = k(e2.touches), n2 = this.targetIds;
            if (t2 & (Ce | Te) && 1 === i2.length)
              return n2[i2[0].identifier] = true, [i2, i2];
            var o2, s2, r2 = k(e2.changedTouches), a2 = [], d2 = this.target;
            if (s2 = i2.filter(function(e3) {
              return m(e3.target, d2);
            }), t2 === Ce)
              for (o2 = 0; o2 < s2.length; )
                n2[s2[o2].identifier] = true, o2++;
            for (o2 = 0; o2 < r2.length; )
              n2[r2[o2].identifier] && a2.push(r2[o2]), t2 & (Pe | Ie) && delete n2[r2[o2].identifier], o2++;
            return a2.length ? [x(s2.concat(a2), "identifier", true), a2] : void 0;
          }
          function G() {
            S.apply(this, arguments);
            var e2 = f(this.handler, this);
            this.touch = new U(this.manager, e2), this.mouse = new H(this.manager, e2), this.primaryTouch = null, this.lastTouches = [];
          }
          function X(e2, t2) {
            e2 & Ce ? (this.primaryTouch = t2.changedPointers[0].identifier, K.call(this, t2)) : e2 & (Pe | Ie) && K.call(this, t2);
          }
          function K(e2) {
            var t2 = e2.changedPointers[0];
            if (t2.identifier === this.primaryTouch) {
              var i2 = { x: t2.clientX, y: t2.clientY };
              this.lastTouches.push(i2);
              var n2 = this.lastTouches, o2 = function() {
                var e3 = n2.indexOf(i2);
                e3 > -1 && n2.splice(e3, 1);
              };
              setTimeout(o2, tt);
            }
          }
          function Z(e2) {
            for (var t2 = e2.srcEvent.clientX, i2 = e2.srcEvent.clientY, n2 = 0; n2 < this.lastTouches.length; n2++) {
              var o2 = this.lastTouches[n2], s2 = Math.abs(t2 - o2.x), r2 = Math.abs(i2 - o2.y);
              if (s2 <= it && r2 <= it)
                return true;
            }
            return false;
          }
          function $(e2, t2) {
            this.manager = e2, this.set(t2);
          }
          function Q(e2) {
            if (b(e2, at))
              return at;
            var t2 = b(e2, dt), i2 = b(e2, ht);
            return t2 && i2 ? at : t2 || i2 ? t2 ? dt : ht : b(e2, rt) ? rt : st;
          }
          function J(e2) {
            this.options = pe({}, this.defaults, e2 || {}), this.id = M(), this.manager = null, this.options.enable = v(this.options.enable, true), this.state = ut, this.simultaneous = {}, this.requireFail = [];
          }
          function ee(e2) {
            return e2 & gt ? "cancel" : e2 & pt ? "end" : e2 & ft ? "move" : e2 & ct ? "start" : "";
          }
          function te(e2) {
            return e2 == Re ? "down" : e2 == ze ? "up" : e2 == Ne ? "left" : e2 == Be ? "right" : "";
          }
          function ie(e2, t2) {
            var i2 = t2.manager;
            return i2 ? i2.get(e2) : e2;
          }
          function ne() {
            J.apply(this, arguments);
          }
          function oe() {
            ne.apply(this, arguments), this.pX = null, this.pY = null;
          }
          function se() {
            ne.apply(this, arguments);
          }
          function re() {
            J.apply(this, arguments), this._timer = null, this._input = null;
          }
          function ae() {
            ne.apply(this, arguments);
          }
          function de() {
            ne.apply(this, arguments);
          }
          function he() {
            J.apply(this, arguments), this.pTime = false, this.pCenter = false, this._timer = null, this._input = null, this.count = 0;
          }
          function le(e2, t2) {
            return t2 = t2 || {}, t2.recognizers = v(t2.recognizers, le.defaults.preset), new ue(e2, t2);
          }
          function ue(e2, t2) {
            this.options = pe({}, le.defaults, t2 || {}), this.options.inputTarget = this.options.inputTarget || e2, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = e2, this.input = D(this), this.touchAction = new $(this, this.options.touchAction), ce(this, true), l(this.options.recognizers, function(e3) {
              var t3 = this.add(new e3[0](e3[1]));
              e3[2] && t3.recognizeWith(e3[2]), e3[3] && t3.requireFailure(e3[3]);
            }, this);
          }
          function ce(e2, t2) {
            var i2 = e2.element;
            if (i2.style) {
              var n2;
              l(e2.options.cssProps, function(o2, s2) {
                n2 = O(i2.style, s2), t2 ? (e2.oldCssProps[n2] = i2.style[n2], i2.style[n2] = o2) : i2.style[n2] = e2.oldCssProps[n2] || "";
              }), t2 || (e2.oldCssProps = {});
            }
          }
          function fe(e2, t2) {
            var i2 = s.createEvent("Event");
            i2.initEvent(e2, true, true), i2.gesture = t2, t2.target.dispatchEvent(i2);
          }
          var pe, ve = ["", "webkit", "Moz", "MS", "ms", "o"], ge = s.createElement("div"), ye = "function", me = Math.round, be = Math.abs, _e = Date.now;
          pe = "function" != typeof Object.assign ? function(e2) {
            if (e2 === a || null === e2)
              throw new TypeError("Cannot convert undefined or null to object");
            for (var t2 = Object(e2), i2 = 1; i2 < arguments.length; i2++) {
              var n2 = arguments[i2];
              if (n2 !== a && null !== n2)
                for (var o2 in n2)
                  n2.hasOwnProperty(o2) && (t2[o2] = n2[o2]);
            }
            return t2;
          } : Object.assign;
          var we = u(function(e2, t2, i2) {
            for (var n2 = Object.keys(t2), o2 = 0; o2 < n2.length; )
              (!i2 || i2 && e2[n2[o2]] === a) && (e2[n2[o2]] = t2[n2[o2]]), o2++;
            return e2;
          }, "extend", "Use `assign`."), ke = u(function(e2, t2) {
            return we(e2, t2, true);
          }, "merge", "Use `assign`."), xe = 1, Oe = /mobile|tablet|ip(ad|hone|od)|android/i, Me = "ontouchstart" in o, Ee = O(o, "PointerEvent") !== a, Se = Me && Oe.test(navigator.userAgent), De = 25, Ce = 1, Te = 2, Pe = 4, Ie = 8, Fe = 1, Ne = 2, Be = 4, ze = 8, Re = 16, Ae = Ne | Be, je = ze | Re, Le = Ae | je, He = ["x", "y"], We = ["clientX", "clientY"];
          S.prototype = { handler: function() {
          }, init: function() {
            this.evEl && g(this.element, this.evEl, this.domHandler), this.evTarget && g(this.target, this.evTarget, this.domHandler), this.evWin && g(E(this.element), this.evWin, this.domHandler);
          }, destroy: function() {
            this.evEl && y(this.element, this.evEl, this.domHandler), this.evTarget && y(this.target, this.evTarget, this.domHandler), this.evWin && y(E(this.element), this.evWin, this.domHandler);
          } };
          var Ye = { mousedown: Ce, mousemove: Te, mouseup: Pe }, Ve = "mousedown", Ue = "mousemove mouseup";
          c(H, S, { handler: function(e2) {
            var t2 = Ye[e2.type];
            t2 & Ce && 0 === e2.button && (this.pressed = true), t2 & Te && 1 !== e2.which && (t2 = Pe), this.pressed && (t2 & Pe && (this.pressed = false), this.callback(this.manager, t2, { pointers: [e2], changedPointers: [e2], pointerType: "mouse", srcEvent: e2 }));
          } });
          var qe = { pointerdown: Ce, pointermove: Te, pointerup: Pe, pointercancel: Ie, pointerout: Ie }, Ge = { 2: "touch", 3: "pen", 4: "mouse", 5: "kinect" }, Xe = "pointerdown", Ke = "pointermove pointerup pointercancel";
          o.MSPointerEvent && !o.PointerEvent && (Xe = "MSPointerDown", Ke = "MSPointerMove MSPointerUp MSPointerCancel"), c(W, S, { handler: function(e2) {
            var t2 = this.store, i2 = false, n2 = e2.type.toLowerCase().replace("ms", ""), o2 = qe[n2], s2 = Ge[e2.pointerType] || e2.pointerType, r2 = "touch" == s2, a2 = w(t2, e2.pointerId, "pointerId");
            o2 & Ce && (0 === e2.button || r2) ? a2 < 0 && (t2.push(e2), a2 = t2.length - 1) : o2 & (Pe | Ie) && (i2 = true), a2 < 0 || (t2[a2] = e2, this.callback(this.manager, o2, { pointers: t2, changedPointers: [e2], pointerType: s2, srcEvent: e2 }), i2 && t2.splice(a2, 1));
          } });
          var Ze = { touchstart: Ce, touchmove: Te, touchend: Pe, touchcancel: Ie }, $e = "touchstart", Qe = "touchstart touchmove touchend touchcancel";
          c(Y, S, { handler: function(e2) {
            var t2 = Ze[e2.type];
            if (t2 === Ce && (this.started = true), this.started) {
              var i2 = V.call(this, e2, t2);
              t2 & (Pe | Ie) && i2[0].length - i2[1].length == 0 && (this.started = false), this.callback(this.manager, t2, { pointers: i2[0], changedPointers: i2[1], pointerType: "touch", srcEvent: e2 });
            }
          } });
          var Je = { touchstart: Ce, touchmove: Te, touchend: Pe, touchcancel: Ie }, et = "touchstart touchmove touchend touchcancel";
          c(U, S, { handler: function(e2) {
            var t2 = Je[e2.type], i2 = q.call(this, e2, t2);
            i2 && this.callback(this.manager, t2, { pointers: i2[0], changedPointers: i2[1], pointerType: "touch", srcEvent: e2 });
          } });
          var tt = 2500, it = 25;
          c(G, S, { handler: function(e2, t2, i2) {
            var n2 = "touch" == i2.pointerType, o2 = "mouse" == i2.pointerType;
            if (!(o2 && i2.sourceCapabilities && i2.sourceCapabilities.firesTouchEvents)) {
              if (n2)
                X.call(this, t2, i2);
              else if (o2 && Z.call(this, i2))
                return;
              this.callback(e2, t2, i2);
            }
          }, destroy: function() {
            this.touch.destroy(), this.mouse.destroy();
          } });
          var nt = O(ge.style, "touchAction"), ot = nt !== a, st = "auto", rt = "manipulation", at = "none", dt = "pan-x", ht = "pan-y", lt = function() {
            if (!ot)
              return false;
            var e2 = {}, t2 = o.CSS && o.CSS.supports;
            return ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function(i2) {
              e2[i2] = !t2 || o.CSS.supports("touch-action", i2);
            }), e2;
          }();
          $.prototype = { set: function(e2) {
            "compute" == e2 && (e2 = this.compute()), ot && this.manager.element.style && lt[e2] && (this.manager.element.style[nt] = e2), this.actions = e2.toLowerCase().trim();
          }, update: function() {
            this.set(this.manager.options.touchAction);
          }, compute: function() {
            var e2 = [];
            return l(this.manager.recognizers, function(t2) {
              p(t2.options.enable, [t2]) && (e2 = e2.concat(t2.getTouchAction()));
            }), Q(e2.join(" "));
          }, preventDefaults: function(e2) {
            var t2 = e2.srcEvent, i2 = e2.offsetDirection;
            if (this.manager.session.prevented)
              return void t2.preventDefault();
            var n2 = this.actions, o2 = b(n2, at) && !lt[at], s2 = b(n2, ht) && !lt[ht], r2 = b(n2, dt) && !lt[dt];
            if (o2) {
              var a2 = 1 === e2.pointers.length, d2 = e2.distance < 2, h2 = e2.deltaTime < 250;
              if (a2 && d2 && h2)
                return;
            }
            return r2 && s2 ? void 0 : o2 || s2 && i2 & Ae || r2 && i2 & je ? this.preventSrc(t2) : void 0;
          }, preventSrc: function(e2) {
            this.manager.session.prevented = true, e2.preventDefault();
          } };
          var ut = 1, ct = 2, ft = 4, pt = 8, vt = pt, gt = 16;
          J.prototype = { defaults: {}, set: function(e2) {
            return pe(this.options, e2), this.manager && this.manager.touchAction.update(), this;
          }, recognizeWith: function(e2) {
            if (h(e2, "recognizeWith", this))
              return this;
            var t2 = this.simultaneous;
            return e2 = ie(e2, this), t2[e2.id] || (t2[e2.id] = e2, e2.recognizeWith(this)), this;
          }, dropRecognizeWith: function(e2) {
            return h(e2, "dropRecognizeWith", this) ? this : (e2 = ie(e2, this), delete this.simultaneous[e2.id], this);
          }, requireFailure: function(e2) {
            if (h(e2, "requireFailure", this))
              return this;
            var t2 = this.requireFail;
            return e2 = ie(e2, this), -1 === w(t2, e2) && (t2.push(e2), e2.requireFailure(this)), this;
          }, dropRequireFailure: function(e2) {
            if (h(e2, "dropRequireFailure", this))
              return this;
            e2 = ie(e2, this);
            var t2 = w(this.requireFail, e2);
            return t2 > -1 && this.requireFail.splice(t2, 1), this;
          }, hasRequireFailures: function() {
            return this.requireFail.length > 0;
          }, canRecognizeWith: function(e2) {
            return !!this.simultaneous[e2.id];
          }, emit: function(e2) {
            function t2(t3) {
              i2.manager.emit(t3, e2);
            }
            var i2 = this, n2 = this.state;
            n2 < pt && t2(i2.options.event + ee(n2)), t2(i2.options.event), e2.additionalEvent && t2(e2.additionalEvent), n2 >= pt && t2(i2.options.event + ee(n2));
          }, tryEmit: function(e2) {
            if (this.canEmit())
              return this.emit(e2);
            this.state = 32;
          }, canEmit: function() {
            for (var e2 = 0; e2 < this.requireFail.length; ) {
              if (!(this.requireFail[e2].state & (32 | ut)))
                return false;
              e2++;
            }
            return true;
          }, recognize: function(e2) {
            var t2 = pe({}, e2);
            if (!p(this.options.enable, [this, t2]))
              return this.reset(), void (this.state = 32);
            this.state & (vt | gt | 32) && (this.state = ut), this.state = this.process(t2), this.state & (ct | ft | pt | gt) && this.tryEmit(t2);
          }, process: function(e2) {
          }, getTouchAction: function() {
          }, reset: function() {
          } }, c(ne, J, { defaults: { pointers: 1 }, attrTest: function(e2) {
            var t2 = this.options.pointers;
            return 0 === t2 || e2.pointers.length === t2;
          }, process: function(e2) {
            var t2 = this.state, i2 = e2.eventType, n2 = t2 & (ct | ft), o2 = this.attrTest(e2);
            return n2 && (i2 & Ie || !o2) ? t2 | gt : n2 || o2 ? i2 & Pe ? t2 | pt : t2 & ct ? t2 | ft : ct : 32;
          } }), c(oe, ne, { defaults: { event: "pan", threshold: 10, pointers: 1, direction: Le }, getTouchAction: function() {
            var e2 = this.options.direction, t2 = [];
            return e2 & Ae && t2.push(ht), e2 & je && t2.push(dt), t2;
          }, directionTest: function(e2) {
            var t2 = this.options, i2 = true, n2 = e2.distance, o2 = e2.direction, s2 = e2.deltaX, r2 = e2.deltaY;
            return o2 & t2.direction || (t2.direction & Ae ? (o2 = 0 === s2 ? Fe : s2 < 0 ? Ne : Be, i2 = s2 != this.pX, n2 = Math.abs(e2.deltaX)) : (o2 = 0 === r2 ? Fe : r2 < 0 ? ze : Re, i2 = r2 != this.pY, n2 = Math.abs(e2.deltaY))), e2.direction = o2, i2 && n2 > t2.threshold && o2 & t2.direction;
          }, attrTest: function(e2) {
            return ne.prototype.attrTest.call(this, e2) && (this.state & ct || !(this.state & ct) && this.directionTest(e2));
          }, emit: function(e2) {
            this.pX = e2.deltaX, this.pY = e2.deltaY;
            var t2 = te(e2.direction);
            t2 && (e2.additionalEvent = this.options.event + t2), this._super.emit.call(this, e2);
          } }), c(se, ne, { defaults: { event: "pinch", threshold: 0, pointers: 2 }, getTouchAction: function() {
            return [at];
          }, attrTest: function(e2) {
            return this._super.attrTest.call(this, e2) && (Math.abs(e2.scale - 1) > this.options.threshold || this.state & ct);
          }, emit: function(e2) {
            if (1 !== e2.scale) {
              var t2 = e2.scale < 1 ? "in" : "out";
              e2.additionalEvent = this.options.event + t2;
            }
            this._super.emit.call(this, e2);
          } }), c(re, J, { defaults: { event: "press", pointers: 1, time: 251, threshold: 9 }, getTouchAction: function() {
            return [st];
          }, process: function(e2) {
            var t2 = this.options, i2 = e2.pointers.length === t2.pointers, n2 = e2.distance < t2.threshold, o2 = e2.deltaTime > t2.time;
            if (this._input = e2, !n2 || !i2 || e2.eventType & (Pe | Ie) && !o2)
              this.reset();
            else if (e2.eventType & Ce)
              this.reset(), this._timer = d(function() {
                this.state = vt, this.tryEmit();
              }, t2.time, this);
            else if (e2.eventType & Pe)
              return vt;
            return 32;
          }, reset: function() {
            clearTimeout(this._timer);
          }, emit: function(e2) {
            this.state === vt && (e2 && e2.eventType & Pe ? this.manager.emit(this.options.event + "up", e2) : (this._input.timeStamp = _e(), this.manager.emit(this.options.event, this._input)));
          } }), c(ae, ne, { defaults: { event: "rotate", threshold: 0, pointers: 2 }, getTouchAction: function() {
            return [at];
          }, attrTest: function(e2) {
            return this._super.attrTest.call(this, e2) && (Math.abs(e2.rotation) > this.options.threshold || this.state & ct);
          } }), c(de, ne, { defaults: { event: "swipe", threshold: 10, velocity: 0.3, direction: Ae | je, pointers: 1 }, getTouchAction: function() {
            return oe.prototype.getTouchAction.call(this);
          }, attrTest: function(e2) {
            var t2, i2 = this.options.direction;
            return i2 & (Ae | je) ? t2 = e2.overallVelocity : i2 & Ae ? t2 = e2.overallVelocityX : i2 & je && (t2 = e2.overallVelocityY), this._super.attrTest.call(this, e2) && i2 & e2.offsetDirection && e2.distance > this.options.threshold && e2.maxPointers == this.options.pointers && be(t2) > this.options.velocity && e2.eventType & Pe;
          }, emit: function(e2) {
            var t2 = te(e2.offsetDirection);
            t2 && this.manager.emit(this.options.event + t2, e2), this.manager.emit(this.options.event, e2);
          } }), c(he, J, { defaults: { event: "tap", pointers: 1, taps: 1, interval: 300, time: 250, threshold: 9, posThreshold: 10 }, getTouchAction: function() {
            return [rt];
          }, process: function(e2) {
            var t2 = this.options, i2 = e2.pointers.length === t2.pointers, n2 = e2.distance < t2.threshold, o2 = e2.deltaTime < t2.time;
            if (this.reset(), e2.eventType & Ce && 0 === this.count)
              return this.failTimeout();
            if (n2 && o2 && i2) {
              if (e2.eventType != Pe)
                return this.failTimeout();
              var s2 = !this.pTime || e2.timeStamp - this.pTime < t2.interval, r2 = !this.pCenter || R(this.pCenter, e2.center) < t2.posThreshold;
              this.pTime = e2.timeStamp, this.pCenter = e2.center, r2 && s2 ? this.count += 1 : this.count = 1, this._input = e2;
              if (0 === this.count % t2.taps)
                return this.hasRequireFailures() ? (this._timer = d(function() {
                  this.state = vt, this.tryEmit();
                }, t2.interval, this), ct) : vt;
            }
            return 32;
          }, failTimeout: function() {
            return this._timer = d(function() {
              this.state = 32;
            }, this.options.interval, this), 32;
          }, reset: function() {
            clearTimeout(this._timer);
          }, emit: function() {
            this.state == vt && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input));
          } }), le.VERSION = "2.0.7", le.defaults = { domEvents: false, touchAction: "compute", enable: true, inputTarget: null, inputClass: null, preset: [[ae, { enable: false }], [se, { enable: false }, ["rotate"]], [de, { direction: Ae }], [oe, { direction: Ae }, ["swipe"]], [he], [he, { event: "doubletap", taps: 2 }, ["tap"]], [re]], cssProps: { userSelect: "none", touchSelect: "none", touchCallout: "none", contentZooming: "none", userDrag: "none", tapHighlightColor: "rgba(0,0,0,0)" } };
          ue.prototype = { set: function(e2) {
            return pe(this.options, e2), e2.touchAction && this.touchAction.update(), e2.inputTarget && (this.input.destroy(), this.input.target = e2.inputTarget, this.input.init()), this;
          }, stop: function(e2) {
            this.session.stopped = e2 ? 2 : 1;
          }, recognize: function(e2) {
            var t2 = this.session;
            if (!t2.stopped) {
              this.touchAction.preventDefaults(e2);
              var i2, n2 = this.recognizers, o2 = t2.curRecognizer;
              (!o2 || o2 && o2.state & vt) && (o2 = t2.curRecognizer = null);
              for (var s2 = 0; s2 < n2.length; )
                i2 = n2[s2], 2 === t2.stopped || o2 && i2 != o2 && !i2.canRecognizeWith(o2) ? i2.reset() : i2.recognize(e2), !o2 && i2.state & (ct | ft | pt) && (o2 = t2.curRecognizer = i2), s2++;
            }
          }, get: function(e2) {
            if (e2 instanceof J)
              return e2;
            for (var t2 = this.recognizers, i2 = 0; i2 < t2.length; i2++)
              if (t2[i2].options.event == e2)
                return t2[i2];
            return null;
          }, add: function(e2) {
            if (h(e2, "add", this))
              return this;
            var t2 = this.get(e2.options.event);
            return t2 && this.remove(t2), this.recognizers.push(e2), e2.manager = this, this.touchAction.update(), e2;
          }, remove: function(e2) {
            if (h(e2, "remove", this))
              return this;
            if (e2 = this.get(e2)) {
              var t2 = this.recognizers, i2 = w(t2, e2);
              -1 !== i2 && (t2.splice(i2, 1), this.touchAction.update());
            }
            return this;
          }, on: function(e2, t2) {
            if (e2 !== a && t2 !== a) {
              var i2 = this.handlers;
              return l(_(e2), function(e3) {
                i2[e3] = i2[e3] || [], i2[e3].push(t2);
              }), this;
            }
          }, off: function(e2, t2) {
            if (e2 !== a) {
              var i2 = this.handlers;
              return l(_(e2), function(e3) {
                t2 ? i2[e3] && i2[e3].splice(w(i2[e3], t2), 1) : delete i2[e3];
              }), this;
            }
          }, emit: function(e2, t2) {
            this.options.domEvents && fe(e2, t2);
            var i2 = this.handlers[e2] && this.handlers[e2].slice();
            if (i2 && i2.length) {
              t2.type = e2, t2.preventDefault = function() {
                t2.srcEvent.preventDefault();
              };
              for (var n2 = 0; n2 < i2.length; )
                i2[n2](t2), n2++;
            }
          }, destroy: function() {
            this.element && ce(this, false), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null;
          } }, pe(le, { INPUT_START: Ce, INPUT_MOVE: Te, INPUT_END: Pe, INPUT_CANCEL: Ie, STATE_POSSIBLE: ut, STATE_BEGAN: ct, STATE_CHANGED: ft, STATE_ENDED: pt, STATE_RECOGNIZED: vt, STATE_CANCELLED: gt, STATE_FAILED: 32, DIRECTION_NONE: Fe, DIRECTION_LEFT: Ne, DIRECTION_RIGHT: Be, DIRECTION_UP: ze, DIRECTION_DOWN: Re, DIRECTION_HORIZONTAL: Ae, DIRECTION_VERTICAL: je, DIRECTION_ALL: Le, Manager: ue, Input: S, TouchAction: $, TouchInput: U, MouseInput: H, PointerEventInput: W, TouchMouseInput: G, SingleTouchInput: Y, Recognizer: J, AttrRecognizer: ne, Tap: he, Pan: oe, Swipe: de, Pinch: se, Rotate: ae, Press: re, on: g, off: y, each: l, merge: ke, extend: we, assign: pe, inherit: c, bindFn: f, prefixed: O }), (void 0 !== o ? o : "undefined" != typeof self ? self : {}).Hammer = le, (n = function() {
            return le;
          }.call(t, i, t, e)) !== a && (e.exports = n);
        }(window, document);
      }, function(e, t, i) {
        t.en = { edit: "Edit", del: "Delete selected", back: "Back", addNode: "Add Node", addEdge: "Add Edge", editNode: "Edit Node", editEdge: "Edit Edge", addDescription: "Click in an empty space to place a new node.", edgeDescription: "Click on a node and drag the edge to another node to connect them.", editEdgeDescription: "Click on the control points and drag them to a node to connect to it.", createEdgeError: "Cannot link edges to a cluster.", deleteClusterError: "Clusters cannot be deleted.", editClusterError: "Clusters cannot be edited." }, t.en_EN = t.en, t.en_US = t.en, t.de = { edit: "Editieren", del: "Lsche Auswahl", back: "Zurck", addNode: "Knoten hinzufgen", addEdge: "Kante hinzufgen", editNode: "Knoten editieren", editEdge: "Kante editieren", addDescription: "Klicke auf eine freie Stelle, um einen neuen Knoten zu plazieren.", edgeDescription: "Klicke auf einen Knoten und ziehe die Kante zu einem anderen Knoten, um diese zu verbinden.", editEdgeDescription: "Klicke auf die Verbindungspunkte und ziehe diese auf einen Knoten, um sie zu verbinden.", createEdgeError: "Es ist nicht mglich, Kanten mit Clustern zu verbinden.", deleteClusterError: "Cluster knnen nicht gelscht werden.", editClusterError: "Cluster knnen nicht editiert werden." }, t.de_DE = t.de, t.es = { edit: "Editar", del: "Eliminar seleccin", back: "tras", addNode: "Aadir nodo", addEdge: "Aadir arista", editNode: "Editar nodo", editEdge: "Editar arista", addDescription: "Haga clic en un lugar vaco para colocar un nuevo nodo.", edgeDescription: "Haga clic en un nodo y arrastre la arista hacia otro nodo para conectarlos.", editEdgeDescription: "Haga clic en un punto de control y arrastrelo a un nodo para conectarlo.", createEdgeError: "No se puede conectar una arista a un grupo.", deleteClusterError: "No es posible eliminar grupos.", editClusterError: "No es posible editar grupos." }, t.es_ES = t.es, t.it = { edit: "Modifica", del: "Cancella la selezione", back: "Indietro", addNode: "Aggiungi un nodo", addEdge: "Aggiungi un vertice", editNode: "Modifica il nodo", editEdge: "Modifica il vertice", addDescription: "Clicca per aggiungere un nuovo nodo", edgeDescription: "Clicca su un nodo e trascinalo ad un altro nodo per connetterli.", editEdgeDescription: "Clicca sui Punti di controllo e trascinali ad un nodo per connetterli.", createEdgeError: "Non si possono collegare vertici ad un cluster", deleteClusterError: "I cluster non possono essere cancellati", editClusterError: "I clusters non possono essere modificati." }, t.it_IT = t.it, t.nl = { edit: "Wijzigen", del: "Selectie verwijderen", back: "Terug", addNode: "Node toevoegen", addEdge: "Link toevoegen", editNode: "Node wijzigen", editEdge: "Link wijzigen", addDescription: "Klik op een leeg gebied om een nieuwe node te maken.", edgeDescription: "Klik op een node en sleep de link naar een andere node om ze te verbinden.", editEdgeDescription: "Klik op de verbindingspunten en sleep ze naar een node om daarmee te verbinden.", createEdgeError: "Kan geen link maken naar een cluster.", deleteClusterError: "Clusters kunnen niet worden verwijderd.", editClusterError: "Clusters kunnen niet worden aangepast." }, t.nl_NL = t.nl, t.nl_BE = t.nl, t["pt-br"] = { edit: "Editar", del: "Remover selecionado", back: "Voltar", addNode: "Adicionar n", addEdge: "Adicionar aresta", editNode: "Editar n", editEdge: "Editar aresta", addDescription: "Clique em um espao em branco para adicionar um novo n", edgeDescription: "Clique em um n e arraste a aresta at outro n para conect-los", editEdgeDescription: "Clique nos pontos de controle e os arraste para um n para conect-los", createEdgeError: "No foi possvel linkar arestas a um cluster.", deleteClusterError: "Clusters no puderam ser removidos.", editClusterError: "Clusters no puderam ser editados." }, t["pt-BR"] = t["pt-br"], t.pt_BR = t["pt-br"], t.pt_br = t["pt-br"], t.ru = { edit: "", del: " ", back: "", addNode: " ", addEdge: " ", editNode: " ", editEdge: " ", addDescription: "   ,    .", edgeDescription: "        ,   .", editEdgeDescription: "        ,    .", createEdgeError: "    .", deleteClusterError: "    ", editClusterError: "   ." }, t.ru_RU = t.ru, t.cn = { edit: "", del: "", back: "", addNode: "", addEdge: "", editNode: "", editEdge: "", addDescription: "", edgeDescription: "", editEdgeDescription: "", createEdgeError: "", deleteClusterError: "", editClusterError: "" }, t.zh_CN = t.cn;
      }, function(e, t, i) {
        e.exports = { default: i(128), __esModule: true };
      }, function(e, t, i) {
        i(129);
        var n = i(6).Object;
        e.exports = function(e2, t2, i2) {
          return n.defineProperty(e2, t2, i2);
        };
      }, function(e, t, i) {
        var n = i(11);
        n(n.S + n.F * !i(13), "Object", { defineProperty: i(12).f });
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(0), s = n(o), r = i(1), a = n(r), d = function() {
          function e2() {
            (0, s.default)(this, e2), this.NUM_ITERATIONS = 4, this.image = new Image(), this.canvas = document.createElement("canvas");
          }
          return (0, a.default)(e2, [{ key: "init", value: function() {
            if (!this.initialized()) {
              this.src = this.image.src;
              var e3 = this.image.width, t2 = this.image.height;
              this.width = e3, this.height = t2;
              var i2 = Math.floor(t2 / 2), n2 = Math.floor(t2 / 4), o2 = Math.floor(t2 / 8), s2 = Math.floor(t2 / 16), r2 = Math.floor(e3 / 2), a2 = Math.floor(e3 / 4), d2 = Math.floor(e3 / 8), h = Math.floor(e3 / 16);
              this.canvas.width = 3 * a2, this.canvas.height = i2, this.coordinates = [[0, 0, r2, i2], [r2, 0, a2, n2], [r2, n2, d2, o2], [5 * d2, n2, h, s2]], this._fillMipMap();
            }
          } }, { key: "initialized", value: function() {
            return void 0 !== this.coordinates;
          } }, { key: "_fillMipMap", value: function() {
            var e3 = this.canvas.getContext("2d"), t2 = this.coordinates[0];
            e3.drawImage(this.image, t2[0], t2[1], t2[2], t2[3]);
            for (var i2 = 1; i2 < this.NUM_ITERATIONS; i2++) {
              var n2 = this.coordinates[i2 - 1], o2 = this.coordinates[i2];
              e3.drawImage(this.canvas, n2[0], n2[1], n2[2], n2[3], o2[0], o2[1], o2[2], o2[3]);
            }
          } }, { key: "drawImageAtPosition", value: function(e3, t2, i2, n2, o2, s2) {
            if (this.initialized())
              if (t2 > 2) {
                t2 *= 0.5;
                for (var r2 = 0; t2 > 2 && r2 < this.NUM_ITERATIONS; )
                  t2 *= 0.5, r2 += 1;
                r2 >= this.NUM_ITERATIONS && (r2 = this.NUM_ITERATIONS - 1);
                var a2 = this.coordinates[r2];
                e3.drawImage(this.canvas, a2[0], a2[1], a2[2], a2[3], i2, n2, o2, s2);
              } else
                e3.drawImage(this.image, i2, n2, o2, s2);
          } }]), e2;
        }();
        t.default = d;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(0), s = n(o), r = i(1), a = n(r), d = i(5), h = function() {
          function e2() {
            (0, s.default)(this, e2), this.clear(), this.defaultIndex = 0, this.groupsArray = [], this.groupIndex = 0, this.defaultGroups = [{ border: "#2B7CE9", background: "#97C2FC", highlight: { border: "#2B7CE9", background: "#D2E5FF" }, hover: { border: "#2B7CE9", background: "#D2E5FF" } }, { border: "#FFA500", background: "#FFFF00", highlight: { border: "#FFA500", background: "#FFFFA3" }, hover: { border: "#FFA500", background: "#FFFFA3" } }, { border: "#FA0A10", background: "#FB7E81", highlight: { border: "#FA0A10", background: "#FFAFB1" }, hover: { border: "#FA0A10", background: "#FFAFB1" } }, { border: "#41A906", background: "#7BE141", highlight: { border: "#41A906", background: "#A1EC76" }, hover: { border: "#41A906", background: "#A1EC76" } }, { border: "#E129F0", background: "#EB7DF4", highlight: { border: "#E129F0", background: "#F0B3F5" }, hover: { border: "#E129F0", background: "#F0B3F5" } }, { border: "#7C29F0", background: "#AD85E4", highlight: { border: "#7C29F0", background: "#D3BDF0" }, hover: { border: "#7C29F0", background: "#D3BDF0" } }, { border: "#C37F00", background: "#FFA807", highlight: { border: "#C37F00", background: "#FFCA66" }, hover: { border: "#C37F00", background: "#FFCA66" } }, { border: "#4220FB", background: "#6E6EFD", highlight: { border: "#4220FB", background: "#9B9BFD" }, hover: { border: "#4220FB", background: "#9B9BFD" } }, { border: "#FD5A77", background: "#FFC0CB", highlight: { border: "#FD5A77", background: "#FFD1D9" }, hover: { border: "#FD5A77", background: "#FFD1D9" } }, { border: "#4AD63A", background: "#C2FABC", highlight: { border: "#4AD63A", background: "#E6FFE3" }, hover: { border: "#4AD63A", background: "#E6FFE3" } }, { border: "#990000", background: "#EE0000", highlight: { border: "#BB0000", background: "#FF3333" }, hover: { border: "#BB0000", background: "#FF3333" } }, { border: "#FF6000", background: "#FF6000", highlight: { border: "#FF6000", background: "#FF6000" }, hover: { border: "#FF6000", background: "#FF6000" } }, { border: "#97C2FC", background: "#2B7CE9", highlight: { border: "#D2E5FF", background: "#2B7CE9" }, hover: { border: "#D2E5FF", background: "#2B7CE9" } }, { border: "#399605", background: "#255C03", highlight: { border: "#399605", background: "#255C03" }, hover: { border: "#399605", background: "#255C03" } }, { border: "#B70054", background: "#FF007E", highlight: { border: "#B70054", background: "#FF007E" }, hover: { border: "#B70054", background: "#FF007E" } }, { border: "#AD85E4", background: "#7C29F0", highlight: { border: "#D3BDF0", background: "#7C29F0" }, hover: { border: "#D3BDF0", background: "#7C29F0" } }, { border: "#4557FA", background: "#000EA1", highlight: { border: "#6E6EFD", background: "#000EA1" }, hover: { border: "#6E6EFD", background: "#000EA1" } }, { border: "#FFC0CB", background: "#FD5A77", highlight: { border: "#FFD1D9", background: "#FD5A77" }, hover: { border: "#FFD1D9", background: "#FD5A77" } }, { border: "#C2FABC", background: "#74D66A", highlight: { border: "#E6FFE3", background: "#74D66A" }, hover: { border: "#E6FFE3", background: "#74D66A" } }, { border: "#EE0000", background: "#990000", highlight: { border: "#FF3333", background: "#BB0000" }, hover: { border: "#FF3333", background: "#BB0000" } }], this.options = {}, this.defaultOptions = { useDefaultGroups: true }, d.extend(this.options, this.defaultOptions);
          }
          return (0, a.default)(e2, [{ key: "setOptions", value: function(e3) {
            var t2 = ["useDefaultGroups"];
            if (void 0 !== e3) {
              for (var i2 in e3)
                if (e3.hasOwnProperty(i2) && -1 === t2.indexOf(i2)) {
                  var n2 = e3[i2];
                  this.add(i2, n2);
                }
            }
          } }, { key: "clear", value: function() {
            this.groups = {}, this.groupsArray = [];
          } }, { key: "get", value: function(e3) {
            var t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i2 = this.groups[e3];
            if (void 0 === i2 && t2)
              if (false === this.options.useDefaultGroups && this.groupsArray.length > 0) {
                var n2 = this.groupIndex % this.groupsArray.length;
                this.groupIndex++, i2 = {}, i2.color = this.groups[this.groupsArray[n2]], this.groups[e3] = i2;
              } else {
                var o2 = this.defaultIndex % this.defaultGroups.length;
                this.defaultIndex++, i2 = {}, i2.color = this.defaultGroups[o2], this.groups[e3] = i2;
              }
            return i2;
          } }, { key: "add", value: function(e3, t2) {
            return this.groups[e3] = t2, this.groupsArray.push(e3), t2;
          } }]), e2;
        }();
        t.default = h;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(0), s = n(o), r = i(1), a = n(r), d = i(5), h = i(32), l = i(51), u = i(33).default, c = function() {
          function e2(t2, i2, n2, o2) {
            var r2 = this;
            if ((0, s.default)(this, e2), this.body = t2, this.images = i2, this.groups = n2, this.layoutEngine = o2, this.body.functions.createNode = this.create.bind(this), this.nodesListeners = { add: function(e3, t3) {
              r2.add(t3.items);
            }, update: function(e3, t3) {
              r2.update(t3.items, t3.data, t3.oldData);
            }, remove: function(e3, t3) {
              r2.remove(t3.items);
            } }, this.defaultOptions = { borderWidth: 1, borderWidthSelected: 2, brokenImage: void 0, color: { border: "#2B7CE9", background: "#97C2FC", highlight: { border: "#2B7CE9", background: "#D2E5FF" }, hover: { border: "#2B7CE9", background: "#D2E5FF" } }, fixed: { x: false, y: false }, font: { color: "#343434", size: 14, face: "arial", background: "none", strokeWidth: 0, strokeColor: "#ffffff", align: "center", vadjust: 0, multi: false, bold: { mod: "bold" }, boldital: { mod: "bold italic" }, ital: { mod: "italic" }, mono: { mod: "", size: 15, face: "monospace", vadjust: 2 } }, group: void 0, hidden: false, icon: { face: "FontAwesome", code: void 0, size: 50, color: "#2B7CE9" }, image: void 0, label: void 0, labelHighlightBold: true, level: void 0, margin: { top: 5, right: 5, bottom: 5, left: 5 }, mass: 1, physics: true, scaling: { min: 10, max: 30, label: { enabled: false, min: 14, max: 30, maxVisible: 30, drawThreshold: 5 }, customScalingFunction: function(e3, t3, i3, n3) {
              if (t3 === e3)
                return 0.5;
              var o3 = 1 / (t3 - e3);
              return Math.max(0, (n3 - e3) * o3);
            } }, shadow: { enabled: false, color: "rgba(0,0,0,0.5)", size: 10, x: 5, y: 5 }, shape: "ellipse", shapeProperties: { borderDashes: false, borderRadius: 6, interpolation: true, useImageSize: false, useBorderWithImage: false }, size: 25, title: void 0, value: void 0, x: void 0, y: void 0 }, this.defaultOptions.mass <= 0)
              throw "Internal error: mass in defaultOptions of NodesHandler may not be zero or negative";
            this.options = d.bridgeObject(this.defaultOptions), this.bindEventListeners();
          }
          return (0, a.default)(e2, [{ key: "bindEventListeners", value: function() {
            var e3 = this;
            this.body.emitter.on("refreshNodes", this.refresh.bind(this)), this.body.emitter.on("refresh", this.refresh.bind(this)), this.body.emitter.on("destroy", function() {
              d.forEach(e3.nodesListeners, function(t2, i2) {
                e3.body.data.nodes && e3.body.data.nodes.off(i2, t2);
              }), delete e3.body.functions.createNode, delete e3.nodesListeners.add, delete e3.nodesListeners.update, delete e3.nodesListeners.remove, delete e3.nodesListeners;
            });
          } }, { key: "setOptions", value: function(e3) {
            if (void 0 !== e3) {
              if (u.parseOptions(this.options, e3), void 0 !== e3.shape)
                for (var t2 in this.body.nodes)
                  this.body.nodes.hasOwnProperty(t2) && this.body.nodes[t2].updateShape();
              if (void 0 !== e3.font)
                for (var i2 in this.body.nodes)
                  this.body.nodes.hasOwnProperty(i2) && (this.body.nodes[i2].updateLabelModule(), this.body.nodes[i2].needsRefresh());
              if (void 0 !== e3.size)
                for (var n2 in this.body.nodes)
                  this.body.nodes.hasOwnProperty(n2) && this.body.nodes[n2].needsRefresh();
              void 0 === e3.hidden && void 0 === e3.physics || this.body.emitter.emit("_dataChanged");
            }
          } }, { key: "setData", value: function(e3) {
            var t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], i2 = this.body.data.nodes;
            if (e3 instanceof h || e3 instanceof l)
              this.body.data.nodes = e3;
            else if (Array.isArray(e3))
              this.body.data.nodes = new h(), this.body.data.nodes.add(e3);
            else {
              if (e3)
                throw new TypeError("Array or DataSet expected");
              this.body.data.nodes = new h();
            }
            if (i2 && d.forEach(this.nodesListeners, function(e4, t3) {
              i2.off(t3, e4);
            }), this.body.nodes = {}, this.body.data.nodes) {
              var n2 = this;
              d.forEach(this.nodesListeners, function(e4, t3) {
                n2.body.data.nodes.on(t3, e4);
              });
              var o2 = this.body.data.nodes.getIds();
              this.add(o2, true);
            }
            false === t2 && this.body.emitter.emit("_dataChanged");
          } }, { key: "add", value: function(e3) {
            for (var t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], i2 = void 0, n2 = [], o2 = 0; o2 < e3.length; o2++) {
              i2 = e3[o2];
              var s2 = this.body.data.nodes.get(i2), r2 = this.create(s2);
              n2.push(r2), this.body.nodes[i2] = r2;
            }
            this.layoutEngine.positionInitially(n2), false === t2 && this.body.emitter.emit("_dataChanged");
          } }, { key: "update", value: function(e3, t2, i2) {
            for (var n2 = this.body.nodes, o2 = false, s2 = 0; s2 < e3.length; s2++) {
              var r2 = e3[s2], a2 = n2[r2], d2 = t2[s2];
              void 0 !== a2 ? a2.setOptions(d2) && (o2 = true) : (o2 = true, a2 = this.create(d2), n2[r2] = a2);
            }
            o2 || void 0 === i2 || (o2 = t2.some(function(e4, t3) {
              var n3 = i2[t3];
              return n3 && n3.level !== e4.level;
            })), true === o2 ? this.body.emitter.emit("_dataChanged") : this.body.emitter.emit("_dataUpdated");
          } }, { key: "remove", value: function(e3) {
            for (var t2 = this.body.nodes, i2 = 0; i2 < e3.length; i2++) {
              delete t2[e3[i2]];
            }
            this.body.emitter.emit("_dataChanged");
          } }, { key: "create", value: function(e3) {
            return new (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : u)(e3, this.body, this.images, this.groups, this.options, this.defaultOptions);
          } }, { key: "refresh", value: function() {
            var e3 = this, t2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            d.forEach(this.body.nodes, function(i2, n2) {
              var o2 = e3.body.data.nodes.get(n2);
              void 0 !== o2 && (true === t2 && i2.setOptions({ x: null, y: null }), i2.setOptions({ fixed: false }), i2.setOptions(o2));
            });
          } }, { key: "getPositions", value: function(e3) {
            var t2 = {};
            if (void 0 !== e3) {
              if (true === Array.isArray(e3)) {
                for (var i2 = 0; i2 < e3.length; i2++)
                  if (void 0 !== this.body.nodes[e3[i2]]) {
                    var n2 = this.body.nodes[e3[i2]];
                    t2[e3[i2]] = { x: Math.round(n2.x), y: Math.round(n2.y) };
                  }
              } else if (void 0 !== this.body.nodes[e3]) {
                var o2 = this.body.nodes[e3];
                t2[e3] = { x: Math.round(o2.x), y: Math.round(o2.y) };
              }
            } else
              for (var s2 = 0; s2 < this.body.nodeIndices.length; s2++) {
                var r2 = this.body.nodes[this.body.nodeIndices[s2]];
                t2[this.body.nodeIndices[s2]] = { x: Math.round(r2.x), y: Math.round(r2.y) };
              }
            return t2;
          } }, { key: "storePositions", value: function() {
            var e3 = [], t2 = this.body.data.nodes.getDataSet();
            for (var i2 in t2._data)
              if (t2._data.hasOwnProperty(i2)) {
                var n2 = this.body.nodes[i2];
                t2._data[i2].x == Math.round(n2.x) && t2._data[i2].y == Math.round(n2.y) || e3.push({ id: n2.id, x: Math.round(n2.x), y: Math.round(n2.y) });
              }
            t2.update(e3);
          } }, { key: "getBoundingBox", value: function(e3) {
            if (void 0 !== this.body.nodes[e3])
              return this.body.nodes[e3].shape.boundingBox;
          } }, { key: "getConnectedNodes", value: function(e3, t2) {
            var i2 = [];
            if (void 0 !== this.body.nodes[e3])
              for (var n2 = this.body.nodes[e3], o2 = {}, s2 = 0; s2 < n2.edges.length; s2++) {
                var r2 = n2.edges[s2];
                "to" !== t2 && r2.toId == n2.id ? void 0 === o2[r2.fromId] && (i2.push(r2.fromId), o2[r2.fromId] = true) : "from" !== t2 && r2.fromId == n2.id && void 0 === o2[r2.toId] && (i2.push(r2.toId), o2[r2.toId] = true);
              }
            return i2;
          } }, { key: "getConnectedEdges", value: function(e3) {
            var t2 = [];
            if (void 0 !== this.body.nodes[e3])
              for (var i2 = this.body.nodes[e3], n2 = 0; n2 < i2.edges.length; n2++)
                t2.push(i2.edges[n2].id);
            else
              console.log("NodeId provided for getConnectedEdges does not exist. Provided: ", e3);
            return t2;
          } }, { key: "moveNode", value: function(e3, t2, i2) {
            var n2 = this;
            void 0 !== this.body.nodes[e3] ? (this.body.nodes[e3].x = Number(t2), this.body.nodes[e3].y = Number(i2), setTimeout(function() {
              n2.body.emitter.emit("startSimulation");
            }, 0)) : console.log("Node id supplied to moveNode does not exist. Provided: ", e3);
          } }]), e2;
        }();
        t.default = c;
      }, function(e, t, i) {
        e.exports = { default: i(134), __esModule: true };
      }, function(e, t, i) {
        i(36), i(47), e.exports = i(135);
      }, function(e, t, i) {
        var n = i(67), o = i(8)("iterator"), s = i(24);
        e.exports = i(6).isIterable = function(e2) {
          var t2 = Object(e2);
          return void 0 !== t2[o] || "@@iterator" in t2 || s.hasOwnProperty(n(t2));
        };
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(0), s = n(o), r = i(1), a = n(r), d = i(137).default, h = i(34).default, l = function() {
          function e2(t2, i2, n2, o2) {
            var r2 = this;
            (0, s.default)(this, e2), this.ctx = t2, this.parent = i2;
            var a2 = function(e3, i3) {
              if (void 0 === e3)
                return 0;
              var s2 = r2.parent.getFormattingValues(t2, n2, o2, i3), a3 = 0;
              if ("" !== e3) {
                a3 = r2.ctx.measureText(e3).width;
              }
              return { width: a3, values: s2 };
            };
            this.lines = new d(a2);
          }
          return (0, a.default)(e2, [{ key: "process", value: function(e3) {
            if (!h.isValidLabel(e3))
              return this.lines.finalize();
            var t2 = this.parent.fontOptions;
            e3 = e3.replace(/\r\n/g, "\n"), e3 = e3.replace(/\r/g, "\n");
            var i2 = String(e3).split("\n"), n2 = i2.length;
            if (t2.multi)
              for (var o2 = 0; o2 < n2; o2++) {
                var s2 = this.splitBlocks(i2[o2], t2.multi);
                if (void 0 !== s2)
                  if (0 !== s2.length) {
                    if (t2.maxWdt > 0)
                      for (var r2 = 0; r2 < s2.length; r2++) {
                        var a2 = s2[r2].mod, d2 = s2[r2].text;
                        this.splitStringIntoLines(d2, a2, true);
                      }
                    else
                      for (var l2 = 0; l2 < s2.length; l2++) {
                        var u = s2[l2].mod, c = s2[l2].text;
                        this.lines.append(c, u);
                      }
                    this.lines.newLine();
                  } else
                    this.lines.newLine("");
              }
            else if (t2.maxWdt > 0)
              for (var f = 0; f < n2; f++)
                this.splitStringIntoLines(i2[f]);
            else
              for (var p = 0; p < n2; p++)
                this.lines.newLine(i2[p]);
            return this.lines.finalize();
          } }, { key: "decodeMarkupSystem", value: function(e3) {
            var t2 = "none";
            return "markdown" === e3 || "md" === e3 ? t2 = "markdown" : true !== e3 && "html" !== e3 || (t2 = "html"), t2;
          } }, { key: "splitHtmlBlocks", value: function(e3) {
            var t2 = [], i2 = { bold: false, ital: false, mono: false, spacing: false, position: 0, buffer: "", modStack: [] };
            for (i2.mod = function() {
              return 0 === this.modStack.length ? "normal" : this.modStack[0];
            }, i2.modName = function() {
              return 0 === this.modStack.length ? "normal" : "mono" === this.modStack[0] ? "mono" : i2.bold && i2.ital ? "boldital" : i2.bold ? "bold" : i2.ital ? "ital" : void 0;
            }, i2.emitBlock = function() {
              arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
              this.spacing && (this.add(" "), this.spacing = false), this.buffer.length > 0 && (t2.push({ text: this.buffer, mod: this.modName() }), this.buffer = "");
            }, i2.add = function(e4) {
              " " === e4 && (i2.spacing = true), i2.spacing && (this.buffer += " ", this.spacing = false), " " != e4 && (this.buffer += e4);
            }; i2.position < e3.length; ) {
              var n2 = e3.charAt(i2.position);
              /[ \t]/.test(n2) ? i2.mono ? i2.add(n2) : i2.spacing = true : /</.test(n2) ? i2.mono || i2.bold || !/<b>/.test(e3.substr(i2.position, 3)) ? i2.mono || i2.ital || !/<i>/.test(e3.substr(i2.position, 3)) ? !i2.mono && /<code>/.test(e3.substr(i2.position, 6)) ? (i2.emitBlock(), i2.mono = true, i2.modStack.unshift("mono"), i2.position += 5) : !i2.mono && "bold" === i2.mod() && /<\/b>/.test(e3.substr(i2.position, 4)) ? (i2.emitBlock(), i2.bold = false, i2.modStack.shift(), i2.position += 3) : !i2.mono && "ital" === i2.mod() && /<\/i>/.test(e3.substr(i2.position, 4)) ? (i2.emitBlock(), i2.ital = false, i2.modStack.shift(), i2.position += 3) : "mono" === i2.mod() && /<\/code>/.test(e3.substr(i2.position, 7)) ? (i2.emitBlock(), i2.mono = false, i2.modStack.shift(), i2.position += 6) : i2.add(n2) : (i2.emitBlock(), i2.ital = true, i2.modStack.unshift("ital"), i2.position += 2) : (i2.emitBlock(), i2.bold = true, i2.modStack.unshift("bold"), i2.position += 2) : /&/.test(n2) ? /&lt;/.test(e3.substr(i2.position, 4)) ? (i2.add("<"), i2.position += 3) : /&amp;/.test(e3.substr(i2.position, 5)) ? (i2.add("&"), i2.position += 4) : i2.add("&") : i2.add(n2), i2.position++;
            }
            return i2.emitBlock(), t2;
          } }, { key: "splitMarkdownBlocks", value: function(e3) {
            var t2 = [], i2 = { bold: false, ital: false, mono: false, beginable: true, spacing: false, position: 0, buffer: "", modStack: [] };
            for (i2.mod = function() {
              return 0 === this.modStack.length ? "normal" : this.modStack[0];
            }, i2.modName = function() {
              return 0 === this.modStack.length ? "normal" : "mono" === this.modStack[0] ? "mono" : i2.bold && i2.ital ? "boldital" : i2.bold ? "bold" : i2.ital ? "ital" : void 0;
            }, i2.emitBlock = function() {
              arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
              this.spacing && (this.add(" "), this.spacing = false), this.buffer.length > 0 && (t2.push({ text: this.buffer, mod: this.modName() }), this.buffer = "");
            }, i2.add = function(e4) {
              " " === e4 && (i2.spacing = true), i2.spacing && (this.buffer += " ", this.spacing = false), " " != e4 && (this.buffer += e4);
            }; i2.position < e3.length; ) {
              var n2 = e3.charAt(i2.position);
              /[ \t]/.test(n2) ? (i2.mono ? i2.add(n2) : i2.spacing = true, i2.beginable = true) : /\\/.test(n2) ? i2.position < e3.length + 1 && (i2.position++, n2 = e3.charAt(i2.position), / \t/.test(n2) ? i2.spacing = true : (i2.add(n2), i2.beginable = false)) : i2.mono || i2.bold || !i2.beginable && !i2.spacing || !/\*/.test(n2) ? i2.mono || i2.ital || !i2.beginable && !i2.spacing || !/\_/.test(n2) ? !i2.mono && (i2.beginable || i2.spacing) && /`/.test(n2) ? (i2.emitBlock(), i2.mono = true, i2.modStack.unshift("mono")) : !i2.mono && "bold" === i2.mod() && /\*/.test(n2) ? i2.position === e3.length - 1 || /[.,_` \t\n]/.test(e3.charAt(i2.position + 1)) ? (i2.emitBlock(), i2.bold = false, i2.modStack.shift()) : i2.add(n2) : !i2.mono && "ital" === i2.mod() && /\_/.test(n2) ? i2.position === e3.length - 1 || /[.,*` \t\n]/.test(e3.charAt(i2.position + 1)) ? (i2.emitBlock(), i2.ital = false, i2.modStack.shift()) : i2.add(n2) : i2.mono && "mono" === i2.mod() && /`/.test(n2) ? i2.position === e3.length - 1 || /[.,*_ \t\n]/.test(e3.charAt(i2.position + 1)) ? (i2.emitBlock(), i2.mono = false, i2.modStack.shift()) : i2.add(n2) : (i2.add(n2), i2.beginable = false) : (i2.emitBlock(), i2.ital = true, i2.modStack.unshift("ital")) : (i2.emitBlock(), i2.bold = true, i2.modStack.unshift("bold")), i2.position++;
            }
            return i2.emitBlock(), t2;
          } }, { key: "splitBlocks", value: function(e3, t2) {
            var i2 = this.decodeMarkupSystem(t2);
            return "none" === i2 ? [{ text: e3, mod: "normal" }] : "markdown" === i2 ? this.splitMarkdownBlocks(e3) : "html" === i2 ? this.splitHtmlBlocks(e3) : void 0;
          } }, { key: "overMaxWidth", value: function(e3) {
            var t2 = this.ctx.measureText(e3).width;
            return this.lines.curWidth() + t2 > this.parent.fontOptions.maxWdt;
          } }, { key: "getLongestFit", value: function(e3) {
            for (var t2 = "", i2 = 0; i2 < e3.length; ) {
              var n2 = "" === t2 ? "" : " ", o2 = t2 + n2 + e3[i2];
              if (this.overMaxWidth(o2))
                break;
              t2 = o2, i2++;
            }
            return i2;
          } }, { key: "getLongestFitWord", value: function(e3) {
            for (var t2 = 0; t2 < e3.length && !this.overMaxWidth(e3.slice(0, t2)); )
              t2++;
            return t2;
          } }, { key: "splitStringIntoLines", value: function(e3) {
            var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "normal", i2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            e3 = e3.replace(/^( +)/g, "$1\r"), e3 = e3.replace(/([^\r][^ ]*)( +)/g, "$1\r$2\r");
            for (var n2 = e3.split("\r"); n2.length > 0; ) {
              var o2 = this.getLongestFit(n2);
              if (0 === o2) {
                var s2 = n2[0], r2 = this.getLongestFitWord(s2);
                this.lines.newLine(s2.slice(0, r2), t2), n2[0] = s2.slice(r2);
              } else {
                var a2 = o2;
                " " === n2[o2 - 1] ? o2-- : " " === n2[a2] && a2++;
                var d2 = n2.slice(0, o2).join("");
                o2 == n2.length && i2 ? this.lines.append(d2, t2) : this.lines.newLine(d2, t2), n2 = n2.slice(a2);
              }
            }
          } }]), e2;
        }();
        t.default = l;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(138), s = n(o), r = i(0), a = n(r), d = i(1), h = n(d), l = function() {
          function e2(t2) {
            (0, a.default)(this, e2), this.measureText = t2, this.current = 0, this.width = 0, this.height = 0, this.lines = [];
          }
          return (0, h.default)(e2, [{ key: "_add", value: function(e3, t2) {
            var i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "normal";
            void 0 === this.lines[e3] && (this.lines[e3] = { width: 0, height: 0, blocks: [] });
            var n2 = t2;
            void 0 !== t2 && "" !== t2 || (n2 = " ");
            var o2 = this.measureText(n2, i2), r2 = (0, s.default)({}, o2.values);
            r2.text = t2, r2.width = o2.width, r2.mod = i2, void 0 !== t2 && "" !== t2 || (r2.width = 0), this.lines[e3].blocks.push(r2), this.lines[e3].width += r2.width;
          } }, { key: "curWidth", value: function() {
            var e3 = this.lines[this.current];
            return void 0 === e3 ? 0 : e3.width;
          } }, { key: "append", value: function(e3) {
            var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "normal";
            this._add(this.current, e3, t2);
          } }, { key: "newLine", value: function(e3) {
            var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "normal";
            this._add(this.current, e3, t2), this.current++;
          } }, { key: "determineLineHeights", value: function() {
            for (var e3 = 0; e3 < this.lines.length; e3++) {
              var t2 = this.lines[e3], i2 = 0;
              if (void 0 !== t2.blocks)
                for (var n2 = 0; n2 < t2.blocks.length; n2++) {
                  var o2 = t2.blocks[n2];
                  i2 < o2.height && (i2 = o2.height);
                }
              t2.height = i2;
            }
          } }, { key: "determineLabelSize", value: function() {
            for (var e3 = 0, t2 = 0, i2 = 0; i2 < this.lines.length; i2++) {
              var n2 = this.lines[i2];
              n2.width > e3 && (e3 = n2.width), t2 += n2.height;
            }
            this.width = e3, this.height = t2;
          } }, { key: "removeEmptyBlocks", value: function() {
            for (var e3 = [], t2 = 0; t2 < this.lines.length; t2++) {
              var i2 = this.lines[t2];
              if (0 !== i2.blocks.length && (t2 !== this.lines.length - 1 || 0 !== i2.width)) {
                var n2 = {};
                (0, s.default)(n2, i2), n2.blocks = [];
                for (var o2 = void 0, r2 = [], a2 = 0; a2 < i2.blocks.length; a2++) {
                  var d2 = i2.blocks[a2];
                  0 !== d2.width ? r2.push(d2) : void 0 === o2 && (o2 = d2);
                }
                0 === r2.length && void 0 !== o2 && r2.push(o2), n2.blocks = r2, e3.push(n2);
              }
            }
            return e3;
          } }, { key: "finalize", value: function() {
            this.determineLineHeights(), this.determineLabelSize();
            var e3 = this.removeEmptyBlocks();
            return { width: this.width, height: this.height, lines: e3 };
          } }]), e2;
        }();
        t.default = l;
      }, function(e, t, i) {
        e.exports = { default: i(139), __esModule: true };
      }, function(e, t, i) {
        i(140), e.exports = i(6).Object.assign;
      }, function(e, t, i) {
        var n = i(11);
        n(n.S + n.F, "Object", { assign: i(141) });
      }, function(e, t, i) {
        var n = i(26), o = i(50), s = i(31), r = i(29), a = i(59), d = Object.assign;
        e.exports = !d || i(20)(function() {
          var e2 = {}, t2 = {}, i2 = Symbol(), n2 = "abcdefghijklmnopqrst";
          return e2[i2] = 7, n2.split("").forEach(function(e3) {
            t2[e3] = e3;
          }), 7 != d({}, e2)[i2] || Object.keys(d({}, t2)).join("") != n2;
        }) ? function(e2, t2) {
          for (var i2 = r(e2), d2 = arguments.length, h = 1, l = o.f, u = s.f; d2 > h; )
            for (var c, f = a(arguments[h++]), p = l ? n(f).concat(l(f)) : n(f), v = p.length, g = 0; v > g; )
              u.call(f, c = p[g++]) && (i2[c] = f[c]);
          return i2;
        } : d;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(2), s = n(o), r = i(0), a = n(r), d = i(1), h = n(d), l = i(3), u = n(l), c = i(4), f = n(c), p = i(15), v = n(p), g = function(e2) {
          function t2(e3, i2, n2) {
            (0, a.default)(this, t2);
            var o2 = (0, u.default)(this, (t2.__proto__ || (0, s.default)(t2)).call(this, e3, i2, n2));
            return o2._setMargins(n2), o2;
          }
          return (0, f.default)(t2, e2), (0, h.default)(t2, [{ key: "resize", value: function(e3) {
            var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.selected, i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.hover;
            if (this.needsRefresh(t3, i2)) {
              var n2 = this.getDimensionsFromLabel(e3, t3, i2);
              this.width = n2.width + this.margin.right + this.margin.left, this.height = n2.height + this.margin.top + this.margin.bottom, this.radius = this.width / 2;
            }
          } }, { key: "draw", value: function(e3, t3, i2, n2, o2, s2) {
            this.resize(e3, n2, o2), this.left = t3 - this.width / 2, this.top = i2 - this.height / 2, this.initContextForDraw(e3, s2), e3.roundRect(this.left, this.top, this.width, this.height, s2.borderRadius), this.performFill(e3, s2), this.updateBoundingBox(t3, i2, e3, n2, o2), this.labelModule.draw(e3, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, n2, o2);
          } }, { key: "updateBoundingBox", value: function(e3, t3, i2, n2, o2) {
            this._updateBoundingBox(e3, t3, i2, n2, o2);
            var s2 = this.options.shapeProperties.borderRadius;
            this._addBoundingBoxMargin(s2);
          } }, { key: "distanceToBorder", value: function(e3, t3) {
            this.resize(e3);
            var i2 = this.options.borderWidth;
            return Math.min(Math.abs(this.width / 2 / Math.cos(t3)), Math.abs(this.height / 2 / Math.sin(t3))) + i2;
          } }]), t2;
        }(v.default);
        t.default = g;
      }, function(e, t, i) {
        i(144), e.exports = i(6).Object.getPrototypeOf;
      }, function(e, t, i) {
        var n = i(29), o = i(66);
        i(68)("getPrototypeOf", function() {
          return function(e2) {
            return o(n(e2));
          };
        });
      }, function(e, t, i) {
        e.exports = { default: i(146), __esModule: true };
      }, function(e, t, i) {
        i(147), e.exports = i(6).Object.setPrototypeOf;
      }, function(e, t, i) {
        var n = i(11);
        n(n.S, "Object", { setPrototypeOf: i(148).set });
      }, function(e, t, i) {
        var n = i(25), o = i(19), s = function(e2, t2) {
          if (o(e2), !n(t2) && null !== t2)
            throw TypeError(t2 + ": can't set as prototype!");
        };
        e.exports = { set: Object.setPrototypeOf || ("__proto__" in {} ? function(e2, t2, n2) {
          try {
            n2 = i(61)(Function.call, i(70).f(Object.prototype, "__proto__").set, 2), n2(e2, []), t2 = !(e2 instanceof Array);
          } catch (e3) {
            t2 = true;
          }
          return function(e3, i2) {
            return s(e3, i2), t2 ? e3.__proto__ = i2 : n2(e3, i2), e3;
          };
        }({}, false) : void 0), check: s };
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(2), s = n(o), r = i(0), a = n(r), d = i(1), h = n(d), l = i(3), u = n(l), c = i(4), f = n(c), p = i(53), v = n(p), g = function(e2) {
          function t2(e3, i2, n2) {
            (0, a.default)(this, t2);
            var o2 = (0, u.default)(this, (t2.__proto__ || (0, s.default)(t2)).call(this, e3, i2, n2));
            return o2._setMargins(n2), o2;
          }
          return (0, f.default)(t2, e2), (0, h.default)(t2, [{ key: "resize", value: function(e3) {
            var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.selected, i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.hover;
            if (this.needsRefresh(t3, i2)) {
              var n2 = this.getDimensionsFromLabel(e3, t3, i2), o2 = Math.max(n2.width + this.margin.right + this.margin.left, n2.height + this.margin.top + this.margin.bottom);
              this.options.size = o2 / 2, this.width = o2, this.height = o2, this.radius = this.width / 2;
            }
          } }, { key: "draw", value: function(e3, t3, i2, n2, o2, s2) {
            this.resize(e3, n2, o2), this.left = t3 - this.width / 2, this.top = i2 - this.height / 2, this._drawRawCircle(e3, t3, i2, s2), this.updateBoundingBox(t3, i2), this.labelModule.draw(e3, this.left + this.textSize.width / 2 + this.margin.left, i2, n2, o2);
          } }, { key: "updateBoundingBox", value: function(e3, t3) {
            this.boundingBox.top = t3 - this.options.size, this.boundingBox.left = e3 - this.options.size, this.boundingBox.right = e3 + this.options.size, this.boundingBox.bottom = t3 + this.options.size;
          } }, { key: "distanceToBorder", value: function(e3, t3) {
            return this.resize(e3), 0.5 * this.width;
          } }]), t2;
        }(v.default);
        t.default = g;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(2), s = n(o), r = i(0), a = n(r), d = i(1), h = n(d), l = i(3), u = n(l), c = i(4), f = n(c), p = i(53), v = n(p), g = function(e2) {
          function t2(e3, i2, n2, o2, r2) {
            (0, a.default)(this, t2);
            var d2 = (0, u.default)(this, (t2.__proto__ || (0, s.default)(t2)).call(this, e3, i2, n2));
            return d2.setImages(o2, r2), d2;
          }
          return (0, f.default)(t2, e2), (0, h.default)(t2, [{ key: "resize", value: function(e3) {
            var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.selected, i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.hover;
            if (void 0 === this.imageObj.src || void 0 === this.imageObj.width || void 0 === this.imageObj.height) {
              var n2 = 2 * this.options.size;
              return this.width = n2, this.height = n2, void (this.radius = 0.5 * this.width);
            }
            this.needsRefresh(t3, i2) && this._resizeImage();
          } }, { key: "draw", value: function(e3, t3, i2, n2, o2, s2) {
            this.switchImages(n2), this.resize(), this.left = t3 - this.width / 2, this.top = i2 - this.height / 2, this._drawRawCircle(e3, t3, i2, s2), e3.save(), e3.clip(), this._drawImageAtPosition(e3, s2), e3.restore(), this._drawImageLabel(e3, t3, i2, n2, o2), this.updateBoundingBox(t3, i2);
          } }, { key: "updateBoundingBox", value: function(e3, t3) {
            this.boundingBox.top = t3 - this.options.size, this.boundingBox.left = e3 - this.options.size, this.boundingBox.right = e3 + this.options.size, this.boundingBox.bottom = t3 + this.options.size, this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left), this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width), this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelOffset);
          } }, { key: "distanceToBorder", value: function(e3, t3) {
            return this.resize(e3), 0.5 * this.width;
          } }]), t2;
        }(v.default);
        t.default = g;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(2), s = n(o), r = i(0), a = n(r), d = i(1), h = n(d), l = i(3), u = n(l), c = i(4), f = n(c), p = i(15), v = n(p), g = function(e2) {
          function t2(e3, i2, n2) {
            (0, a.default)(this, t2);
            var o2 = (0, u.default)(this, (t2.__proto__ || (0, s.default)(t2)).call(this, e3, i2, n2));
            return o2._setMargins(n2), o2;
          }
          return (0, f.default)(t2, e2), (0, h.default)(t2, [{ key: "resize", value: function(e3, t3, i2) {
            if (this.needsRefresh(t3, i2)) {
              var n2 = this.getDimensionsFromLabel(e3, t3, i2), o2 = n2.width + this.margin.right + this.margin.left;
              this.width = o2, this.height = o2, this.radius = this.width / 2;
            }
          } }, { key: "draw", value: function(e3, t3, i2, n2, o2, s2) {
            this.resize(e3, n2, o2), this.left = t3 - this.width / 2, this.top = i2 - this.height / 2, this.initContextForDraw(e3, s2), e3.database(t3 - this.width / 2, i2 - this.height / 2, this.width, this.height), this.performFill(e3, s2), this.updateBoundingBox(t3, i2, e3, n2, o2), this.labelModule.draw(e3, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, n2, o2);
          } }, { key: "distanceToBorder", value: function(e3, t3) {
            return this._distanceToBorder(e3, t3);
          } }]), t2;
        }(v.default);
        t.default = g;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(2), s = n(o), r = i(0), a = n(r), d = i(1), h = n(d), l = i(3), u = n(l), c = i(4), f = n(c), p = i(16), v = n(p), g = function(e2) {
          function t2(e3, i2, n2) {
            return (0, a.default)(this, t2), (0, u.default)(this, (t2.__proto__ || (0, s.default)(t2)).call(this, e3, i2, n2));
          }
          return (0, f.default)(t2, e2), (0, h.default)(t2, [{ key: "draw", value: function(e3, t3, i2, n2, o2, s2) {
            this._drawShape(e3, "diamond", 4, t3, i2, n2, o2, s2);
          } }, { key: "distanceToBorder", value: function(e3, t3) {
            return this._distanceToBorder(e3, t3);
          } }]), t2;
        }(v.default);
        t.default = g;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(2), s = n(o), r = i(0), a = n(r), d = i(1), h = n(d), l = i(3), u = n(l), c = i(4), f = n(c), p = i(16), v = n(p), g = function(e2) {
          function t2(e3, i2, n2) {
            return (0, a.default)(this, t2), (0, u.default)(this, (t2.__proto__ || (0, s.default)(t2)).call(this, e3, i2, n2));
          }
          return (0, f.default)(t2, e2), (0, h.default)(t2, [{ key: "draw", value: function(e3, t3, i2, n2, o2, s2) {
            this._drawShape(e3, "circle", 2, t3, i2, n2, o2, s2);
          } }, { key: "distanceToBorder", value: function(e3, t3) {
            return this.resize(e3), this.options.size;
          } }]), t2;
        }(v.default);
        t.default = g;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(2), s = n(o), r = i(0), a = n(r), d = i(1), h = n(d), l = i(3), u = n(l), c = i(4), f = n(c), p = i(15), v = n(p), g = function(e2) {
          function t2(e3, i2, n2) {
            return (0, a.default)(this, t2), (0, u.default)(this, (t2.__proto__ || (0, s.default)(t2)).call(this, e3, i2, n2));
          }
          return (0, f.default)(t2, e2), (0, h.default)(t2, [{ key: "resize", value: function(e3) {
            var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.selected, i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.hover;
            if (this.needsRefresh(t3, i2)) {
              var n2 = this.getDimensionsFromLabel(e3, t3, i2);
              this.height = 2 * n2.height, this.width = n2.width + n2.height, this.radius = 0.5 * this.width;
            }
          } }, { key: "draw", value: function(e3, t3, i2, n2, o2, s2) {
            this.resize(e3, n2, o2), this.left = t3 - 0.5 * this.width, this.top = i2 - 0.5 * this.height, this.initContextForDraw(e3, s2), e3.ellipse_vis(this.left, this.top, this.width, this.height), this.performFill(e3, s2), this.updateBoundingBox(t3, i2, e3, n2, o2), this.labelModule.draw(e3, t3, i2, n2, o2);
          } }, { key: "distanceToBorder", value: function(e3, t3) {
            this.resize(e3);
            var i2 = 0.5 * this.width, n2 = 0.5 * this.height, o2 = Math.sin(t3) * i2, s2 = Math.cos(t3) * n2;
            return i2 * n2 / Math.sqrt(o2 * o2 + s2 * s2);
          } }]), t2;
        }(v.default);
        t.default = g;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(2), s = n(o), r = i(0), a = n(r), d = i(1), h = n(d), l = i(3), u = n(l), c = i(4), f = n(c), p = i(15), v = n(p), g = function(e2) {
          function t2(e3, i2, n2) {
            (0, a.default)(this, t2);
            var o2 = (0, u.default)(this, (t2.__proto__ || (0, s.default)(t2)).call(this, e3, i2, n2));
            return o2._setMargins(n2), o2;
          }
          return (0, f.default)(t2, e2), (0, h.default)(t2, [{ key: "resize", value: function(e3, t3, i2) {
            this.needsRefresh(t3, i2) && (this.iconSize = { width: Number(this.options.icon.size), height: Number(this.options.icon.size) }, this.width = this.iconSize.width + this.margin.right + this.margin.left, this.height = this.iconSize.height + this.margin.top + this.margin.bottom, this.radius = 0.5 * this.width);
          } }, { key: "draw", value: function(e3, t3, i2, n2, o2, s2) {
            if (this.resize(e3, n2, o2), this.options.icon.size = this.options.icon.size || 50, this.left = t3 - this.width / 2, this.top = i2 - this.height / 2, this._icon(e3, t3, i2, n2, o2, s2), void 0 !== this.options.label) {
              this.labelModule.draw(e3, this.left + this.iconSize.width / 2 + this.margin.left, i2 + this.height / 2 + 5, n2);
            }
            this.updateBoundingBox(t3, i2);
          } }, { key: "updateBoundingBox", value: function(e3, t3) {
            if (this.boundingBox.top = t3 - 0.5 * this.options.icon.size, this.boundingBox.left = e3 - 0.5 * this.options.icon.size, this.boundingBox.right = e3 + 0.5 * this.options.icon.size, this.boundingBox.bottom = t3 + 0.5 * this.options.icon.size, void 0 !== this.options.label && this.labelModule.size.width > 0) {
              this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left), this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width), this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelModule.size.height + 5);
            }
          } }, { key: "_icon", value: function(e3, t3, i2, n2, o2, s2) {
            var r2 = Number(this.options.icon.size);
            void 0 !== this.options.icon.code ? (e3.font = (n2 ? "bold " : "") + r2 + "px " + this.options.icon.face, e3.fillStyle = this.options.icon.color || "black", e3.textAlign = "center", e3.textBaseline = "middle", this.enableShadow(e3, s2), e3.fillText(this.options.icon.code, t3, i2), this.disableShadow(e3, s2)) : console.error("When using the icon shape, you need to define the code in the icon options object. This can be done per node or globally.");
          } }, { key: "distanceToBorder", value: function(e3, t3) {
            return this._distanceToBorder(e3, t3);
          } }]), t2;
        }(v.default);
        t.default = g;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(2), s = n(o), r = i(0), a = n(r), d = i(1), h = n(d), l = i(3), u = n(l), c = i(4), f = n(c), p = i(53), v = n(p), g = function(e2) {
          function t2(e3, i2, n2, o2, r2) {
            (0, a.default)(this, t2);
            var d2 = (0, u.default)(this, (t2.__proto__ || (0, s.default)(t2)).call(this, e3, i2, n2));
            return d2.setImages(o2, r2), d2;
          }
          return (0, f.default)(t2, e2), (0, h.default)(t2, [{ key: "resize", value: function(e3) {
            var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.selected, i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.hover;
            if (void 0 === this.imageObj.src || void 0 === this.imageObj.width || void 0 === this.imageObj.height) {
              var n2 = 2 * this.options.size;
              return this.width = n2, void (this.height = n2);
            }
            this.needsRefresh(t3, i2) && this._resizeImage();
          } }, { key: "draw", value: function(e3, t3, i2, n2, o2, s2) {
            if (this.switchImages(n2), this.resize(), this.left = t3 - this.width / 2, this.top = i2 - this.height / 2, true === this.options.shapeProperties.useBorderWithImage) {
              var r2 = this.options.borderWidth, a2 = this.options.borderWidthSelected || 2 * this.options.borderWidth, d2 = (n2 ? a2 : r2) / this.body.view.scale;
              e3.lineWidth = Math.min(this.width, d2), e3.beginPath(), e3.strokeStyle = n2 ? this.options.color.highlight.border : o2 ? this.options.color.hover.border : this.options.color.border, e3.fillStyle = n2 ? this.options.color.highlight.background : o2 ? this.options.color.hover.background : this.options.color.background, e3.rect(this.left - 0.5 * e3.lineWidth, this.top - 0.5 * e3.lineWidth, this.width + e3.lineWidth, this.height + e3.lineWidth), e3.fill(), this.performStroke(e3, s2), e3.closePath();
            }
            this._drawImageAtPosition(e3, s2), this._drawImageLabel(e3, t3, i2, n2, o2), this.updateBoundingBox(t3, i2);
          } }, { key: "updateBoundingBox", value: function(e3, t3) {
            this.resize(), this._updateBoundingBox(e3, t3), void 0 !== this.options.label && this.labelModule.size.width > 0 && (this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left), this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width), this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelOffset));
          } }, { key: "distanceToBorder", value: function(e3, t3) {
            return this._distanceToBorder(e3, t3);
          } }]), t2;
        }(v.default);
        t.default = g;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(2), s = n(o), r = i(0), a = n(r), d = i(1), h = n(d), l = i(3), u = n(l), c = i(4), f = n(c), p = i(16), v = n(p), g = function(e2) {
          function t2(e3, i2, n2) {
            return (0, a.default)(this, t2), (0, u.default)(this, (t2.__proto__ || (0, s.default)(t2)).call(this, e3, i2, n2));
          }
          return (0, f.default)(t2, e2), (0, h.default)(t2, [{ key: "draw", value: function(e3, t3, i2, n2, o2, s2) {
            this._drawShape(e3, "square", 2, t3, i2, n2, o2, s2);
          } }, { key: "distanceToBorder", value: function(e3, t3) {
            return this._distanceToBorder(e3, t3);
          } }]), t2;
        }(v.default);
        t.default = g;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(2), s = n(o), r = i(0), a = n(r), d = i(1), h = n(d), l = i(3), u = n(l), c = i(4), f = n(c), p = i(16), v = n(p), g = function(e2) {
          function t2(e3, i2, n2) {
            return (0, a.default)(this, t2), (0, u.default)(this, (t2.__proto__ || (0, s.default)(t2)).call(this, e3, i2, n2));
          }
          return (0, f.default)(t2, e2), (0, h.default)(t2, [{ key: "draw", value: function(e3, t3, i2, n2, o2, s2) {
            this._drawShape(e3, "hexagon", 4, t3, i2, n2, o2, s2);
          } }, { key: "distanceToBorder", value: function(e3, t3) {
            return this._distanceToBorder(e3, t3);
          } }]), t2;
        }(v.default);
        t.default = g;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(2), s = n(o), r = i(0), a = n(r), d = i(1), h = n(d), l = i(3), u = n(l), c = i(4), f = n(c), p = i(16), v = n(p), g = function(e2) {
          function t2(e3, i2, n2) {
            return (0, a.default)(this, t2), (0, u.default)(this, (t2.__proto__ || (0, s.default)(t2)).call(this, e3, i2, n2));
          }
          return (0, f.default)(t2, e2), (0, h.default)(t2, [{ key: "draw", value: function(e3, t3, i2, n2, o2, s2) {
            this._drawShape(e3, "star", 4, t3, i2, n2, o2, s2);
          } }, { key: "distanceToBorder", value: function(e3, t3) {
            return this._distanceToBorder(e3, t3);
          } }]), t2;
        }(v.default);
        t.default = g;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(2), s = n(o), r = i(0), a = n(r), d = i(1), h = n(d), l = i(3), u = n(l), c = i(4), f = n(c), p = i(15), v = n(p), g = function(e2) {
          function t2(e3, i2, n2) {
            (0, a.default)(this, t2);
            var o2 = (0, u.default)(this, (t2.__proto__ || (0, s.default)(t2)).call(this, e3, i2, n2));
            return o2._setMargins(n2), o2;
          }
          return (0, f.default)(t2, e2), (0, h.default)(t2, [{ key: "resize", value: function(e3, t3, i2) {
            this.needsRefresh(t3, i2) && (this.textSize = this.labelModule.getTextSize(e3, t3, i2), this.width = this.textSize.width + this.margin.right + this.margin.left, this.height = this.textSize.height + this.margin.top + this.margin.bottom, this.radius = 0.5 * this.width);
          } }, { key: "draw", value: function(e3, t3, i2, n2, o2, s2) {
            this.resize(e3, n2, o2), this.left = t3 - this.width / 2, this.top = i2 - this.height / 2, this.enableShadow(e3, s2), this.labelModule.draw(e3, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, n2, o2), this.disableShadow(e3, s2), this.updateBoundingBox(t3, i2, e3, n2, o2);
          } }, { key: "distanceToBorder", value: function(e3, t3) {
            return this._distanceToBorder(e3, t3);
          } }]), t2;
        }(v.default);
        t.default = g;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(2), s = n(o), r = i(0), a = n(r), d = i(1), h = n(d), l = i(3), u = n(l), c = i(4), f = n(c), p = i(16), v = n(p), g = function(e2) {
          function t2(e3, i2, n2) {
            return (0, a.default)(this, t2), (0, u.default)(this, (t2.__proto__ || (0, s.default)(t2)).call(this, e3, i2, n2));
          }
          return (0, f.default)(t2, e2), (0, h.default)(t2, [{ key: "draw", value: function(e3, t3, i2, n2, o2, s2) {
            this._drawShape(e3, "triangle", 3, t3, i2, n2, o2, s2);
          } }, { key: "distanceToBorder", value: function(e3, t3) {
            return this._distanceToBorder(e3, t3);
          } }]), t2;
        }(v.default);
        t.default = g;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(2), s = n(o), r = i(0), a = n(r), d = i(1), h = n(d), l = i(3), u = n(l), c = i(4), f = n(c), p = i(16), v = n(p), g = function(e2) {
          function t2(e3, i2, n2) {
            return (0, a.default)(this, t2), (0, u.default)(this, (t2.__proto__ || (0, s.default)(t2)).call(this, e3, i2, n2));
          }
          return (0, f.default)(t2, e2), (0, h.default)(t2, [{ key: "draw", value: function(e3, t3, i2, n2, o2, s2) {
            this._drawShape(e3, "triangleDown", 3, t3, i2, n2, o2, s2);
          } }, { key: "distanceToBorder", value: function(e3, t3) {
            return this._distanceToBorder(e3, t3);
          } }]), t2;
        }(v.default);
        t.default = g;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(0), s = n(o), r = i(1), a = n(r), d = i(5), h = i(32), l = i(51), u = i(55).default, c = function() {
          function e2(t2, i2, n2) {
            var o2 = this;
            (0, s.default)(this, e2), this.body = t2, this.images = i2, this.groups = n2, this.body.functions.createEdge = this.create.bind(this), this.edgesListeners = { add: function(e3, t3) {
              o2.add(t3.items);
            }, update: function(e3, t3) {
              o2.update(t3.items);
            }, remove: function(e3, t3) {
              o2.remove(t3.items);
            } }, this.options = {}, this.defaultOptions = { arrows: { to: { enabled: false, scaleFactor: 1, type: "arrow" }, middle: { enabled: false, scaleFactor: 1, type: "arrow" }, from: { enabled: false, scaleFactor: 1, type: "arrow" } }, arrowStrikethrough: true, color: { color: "#848484", highlight: "#848484", hover: "#848484", inherit: "from", opacity: 1 }, dashes: false, font: { color: "#343434", size: 14, face: "arial", background: "none", strokeWidth: 2, strokeColor: "#ffffff", align: "horizontal", multi: false, vadjust: 0, bold: { mod: "bold" }, boldital: { mod: "bold italic" }, ital: { mod: "italic" }, mono: { mod: "", size: 15, face: "courier new", vadjust: 2 } }, hidden: false, hoverWidth: 1.5, label: void 0, labelHighlightBold: true, length: void 0, physics: true, scaling: { min: 1, max: 15, label: { enabled: true, min: 14, max: 30, maxVisible: 30, drawThreshold: 5 }, customScalingFunction: function(e3, t3, i3, n3) {
              if (t3 === e3)
                return 0.5;
              var o3 = 1 / (t3 - e3);
              return Math.max(0, (n3 - e3) * o3);
            } }, selectionWidth: 1.5, selfReferenceSize: 20, shadow: { enabled: false, color: "rgba(0,0,0,0.5)", size: 10, x: 5, y: 5 }, smooth: { enabled: true, type: "dynamic", forceDirection: "none", roundness: 0.5 }, title: void 0, width: 1, value: void 0 }, d.deepExtend(this.options, this.defaultOptions), this.bindEventListeners();
          }
          return (0, a.default)(e2, [{ key: "bindEventListeners", value: function() {
            var e3 = this;
            this.body.emitter.on("_forceDisableDynamicCurves", function(t2) {
              var i2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
              "dynamic" === t2 && (t2 = "continuous");
              var n2 = false;
              for (var o2 in e3.body.edges)
                if (e3.body.edges.hasOwnProperty(o2)) {
                  var s2 = e3.body.edges[o2], r2 = e3.body.data.edges._data[o2];
                  if (void 0 !== r2) {
                    var a2 = r2.smooth;
                    void 0 !== a2 && true === a2.enabled && "dynamic" === a2.type && (void 0 === t2 ? s2.setOptions({ smooth: false }) : s2.setOptions({ smooth: { type: t2 } }), n2 = true);
                  }
                }
              true === i2 && true === n2 && e3.body.emitter.emit("_dataChanged");
            }), this.body.emitter.on("_dataUpdated", function() {
              e3.reconnectEdges();
            }), this.body.emitter.on("refreshEdges", this.refresh.bind(this)), this.body.emitter.on("refresh", this.refresh.bind(this)), this.body.emitter.on("destroy", function() {
              d.forEach(e3.edgesListeners, function(t2, i2) {
                e3.body.data.edges && e3.body.data.edges.off(i2, t2);
              }), delete e3.body.functions.createEdge, delete e3.edgesListeners.add, delete e3.edgesListeners.update, delete e3.edgesListeners.remove, delete e3.edgesListeners;
            });
          } }, { key: "setOptions", value: function(e3) {
            if (void 0 !== e3) {
              u.parseOptions(this.options, e3, true, this.defaultOptions, true);
              var t2 = false;
              if (void 0 !== e3.smooth)
                for (var i2 in this.body.edges)
                  this.body.edges.hasOwnProperty(i2) && (t2 = this.body.edges[i2].updateEdgeType() || t2);
              if (void 0 !== e3.font)
                for (var n2 in this.body.edges)
                  this.body.edges.hasOwnProperty(n2) && this.body.edges[n2].updateLabelModule();
              void 0 === e3.hidden && void 0 === e3.physics && true !== t2 || this.body.emitter.emit("_dataChanged");
            }
          } }, { key: "setData", value: function(e3) {
            var t2 = this, i2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], n2 = this.body.data.edges;
            if (e3 instanceof h || e3 instanceof l)
              this.body.data.edges = e3;
            else if (Array.isArray(e3))
              this.body.data.edges = new h(), this.body.data.edges.add(e3);
            else {
              if (e3)
                throw new TypeError("Array or DataSet expected");
              this.body.data.edges = new h();
            }
            if (n2 && d.forEach(this.edgesListeners, function(e4, t3) {
              n2.off(t3, e4);
            }), this.body.edges = {}, this.body.data.edges) {
              d.forEach(this.edgesListeners, function(e4, i3) {
                t2.body.data.edges.on(i3, e4);
              });
              var o2 = this.body.data.edges.getIds();
              this.add(o2, true);
            }
            this.body.emitter.emit("_adjustEdgesForHierarchicalLayout"), false === i2 && this.body.emitter.emit("_dataChanged");
          } }, { key: "add", value: function(e3) {
            for (var t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], i2 = this.body.edges, n2 = this.body.data.edges, o2 = 0; o2 < e3.length; o2++) {
              var s2 = e3[o2], r2 = i2[s2];
              r2 && r2.disconnect();
              var a2 = n2.get(s2, { showInternalIds: true });
              i2[s2] = this.create(a2);
            }
            this.body.emitter.emit("_adjustEdgesForHierarchicalLayout"), false === t2 && this.body.emitter.emit("_dataChanged");
          } }, { key: "update", value: function(e3) {
            for (var t2 = this.body.edges, i2 = this.body.data.edges, n2 = false, o2 = 0; o2 < e3.length; o2++) {
              var s2 = e3[o2], r2 = i2.get(s2), a2 = t2[s2];
              void 0 !== a2 ? (a2.disconnect(), n2 = a2.setOptions(r2) || n2, a2.connect()) : (this.body.edges[s2] = this.create(r2), n2 = true);
            }
            true === n2 ? (this.body.emitter.emit("_adjustEdgesForHierarchicalLayout"), this.body.emitter.emit("_dataChanged")) : this.body.emitter.emit("_dataUpdated");
          } }, { key: "remove", value: function(e3) {
            var t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
            if (0 !== e3.length) {
              var i2 = this.body.edges;
              d.forEach(e3, function(e4) {
                var t3 = i2[e4];
                void 0 !== t3 && t3.remove();
              }), t2 && this.body.emitter.emit("_dataChanged");
            }
          } }, { key: "refresh", value: function() {
            var e3 = this;
            d.forEach(this.body.edges, function(t2, i2) {
              var n2 = e3.body.data.edges._data[i2];
              void 0 !== n2 && t2.setOptions(n2);
            });
          } }, { key: "create", value: function(e3) {
            return new u(e3, this.body, this.options, this.defaultOptions);
          } }, { key: "reconnectEdges", value: function() {
            var e3, t2 = this.body.nodes, i2 = this.body.edges;
            for (e3 in t2)
              t2.hasOwnProperty(e3) && (t2[e3].edges = []);
            for (e3 in i2)
              if (i2.hasOwnProperty(e3)) {
                var n2 = i2[e3];
                n2.from = null, n2.to = null, n2.connect();
              }
          } }, { key: "getConnectedNodes", value: function(e3) {
            var t2 = [];
            if (void 0 !== this.body.edges[e3]) {
              var i2 = this.body.edges[e3];
              void 0 !== i2.fromId && t2.push(i2.fromId), void 0 !== i2.toId && t2.push(i2.toId);
            }
            return t2;
          } }, { key: "_updateState", value: function() {
            this._addMissingEdges(), this._removeInvalidEdges();
          } }, { key: "_removeInvalidEdges", value: function() {
            var e3 = this, t2 = [];
            d.forEach(this.body.edges, function(i2, n2) {
              var o2 = e3.body.nodes[i2.toId], s2 = e3.body.nodes[i2.fromId];
              void 0 !== o2 && true === o2.isCluster || void 0 !== s2 && true === s2.isCluster || void 0 !== o2 && void 0 !== s2 || t2.push(n2);
            }), this.remove(t2, false);
          } }, { key: "_addMissingEdges", value: function() {
            var e3 = this.body.edges, t2 = this.body.data.edges, i2 = [];
            t2.forEach(function(t3, n2) {
              void 0 === e3[n2] && i2.push(n2);
            }), this.add(i2, true);
          } }]), e2;
        }();
        t.default = c;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(23), s = n(o), r = i(2), a = n(r), d = i(0), h = n(d), l = i(1), u = n(l), c = i(3), f = n(c), p = i(4), v = n(p), g = i(165), y = n(g), m = function(e2) {
          function t2(e3, i2, n2) {
            return (0, h.default)(this, t2), (0, f.default)(this, (t2.__proto__ || (0, a.default)(t2)).call(this, e3, i2, n2));
          }
          return (0, v.default)(t2, e2), (0, u.default)(t2, [{ key: "_line", value: function(e3, t3, i2) {
            var n2 = i2[0], o2 = i2[1];
            this._bezierCurve(e3, t3, n2, o2);
          } }, { key: "_getViaCoordinates", value: function() {
            var e3 = this.from.x - this.to.x, t3 = this.from.y - this.to.y, i2 = void 0, n2 = void 0, o2 = void 0, s2 = void 0, r2 = this.options.smooth.roundness;
            return (Math.abs(e3) > Math.abs(t3) || true === this.options.smooth.forceDirection || "horizontal" === this.options.smooth.forceDirection) && "vertical" !== this.options.smooth.forceDirection ? (n2 = this.from.y, s2 = this.to.y, i2 = this.from.x - r2 * e3, o2 = this.to.x + r2 * e3) : (n2 = this.from.y - r2 * t3, s2 = this.to.y + r2 * t3, i2 = this.from.x, o2 = this.to.x), [{ x: i2, y: n2 }, { x: o2, y: s2 }];
          } }, { key: "getViaNode", value: function() {
            return this._getViaCoordinates();
          } }, { key: "_findBorderPosition", value: function(e3, t3) {
            return this._findBorderPositionBezier(e3, t3);
          } }, { key: "_getDistanceToEdge", value: function(e3, t3, i2, n2, o2, r2) {
            var a2 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : this._getViaCoordinates(), d2 = (0, s.default)(a2, 2), h2 = d2[0], l2 = d2[1];
            return this._getDistanceToBezierEdge(e3, t3, i2, n2, o2, r2, h2, l2);
          } }, { key: "getPoint", value: function(e3) {
            var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this._getViaCoordinates(), i2 = (0, s.default)(t3, 2), n2 = i2[0], o2 = i2[1], r2 = e3, a2 = [];
            return a2[0] = Math.pow(1 - r2, 3), a2[1] = 3 * r2 * Math.pow(1 - r2, 2), a2[2] = 3 * Math.pow(r2, 2) * (1 - r2), a2[3] = Math.pow(r2, 3), { x: a2[0] * this.fromPoint.x + a2[1] * n2.x + a2[2] * o2.x + a2[3] * this.toPoint.x, y: a2[0] * this.fromPoint.y + a2[1] * n2.y + a2[2] * o2.y + a2[3] * this.toPoint.y };
          } }]), t2;
        }(y.default);
        t.default = m;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(2), s = n(o), r = i(0), a = n(r), d = i(1), h = n(d), l = i(3), u = n(l), c = i(4), f = n(c), p = i(56), v = n(p), g = function(e2) {
          function t2(e3, i2, n2) {
            return (0, a.default)(this, t2), (0, u.default)(this, (t2.__proto__ || (0, s.default)(t2)).call(this, e3, i2, n2));
          }
          return (0, f.default)(t2, e2), (0, h.default)(t2, [{ key: "_getDistanceToBezierEdge", value: function(e3, t3, i2, n2, o2, s2, r2, a2) {
            var d2 = 1e9, h2 = void 0, l2 = void 0, u2 = void 0, c2 = void 0, f2 = void 0, p2 = e3, v2 = t3, g2 = [0, 0, 0, 0];
            for (l2 = 1; l2 < 10; l2++)
              u2 = 0.1 * l2, g2[0] = Math.pow(1 - u2, 3), g2[1] = 3 * u2 * Math.pow(1 - u2, 2), g2[2] = 3 * Math.pow(u2, 2) * (1 - u2), g2[3] = Math.pow(u2, 3), c2 = g2[0] * e3 + g2[1] * r2.x + g2[2] * a2.x + g2[3] * i2, f2 = g2[0] * t3 + g2[1] * r2.y + g2[2] * a2.y + g2[3] * n2, l2 > 0 && (h2 = this._getDistanceToLine(p2, v2, c2, f2, o2, s2), d2 = h2 < d2 ? h2 : d2), p2 = c2, v2 = f2;
            return d2;
          } }]), t2;
        }(v.default);
        t.default = g;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(23), s = n(o), r = i(2), a = n(r), d = i(0), h = n(d), l = i(1), u = n(l), c = i(3), f = n(c), p = i(4), v = n(p), g = i(56), y = n(g), m = function(e2) {
          function t2(e3, i2, n2) {
            (0, h.default)(this, t2);
            var o2 = (0, f.default)(this, (t2.__proto__ || (0, a.default)(t2)).call(this, e3, i2, n2));
            return o2._boundFunction = function() {
              o2.positionBezierNode();
            }, o2.body.emitter.on("_repositionBezierNodes", o2._boundFunction), o2;
          }
          return (0, v.default)(t2, e2), (0, u.default)(t2, [{ key: "setOptions", value: function(e3) {
            var t3 = false;
            this.options.physics !== e3.physics && (t3 = true), this.options = e3, this.id = this.options.id, this.from = this.body.nodes[this.options.from], this.to = this.body.nodes[this.options.to], this.setupSupportNode(), this.connect(), true === t3 && (this.via.setOptions({ physics: this.options.physics }), this.positionBezierNode());
          } }, { key: "connect", value: function() {
            this.from = this.body.nodes[this.options.from], this.to = this.body.nodes[this.options.to], void 0 === this.from || void 0 === this.to || false === this.options.physics ? this.via.setOptions({ physics: false }) : this.from.id === this.to.id ? this.via.setOptions({ physics: false }) : this.via.setOptions({ physics: true });
          } }, { key: "cleanup", value: function() {
            return this.body.emitter.off("_repositionBezierNodes", this._boundFunction), void 0 !== this.via && (delete this.body.nodes[this.via.id], this.via = void 0, true);
          } }, { key: "setupSupportNode", value: function() {
            if (void 0 === this.via) {
              var e3 = "edgeId:" + this.id, t3 = this.body.functions.createNode({ id: e3, shape: "circle", physics: true, hidden: true });
              this.body.nodes[e3] = t3, this.via = t3, this.via.parentEdgeId = this.id, this.positionBezierNode();
            }
          } }, { key: "positionBezierNode", value: function() {
            void 0 !== this.via && void 0 !== this.from && void 0 !== this.to ? (this.via.x = 0.5 * (this.from.x + this.to.x), this.via.y = 0.5 * (this.from.y + this.to.y)) : void 0 !== this.via && (this.via.x = 0, this.via.y = 0);
          } }, { key: "_line", value: function(e3, t3, i2) {
            this._bezierCurve(e3, t3, i2);
          } }, { key: "getViaNode", value: function() {
            return this.via;
          } }, { key: "getPoint", value: function(e3) {
            var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.via, i2 = e3, n2 = void 0, o2 = void 0;
            if (this.from === this.to) {
              var r2 = this._getCircleData(this.from), a2 = (0, s.default)(r2, 3), d2 = a2[0], h2 = a2[1], l2 = a2[2], u2 = 2 * Math.PI * (1 - i2);
              n2 = d2 + l2 * Math.sin(u2), o2 = h2 + l2 - l2 * (1 - Math.cos(u2));
            } else
              n2 = Math.pow(1 - i2, 2) * this.fromPoint.x + 2 * i2 * (1 - i2) * t3.x + Math.pow(i2, 2) * this.toPoint.x, o2 = Math.pow(1 - i2, 2) * this.fromPoint.y + 2 * i2 * (1 - i2) * t3.y + Math.pow(i2, 2) * this.toPoint.y;
            return { x: n2, y: o2 };
          } }, { key: "_findBorderPosition", value: function(e3, t3) {
            return this._findBorderPositionBezier(e3, t3, this.via);
          } }, { key: "_getDistanceToEdge", value: function(e3, t3, i2, n2, o2, s2) {
            return this._getDistanceToBezierEdge(e3, t3, i2, n2, o2, s2, this.via);
          } }]), t2;
        }(y.default);
        t.default = m;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(2), s = n(o), r = i(0), a = n(r), d = i(1), h = n(d), l = i(3), u = n(l), c = i(4), f = n(c), p = i(56), v = n(p), g = function(e2) {
          function t2(e3, i2, n2) {
            return (0, a.default)(this, t2), (0, u.default)(this, (t2.__proto__ || (0, s.default)(t2)).call(this, e3, i2, n2));
          }
          return (0, f.default)(t2, e2), (0, h.default)(t2, [{ key: "_line", value: function(e3, t3, i2) {
            this._bezierCurve(e3, t3, i2);
          } }, { key: "getViaNode", value: function() {
            return this._getViaCoordinates();
          } }, { key: "_getViaCoordinates", value: function() {
            var e3 = void 0, t3 = void 0, i2 = this.options.smooth.roundness, n2 = this.options.smooth.type, o2 = Math.abs(this.from.x - this.to.x), s2 = Math.abs(this.from.y - this.to.y);
            if ("discrete" === n2 || "diagonalCross" === n2) {
              var r2 = void 0, a2 = void 0;
              r2 = a2 = o2 <= s2 ? i2 * s2 : i2 * o2, this.from.x > this.to.x && (r2 = -r2), this.from.y >= this.to.y && (a2 = -a2), e3 = this.from.x + r2, t3 = this.from.y + a2, "discrete" === n2 && (o2 <= s2 ? e3 = o2 < i2 * s2 ? this.from.x : e3 : t3 = s2 < i2 * o2 ? this.from.y : t3);
            } else if ("straightCross" === n2) {
              var d2 = (1 - i2) * o2, h2 = (1 - i2) * s2;
              o2 <= s2 ? (d2 = 0, this.from.y < this.to.y && (h2 = -h2)) : (this.from.x < this.to.x && (d2 = -d2), h2 = 0), e3 = this.to.x + d2, t3 = this.to.y + h2;
            } else if ("horizontal" === n2) {
              var l2 = (1 - i2) * o2;
              this.from.x < this.to.x && (l2 = -l2), e3 = this.to.x + l2, t3 = this.from.y;
            } else if ("vertical" === n2) {
              var u2 = (1 - i2) * s2;
              this.from.y < this.to.y && (u2 = -u2), e3 = this.from.x, t3 = this.to.y + u2;
            } else if ("curvedCW" === n2) {
              o2 = this.to.x - this.from.x, s2 = this.from.y - this.to.y;
              var c2 = Math.sqrt(o2 * o2 + s2 * s2), f2 = Math.PI, p2 = Math.atan2(s2, o2), v2 = (p2 + (0.5 * i2 + 0.5) * f2) % (2 * f2);
              e3 = this.from.x + (0.5 * i2 + 0.5) * c2 * Math.sin(v2), t3 = this.from.y + (0.5 * i2 + 0.5) * c2 * Math.cos(v2);
            } else if ("curvedCCW" === n2) {
              o2 = this.to.x - this.from.x, s2 = this.from.y - this.to.y;
              var g2 = Math.sqrt(o2 * o2 + s2 * s2), y = Math.PI, m = Math.atan2(s2, o2), b = (m + (0.5 * -i2 + 0.5) * y) % (2 * y);
              e3 = this.from.x + (0.5 * i2 + 0.5) * g2 * Math.sin(b), t3 = this.from.y + (0.5 * i2 + 0.5) * g2 * Math.cos(b);
            } else {
              var _ = void 0, w = void 0;
              _ = w = o2 <= s2 ? i2 * s2 : i2 * o2, this.from.x > this.to.x && (_ = -_), this.from.y >= this.to.y && (w = -w), e3 = this.from.x + _, t3 = this.from.y + w, o2 <= s2 ? e3 = this.from.x <= this.to.x ? this.to.x < e3 ? this.to.x : e3 : this.to.x > e3 ? this.to.x : e3 : t3 = this.from.y >= this.to.y ? this.to.y > t3 ? this.to.y : t3 : this.to.y < t3 ? this.to.y : t3;
            }
            return { x: e3, y: t3 };
          } }, { key: "_findBorderPosition", value: function(e3, t3) {
            var i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
            return this._findBorderPositionBezier(e3, t3, i2.via);
          } }, { key: "_getDistanceToEdge", value: function(e3, t3, i2, n2, o2, s2) {
            var r2 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : this._getViaCoordinates();
            return this._getDistanceToBezierEdge(e3, t3, i2, n2, o2, s2, r2);
          } }, { key: "getPoint", value: function(e3) {
            var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this._getViaCoordinates(), i2 = e3;
            return { x: Math.pow(1 - i2, 2) * this.fromPoint.x + 2 * i2 * (1 - i2) * t3.x + Math.pow(i2, 2) * this.toPoint.x, y: Math.pow(1 - i2, 2) * this.fromPoint.y + 2 * i2 * (1 - i2) * t3.y + Math.pow(i2, 2) * this.toPoint.y };
          } }]), t2;
        }(v.default);
        t.default = g;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(2), s = n(o), r = i(0), a = n(r), d = i(1), h = n(d), l = i(3), u = n(l), c = i(4), f = n(c), p = i(78), v = n(p), g = function(e2) {
          function t2(e3, i2, n2) {
            return (0, a.default)(this, t2), (0, u.default)(this, (t2.__proto__ || (0, s.default)(t2)).call(this, e3, i2, n2));
          }
          return (0, f.default)(t2, e2), (0, h.default)(t2, [{ key: "_line", value: function(e3, t3) {
            e3.beginPath(), e3.moveTo(this.fromPoint.x, this.fromPoint.y), e3.lineTo(this.toPoint.x, this.toPoint.y), this.enableShadow(e3, t3), e3.stroke(), this.disableShadow(e3, t3);
          } }, { key: "getViaNode", value: function() {
          } }, { key: "getPoint", value: function(e3) {
            return { x: (1 - e3) * this.fromPoint.x + e3 * this.toPoint.x, y: (1 - e3) * this.fromPoint.y + e3 * this.toPoint.y };
          } }, { key: "_findBorderPosition", value: function(e3, t3) {
            var i2 = this.to, n2 = this.from;
            e3.id === this.from.id && (i2 = this.from, n2 = this.to);
            var o2 = Math.atan2(i2.y - n2.y, i2.x - n2.x), s2 = i2.x - n2.x, r2 = i2.y - n2.y, a2 = Math.sqrt(s2 * s2 + r2 * r2), d2 = e3.distanceToBorder(t3, o2), h2 = (a2 - d2) / a2, l2 = {};
            return l2.x = (1 - h2) * n2.x + h2 * i2.x, l2.y = (1 - h2) * n2.y + h2 * i2.y, l2;
          } }, { key: "_getDistanceToEdge", value: function(e3, t3, i2, n2, o2, s2) {
            return this._getDistanceToLine(e3, t3, i2, n2, o2, s2);
          } }]), t2;
        }(v.default);
        t.default = g;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(10), s = n(o), r = i(0), a = n(r), d = i(1), h = n(d), l = i(80).default, u = i(170).default, c = i(171).default, f = i(172).default, p = i(173).default, v = i(81).default, g = i(174).default, y = i(175).default, m = i(5), b = i(79).default, _ = function() {
          function e2(t2) {
            (0, a.default)(this, e2), this.body = t2, this.physicsBody = { physicsNodeIndices: [], physicsEdgeIndices: [], forces: {}, velocities: {} }, this.physicsEnabled = true, this.simulationInterval = 1e3 / 60, this.requiresTimeout = true, this.previousStates = {}, this.referenceState = {}, this.freezeCache = {}, this.renderTimer = void 0, this.adaptiveTimestep = false, this.adaptiveTimestepEnabled = false, this.adaptiveCounter = 0, this.adaptiveInterval = 3, this.stabilized = false, this.startedStabilization = false, this.stabilizationIterations = 0, this.ready = false, this.options = {}, this.defaultOptions = { enabled: true, barnesHut: { theta: 0.5, gravitationalConstant: -2e3, centralGravity: 0.3, springLength: 95, springConstant: 0.04, damping: 0.09, avoidOverlap: 0 }, forceAtlas2Based: { theta: 0.5, gravitationalConstant: -50, centralGravity: 0.01, springConstant: 0.08, springLength: 100, damping: 0.4, avoidOverlap: 0 }, repulsion: { centralGravity: 0.2, springLength: 200, springConstant: 0.05, nodeDistance: 100, damping: 0.09, avoidOverlap: 0 }, hierarchicalRepulsion: { centralGravity: 0, springLength: 100, springConstant: 0.01, nodeDistance: 120, damping: 0.09 }, maxVelocity: 50, minVelocity: 0.75, solver: "barnesHut", stabilization: { enabled: true, iterations: 1e3, updateInterval: 50, onlyDynamicEdges: false, fit: true }, timestep: 0.5, adaptiveTimestep: true }, m.extend(this.options, this.defaultOptions), this.timestep = 0.5, this.layoutFailed = false, this.bindEventListeners();
          }
          return (0, h.default)(e2, [{ key: "bindEventListeners", value: function() {
            var e3 = this;
            this.body.emitter.on("initPhysics", function() {
              e3.initPhysics();
            }), this.body.emitter.on("_layoutFailed", function() {
              e3.layoutFailed = true;
            }), this.body.emitter.on("resetPhysics", function() {
              e3.stopSimulation(), e3.ready = false;
            }), this.body.emitter.on("disablePhysics", function() {
              e3.physicsEnabled = false, e3.stopSimulation();
            }), this.body.emitter.on("restorePhysics", function() {
              e3.setOptions(e3.options), true === e3.ready && e3.startSimulation();
            }), this.body.emitter.on("startSimulation", function() {
              true === e3.ready && e3.startSimulation();
            }), this.body.emitter.on("stopSimulation", function() {
              e3.stopSimulation();
            }), this.body.emitter.on("destroy", function() {
              e3.stopSimulation(false), e3.body.emitter.off();
            }), this.body.emitter.on("_dataChanged", function() {
              e3.updatePhysicsData();
            });
          } }, { key: "setOptions", value: function(e3) {
            void 0 !== e3 && (false === e3 ? (this.options.enabled = false, this.physicsEnabled = false, this.stopSimulation()) : true === e3 ? (this.options.enabled = true, this.physicsEnabled = true, this.startSimulation()) : (this.physicsEnabled = true, m.selectiveNotDeepExtend(["stabilization"], this.options, e3), m.mergeOptions(this.options, e3, "stabilization"), void 0 === e3.enabled && (this.options.enabled = true), false === this.options.enabled && (this.physicsEnabled = false, this.stopSimulation()), this.timestep = this.options.timestep)), this.init();
          } }, { key: "init", value: function() {
            var e3;
            "forceAtlas2Based" === this.options.solver ? (e3 = this.options.forceAtlas2Based, this.nodesSolver = new g(this.body, this.physicsBody, e3), this.edgesSolver = new f(this.body, this.physicsBody, e3), this.gravitySolver = new y(this.body, this.physicsBody, e3)) : "repulsion" === this.options.solver ? (e3 = this.options.repulsion, this.nodesSolver = new u(this.body, this.physicsBody, e3), this.edgesSolver = new f(this.body, this.physicsBody, e3), this.gravitySolver = new v(this.body, this.physicsBody, e3)) : "hierarchicalRepulsion" === this.options.solver ? (e3 = this.options.hierarchicalRepulsion, this.nodesSolver = new c(this.body, this.physicsBody, e3), this.edgesSolver = new p(this.body, this.physicsBody, e3), this.gravitySolver = new v(this.body, this.physicsBody, e3)) : (e3 = this.options.barnesHut, this.nodesSolver = new l(this.body, this.physicsBody, e3), this.edgesSolver = new f(this.body, this.physicsBody, e3), this.gravitySolver = new v(this.body, this.physicsBody, e3)), this.modelOptions = e3;
          } }, { key: "initPhysics", value: function() {
            true === this.physicsEnabled && true === this.options.enabled ? true === this.options.stabilization.enabled ? this.stabilize() : (this.stabilized = false, this.ready = true, this.body.emitter.emit("fit", {}, this.layoutFailed), this.startSimulation()) : (this.ready = true, this.body.emitter.emit("fit"));
          } }, { key: "startSimulation", value: function() {
            true === this.physicsEnabled && true === this.options.enabled ? (this.stabilized = false, this.adaptiveTimestep = false, this.body.emitter.emit("_resizeNodes"), void 0 === this.viewFunction && (this.viewFunction = this.simulationStep.bind(this), this.body.emitter.on("initRedraw", this.viewFunction), this.body.emitter.emit("_startRendering"))) : this.body.emitter.emit("_redraw");
          } }, { key: "stopSimulation", value: function() {
            var e3 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
            this.stabilized = true, true === e3 && this._emitStabilized(), void 0 !== this.viewFunction && (this.body.emitter.off("initRedraw", this.viewFunction), this.viewFunction = void 0, true === e3 && this.body.emitter.emit("_stopRendering"));
          } }, { key: "simulationStep", value: function() {
            var e3 = Date.now();
            this.physicsTick(), (Date.now() - e3 < 0.4 * this.simulationInterval || true === this.runDoubleSpeed) && false === this.stabilized && (this.physicsTick(), this.runDoubleSpeed = true), true === this.stabilized && this.stopSimulation();
          } }, { key: "_emitStabilized", value: function() {
            var e3 = this, t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.stabilizationIterations;
            (this.stabilizationIterations > 1 || true === this.startedStabilization) && setTimeout(function() {
              e3.body.emitter.emit("stabilized", { iterations: t2 }), e3.startedStabilization = false, e3.stabilizationIterations = 0;
            }, 0);
          } }, { key: "physicsStep", value: function() {
            this.gravitySolver.solve(), this.nodesSolver.solve(), this.edgesSolver.solve(), this.moveNodes();
          } }, { key: "adjustTimeStep", value: function() {
            true === this._evaluateStepQuality() ? this.timestep = 1.2 * this.timestep : this.timestep / 1.2 < this.options.timestep ? this.timestep = this.options.timestep : (this.adaptiveCounter = -1, this.timestep = Math.max(this.options.timestep, this.timestep / 1.2));
          } }, { key: "physicsTick", value: function() {
            if (this._startStabilizing(), true !== this.stabilized) {
              if (true === this.adaptiveTimestep && true === this.adaptiveTimestepEnabled) {
                this.adaptiveCounter % this.adaptiveInterval == 0 ? (this.timestep = 2 * this.timestep, this.physicsStep(), this.revert(), this.timestep = 0.5 * this.timestep, this.physicsStep(), this.physicsStep(), this.adjustTimeStep()) : this.physicsStep(), this.adaptiveCounter += 1;
              } else
                this.timestep = this.options.timestep, this.physicsStep();
              true === this.stabilized && this.revert(), this.stabilizationIterations++;
            }
          } }, { key: "updatePhysicsData", value: function() {
            this.physicsBody.forces = {}, this.physicsBody.physicsNodeIndices = [], this.physicsBody.physicsEdgeIndices = [];
            var e3 = this.body.nodes, t2 = this.body.edges;
            for (var i2 in e3)
              e3.hasOwnProperty(i2) && true === e3[i2].options.physics && this.physicsBody.physicsNodeIndices.push(e3[i2].id);
            for (var n2 in t2)
              t2.hasOwnProperty(n2) && true === t2[n2].options.physics && this.physicsBody.physicsEdgeIndices.push(t2[n2].id);
            for (var o2 = 0; o2 < this.physicsBody.physicsNodeIndices.length; o2++) {
              var s2 = this.physicsBody.physicsNodeIndices[o2];
              this.physicsBody.forces[s2] = { x: 0, y: 0 }, void 0 === this.physicsBody.velocities[s2] && (this.physicsBody.velocities[s2] = { x: 0, y: 0 });
            }
            for (var r2 in this.physicsBody.velocities)
              void 0 === e3[r2] && delete this.physicsBody.velocities[r2];
          } }, { key: "revert", value: function() {
            var e3 = (0, s.default)(this.previousStates), t2 = this.body.nodes, i2 = this.physicsBody.velocities;
            this.referenceState = {};
            for (var n2 = 0; n2 < e3.length; n2++) {
              var o2 = e3[n2];
              void 0 !== t2[o2] ? true === t2[o2].options.physics && (this.referenceState[o2] = { positions: { x: t2[o2].x, y: t2[o2].y } }, i2[o2].x = this.previousStates[o2].vx, i2[o2].y = this.previousStates[o2].vy, t2[o2].x = this.previousStates[o2].x, t2[o2].y = this.previousStates[o2].y) : delete this.previousStates[o2];
            }
          } }, { key: "_evaluateStepQuality", value: function() {
            var e3 = void 0, t2 = void 0, i2 = this.body.nodes, n2 = this.referenceState;
            for (var o2 in this.referenceState)
              if (this.referenceState.hasOwnProperty(o2) && void 0 !== i2[o2] && (e3 = i2[o2].x - n2[o2].positions.x, t2 = i2[o2].y - n2[o2].positions.y, Math.sqrt(Math.pow(e3, 2) + Math.pow(t2, 2)) > 0.3))
                return false;
            return true;
          } }, { key: "moveNodes", value: function() {
            for (var e3 = this.physicsBody.physicsNodeIndices, t2 = 0, i2 = 0, n2 = 0; n2 < e3.length; n2++) {
              var o2 = e3[n2], s2 = this._performStep(o2);
              t2 = Math.max(t2, s2), i2 += s2;
            }
            this.adaptiveTimestepEnabled = i2 / e3.length < 5, this.stabilized = t2 < this.options.minVelocity;
          } }, { key: "calculateComponentVelocity", value: function(e3, t2, i2) {
            e3 += (t2 - this.modelOptions.damping * e3) / i2 * this.timestep;
            var n2 = this.options.maxVelocity || 1e9;
            return Math.abs(e3) > n2 && (e3 = e3 > 0 ? n2 : -n2), e3;
          } }, { key: "_performStep", value: function(e3) {
            var t2 = this.body.nodes[e3], i2 = this.physicsBody.forces[e3], n2 = this.physicsBody.velocities[e3];
            return this.previousStates[e3] = { x: t2.x, y: t2.y, vx: n2.x, vy: n2.y }, false === t2.options.fixed.x ? (n2.x = this.calculateComponentVelocity(n2.x, i2.x, t2.options.mass), t2.x += n2.x * this.timestep) : (i2.x = 0, n2.x = 0), false === t2.options.fixed.y ? (n2.y = this.calculateComponentVelocity(n2.y, i2.y, t2.options.mass), t2.y += n2.y * this.timestep) : (i2.y = 0, n2.y = 0), Math.sqrt(Math.pow(n2.x, 2) + Math.pow(n2.y, 2));
          } }, { key: "_freezeNodes", value: function() {
            var e3 = this.body.nodes;
            for (var t2 in e3)
              if (e3.hasOwnProperty(t2) && e3[t2].x && e3[t2].y) {
                var i2 = e3[t2].options.fixed;
                this.freezeCache[t2] = { x: i2.x, y: i2.y }, i2.x = true, i2.y = true;
              }
          } }, { key: "_restoreFrozenNodes", value: function() {
            var e3 = this.body.nodes;
            for (var t2 in e3)
              e3.hasOwnProperty(t2) && void 0 !== this.freezeCache[t2] && (e3[t2].options.fixed.x = this.freezeCache[t2].x, e3[t2].options.fixed.y = this.freezeCache[t2].y);
            this.freezeCache = {};
          } }, { key: "stabilize", value: function() {
            var e3 = this, t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.options.stabilization.iterations;
            if ("number" != typeof t2 && (t2 = this.options.stabilization.iterations, console.log("The stabilize method needs a numeric amount of iterations. Switching to default: ", t2)), 0 === this.physicsBody.physicsNodeIndices.length)
              return void (this.ready = true);
            this.adaptiveTimestep = this.options.adaptiveTimestep, this.body.emitter.emit("_resizeNodes"), this.stopSimulation(), this.stabilized = false, this.body.emitter.emit("_blockRedraw"), this.targetIterations = t2, true === this.options.stabilization.onlyDynamicEdges && this._freezeNodes(), this.stabilizationIterations = 0, setTimeout(function() {
              return e3._stabilizationBatch();
            }, 0);
          } }, { key: "_startStabilizing", value: function() {
            return true !== this.startedStabilization && (this.body.emitter.emit("startStabilizing"), this.startedStabilization = true, true);
          } }, { key: "_stabilizationBatch", value: function() {
            var e3 = this, t2 = function() {
              return false === e3.stabilized && e3.stabilizationIterations < e3.targetIterations;
            }, i2 = function() {
              e3.body.emitter.emit("stabilizationProgress", { iterations: e3.stabilizationIterations, total: e3.targetIterations });
            };
            this._startStabilizing() && i2();
            for (var n2 = 0; t2() && n2 < this.options.stabilization.updateInterval; )
              this.physicsTick(), n2++;
            i2(), t2() ? setTimeout(this._stabilizationBatch.bind(this), 0) : this._finalizeStabilization();
          } }, { key: "_finalizeStabilization", value: function() {
            this.body.emitter.emit("_allowRedraw"), true === this.options.stabilization.fit && this.body.emitter.emit("fit"), true === this.options.stabilization.onlyDynamicEdges && this._restoreFrozenNodes(), this.body.emitter.emit("stabilizationIterationsDone"), this.body.emitter.emit("_requestRedraw"), true === this.stabilized ? this._emitStabilized() : this.startSimulation(), this.ready = true;
          } }, { key: "_drawForces", value: function(e3) {
            for (var t2 = 0; t2 < this.physicsBody.physicsNodeIndices.length; t2++) {
              var i2 = this.physicsBody.physicsNodeIndices[t2], n2 = this.body.nodes[i2], o2 = this.physicsBody.forces[i2], s2 = Math.sqrt(Math.pow(o2.x, 2) + Math.pow(o2.x, 2)), r2 = Math.min(Math.max(5, s2), 15), a2 = 3 * r2, d2 = m.HSVToHex((180 - 180 * Math.min(1, Math.max(0, 0.03 * s2))) / 360, 1, 1), h2 = { x: n2.x + 20 * o2.x, y: n2.y + 20 * o2.y };
              e3.lineWidth = r2, e3.strokeStyle = d2, e3.beginPath(), e3.moveTo(n2.x, n2.y), e3.lineTo(h2.x, h2.y), e3.stroke();
              var l2 = Math.atan2(o2.y, o2.x);
              e3.fillStyle = d2, b.draw(e3, { type: "arrow", point: h2, angle: l2, length: a2 }), e3.fill();
            }
          } }]), e2;
        }();
        t.default = _;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(0), s = n(o), r = i(1), a = n(r), d = function() {
          function e2(t2, i2, n2) {
            (0, s.default)(this, e2), this.body = t2, this.physicsBody = i2, this.setOptions(n2);
          }
          return (0, a.default)(e2, [{ key: "setOptions", value: function(e3) {
            this.options = e3;
          } }, { key: "solve", value: function() {
            for (var e3, t2, i2, n2, o2, s2, r2, a2, d2 = this.body.nodes, h = this.physicsBody.physicsNodeIndices, l = this.physicsBody.forces, u = this.options.nodeDistance, c = -2 / 3 / u, f = 0; f < h.length - 1; f++) {
              r2 = d2[h[f]];
              for (var p = f + 1; p < h.length; p++)
                a2 = d2[h[p]], e3 = a2.x - r2.x, t2 = a2.y - r2.y, i2 = Math.sqrt(e3 * e3 + t2 * t2), 0 === i2 && (i2 = 0.1 * Math.random(), e3 = i2), i2 < 2 * u && (s2 = i2 < 0.5 * u ? 1 : c * i2 + 4 / 3, s2 /= i2, n2 = e3 * s2, o2 = t2 * s2, l[r2.id].x -= n2, l[r2.id].y -= o2, l[a2.id].x += n2, l[a2.id].y += o2);
            }
          } }]), e2;
        }();
        t.default = d;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(0), s = n(o), r = i(1), a = n(r), d = function() {
          function e2(t2, i2, n2) {
            (0, s.default)(this, e2), this.body = t2, this.physicsBody = i2, this.setOptions(n2);
          }
          return (0, a.default)(e2, [{ key: "setOptions", value: function(e3) {
            this.options = e3;
          } }, { key: "solve", value: function() {
            var e3, t2, i2, n2, o2, s2, r2, a2, d2, h, l = this.body.nodes, u = this.physicsBody.physicsNodeIndices, c = this.physicsBody.forces, f = this.options.nodeDistance;
            for (d2 = 0; d2 < u.length - 1; d2++)
              for (r2 = l[u[d2]], h = d2 + 1; h < u.length; h++)
                if (a2 = l[u[h]], r2.level === a2.level) {
                  e3 = a2.x - r2.x, t2 = a2.y - r2.y, i2 = Math.sqrt(e3 * e3 + t2 * t2);
                  s2 = i2 < f ? -Math.pow(0.05 * i2, 2) + Math.pow(0.05 * f, 2) : 0, 0 === i2 ? i2 = 0.01 : s2 /= i2, n2 = e3 * s2, o2 = t2 * s2, c[r2.id].x -= n2, c[r2.id].y -= o2, c[a2.id].x += n2, c[a2.id].y += o2;
                }
          } }]), e2;
        }();
        t.default = d;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(0), s = n(o), r = i(1), a = n(r), d = function() {
          function e2(t2, i2, n2) {
            (0, s.default)(this, e2), this.body = t2, this.physicsBody = i2, this.setOptions(n2);
          }
          return (0, a.default)(e2, [{ key: "setOptions", value: function(e3) {
            this.options = e3;
          } }, { key: "solve", value: function() {
            for (var e3 = void 0, t2 = void 0, i2 = this.physicsBody.physicsEdgeIndices, n2 = this.body.edges, o2 = void 0, s2 = void 0, r2 = void 0, a2 = 0; a2 < i2.length; a2++)
              t2 = n2[i2[a2]], true === t2.connected && t2.toId !== t2.fromId && void 0 !== this.body.nodes[t2.toId] && void 0 !== this.body.nodes[t2.fromId] && (void 0 !== t2.edgeType.via ? (e3 = void 0 === t2.options.length ? this.options.springLength : t2.options.length, o2 = t2.to, s2 = t2.edgeType.via, r2 = t2.from, this._calculateSpringForce(o2, s2, 0.5 * e3), this._calculateSpringForce(s2, r2, 0.5 * e3)) : (e3 = void 0 === t2.options.length ? 1.5 * this.options.springLength : t2.options.length, this._calculateSpringForce(t2.from, t2.to, e3)));
          } }, { key: "_calculateSpringForce", value: function(e3, t2, i2) {
            var n2 = e3.x - t2.x, o2 = e3.y - t2.y, s2 = Math.max(Math.sqrt(n2 * n2 + o2 * o2), 0.01), r2 = this.options.springConstant * (i2 - s2) / s2, a2 = n2 * r2, d2 = o2 * r2;
            void 0 !== this.physicsBody.forces[e3.id] && (this.physicsBody.forces[e3.id].x += a2, this.physicsBody.forces[e3.id].y += d2), void 0 !== this.physicsBody.forces[t2.id] && (this.physicsBody.forces[t2.id].x -= a2, this.physicsBody.forces[t2.id].y -= d2);
          } }]), e2;
        }();
        t.default = d;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(0), s = n(o), r = i(1), a = n(r), d = function() {
          function e2(t2, i2, n2) {
            (0, s.default)(this, e2), this.body = t2, this.physicsBody = i2, this.setOptions(n2);
          }
          return (0, a.default)(e2, [{ key: "setOptions", value: function(e3) {
            this.options = e3;
          } }, { key: "solve", value: function() {
            for (var e3, t2, i2, n2, o2, s2, r2, a2, d2 = this.body.edges, h = this.physicsBody.physicsEdgeIndices, l = this.physicsBody.physicsNodeIndices, u = this.physicsBody.forces, c = 0; c < l.length; c++) {
              var f = l[c];
              u[f].springFx = 0, u[f].springFy = 0;
            }
            for (var p = 0; p < h.length; p++)
              t2 = d2[h[p]], true === t2.connected && (e3 = void 0 === t2.options.length ? this.options.springLength : t2.options.length, i2 = t2.from.x - t2.to.x, n2 = t2.from.y - t2.to.y, a2 = Math.sqrt(i2 * i2 + n2 * n2), a2 = 0 === a2 ? 0.01 : a2, r2 = this.options.springConstant * (e3 - a2) / a2, o2 = i2 * r2, s2 = n2 * r2, t2.to.level != t2.from.level ? (void 0 !== u[t2.toId] && (u[t2.toId].springFx -= o2, u[t2.toId].springFy -= s2), void 0 !== u[t2.fromId] && (u[t2.fromId].springFx += o2, u[t2.fromId].springFy += s2)) : (void 0 !== u[t2.toId] && (u[t2.toId].x -= 0.5 * o2, u[t2.toId].y -= 0.5 * s2), void 0 !== u[t2.fromId] && (u[t2.fromId].x += 0.5 * o2, u[t2.fromId].y += 0.5 * s2)));
            r2 = 1;
            for (var v, g, y = 0; y < l.length; y++) {
              var m = l[y];
              v = Math.min(r2, Math.max(-r2, u[m].springFx)), g = Math.min(r2, Math.max(-r2, u[m].springFy)), u[m].x += v, u[m].y += g;
            }
            for (var b = 0, _ = 0, w = 0; w < l.length; w++) {
              var k = l[w];
              b += u[k].x, _ += u[k].y;
            }
            for (var x = b / l.length, O = _ / l.length, M = 0; M < l.length; M++) {
              var E = l[M];
              u[E].x -= x, u[E].y -= O;
            }
          } }]), e2;
        }();
        t.default = d;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(2), s = n(o), r = i(0), a = n(r), d = i(1), h = n(d), l = i(3), u = n(l), c = i(4), f = n(c), p = i(80), v = n(p), g = function(e2) {
          function t2(e3, i2, n2) {
            return (0, a.default)(this, t2), (0, u.default)(this, (t2.__proto__ || (0, s.default)(t2)).call(this, e3, i2, n2));
          }
          return (0, f.default)(t2, e2), (0, h.default)(t2, [{ key: "_calculateForces", value: function(e3, t3, i2, n2, o2) {
            0 === e3 && (e3 = 0.1 * Math.random(), t3 = e3), this.overlapAvoidanceFactor < 1 && n2.shape.radius && (e3 = Math.max(0.1 + this.overlapAvoidanceFactor * n2.shape.radius, e3 - n2.shape.radius));
            var s2 = n2.edges.length + 1, r2 = this.options.gravitationalConstant * o2.mass * n2.options.mass * s2 / Math.pow(e3, 2), a2 = t3 * r2, d2 = i2 * r2;
            this.physicsBody.forces[n2.id].x += a2, this.physicsBody.forces[n2.id].y += d2;
          } }]), t2;
        }(v.default);
        t.default = g;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(2), s = n(o), r = i(0), a = n(r), d = i(1), h = n(d), l = i(3), u = n(l), c = i(4), f = n(c), p = i(81), v = n(p), g = function(e2) {
          function t2(e3, i2, n2) {
            return (0, a.default)(this, t2), (0, u.default)(this, (t2.__proto__ || (0, s.default)(t2)).call(this, e3, i2, n2));
          }
          return (0, f.default)(t2, e2), (0, h.default)(t2, [{ key: "_calculateForces", value: function(e3, t3, i2, n2, o2) {
            if (e3 > 0) {
              var s2 = o2.edges.length + 1, r2 = this.options.centralGravity * s2 * o2.options.mass;
              n2[o2.id].x = t3 * r2, n2[o2.id].y = i2 * r2;
            }
          } }]), t2;
        }(v.default);
        t.default = g;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(10), s = n(o), r = i(7), a = n(r), d = i(0), h = n(d), l = i(1), u = n(l), c = i(5), f = i(57).default, p = i(177).default, v = i(55).default, g = i(33).default, y = function() {
          function e2(t2) {
            var i2 = this;
            (0, h.default)(this, e2), this.body = t2, this.clusteredNodes = {}, this.clusteredEdges = {}, this.options = {}, this.defaultOptions = {}, c.extend(this.options, this.defaultOptions), this.body.emitter.on("_resetData", function() {
              i2.clusteredNodes = {}, i2.clusteredEdges = {};
            });
          }
          return (0, u.default)(e2, [{ key: "clusterByHubsize", value: function(e3, t2) {
            void 0 === e3 ? e3 = this._getHubSize() : "object" === (void 0 === e3 ? "undefined" : (0, a.default)(e3)) && (t2 = this._checkOptions(e3), e3 = this._getHubSize());
            for (var i2 = [], n2 = 0; n2 < this.body.nodeIndices.length; n2++) {
              var o2 = this.body.nodes[this.body.nodeIndices[n2]];
              o2.edges.length >= e3 && i2.push(o2.id);
            }
            for (var s2 = 0; s2 < i2.length; s2++)
              this.clusterByConnection(i2[s2], t2, true);
            this.body.emitter.emit("_dataChanged");
          } }, { key: "cluster", value: function() {
            var e3 = this, t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, i2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
            if (void 0 === t2.joinCondition)
              throw new Error("Cannot call clusterByNodeData without a joinCondition function in the options.");
            t2 = this._checkOptions(t2);
            var n2 = {}, o2 = {};
            c.forEach(this.body.nodes, function(i3, s2) {
              var r2 = f.cloneOptions(i3);
              true === t2.joinCondition(r2) && (n2[s2] = i3, c.forEach(i3.edges, function(t3) {
                void 0 === e3.clusteredEdges[t3.id] && (o2[t3.id] = t3);
              }));
            }), this._cluster(n2, o2, t2, i2);
          } }, { key: "clusterByEdgeCount", value: function(e3, t2) {
            var i2 = this, n2 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
            t2 = this._checkOptions(t2);
            for (var o2 = [], r2 = {}, a2 = void 0, d2 = void 0, h2 = void 0, l2 = 0; l2 < this.body.nodeIndices.length; l2++) {
              var u2, c2, p2;
              !function(n3) {
                var l3 = {}, v2 = {}, g2 = i2.body.nodeIndices[n3], y2 = i2.body.nodes[g2];
                if (void 0 === r2[g2]) {
                  h2 = 0, d2 = [];
                  for (var m = 0; m < y2.edges.length; m++)
                    a2 = y2.edges[m], void 0 === i2.clusteredEdges[a2.id] && (a2.toId !== a2.fromId && h2++, d2.push(a2));
                  if (h2 === e3) {
                    u2 = function(e4) {
                      if (void 0 === t2.joinCondition || null === t2.joinCondition)
                        return true;
                      var i3 = f.cloneOptions(e4);
                      return t2.joinCondition(i3);
                    };
                    for (var b = true, _ = 0; _ < d2.length; _++) {
                      a2 = d2[_];
                      var w = i2._getConnectedId(a2, g2);
                      if (!u2(y2)) {
                        b = false;
                        break;
                      }
                      v2[a2.id] = a2, l3[g2] = y2, l3[w] = i2.body.nodes[w], r2[g2] = true;
                    }
                    if ((0, s.default)(l3).length > 0 && (0, s.default)(v2).length > 0 && true === b)
                      if (c2 = function() {
                        for (var e4 = 0; e4 < o2.length; ++e4)
                          for (var t3 in l3)
                            if (void 0 !== o2[e4].nodes[t3])
                              return o2[e4];
                      }, void 0 !== (p2 = c2())) {
                        for (var k in l3)
                          void 0 === p2.nodes[k] && (p2.nodes[k] = l3[k]);
                        for (var x in v2)
                          void 0 === p2.edges[x] && (p2.edges[x] = v2[x]);
                      } else
                        o2.push({ nodes: l3, edges: v2 });
                  }
                }
              }(l2);
            }
            for (var l2 = 0; l2 < o2.length; l2++)
              this._cluster(o2[l2].nodes, o2[l2].edges, t2, false);
            true === n2 && this.body.emitter.emit("_dataChanged");
          } }, { key: "clusterOutliers", value: function(e3) {
            var t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
            this.clusterByEdgeCount(1, e3, t2);
          } }, { key: "clusterBridges", value: function(e3) {
            var t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
            this.clusterByEdgeCount(2, e3, t2);
          } }, { key: "clusterByConnection", value: function(e3, t2) {
            var i2 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
            if (void 0 === e3)
              throw new Error("No nodeId supplied to clusterByConnection!");
            if (void 0 === this.body.nodes[e3])
              throw new Error("The nodeId given to clusterByConnection does not exist!");
            var n2 = this.body.nodes[e3];
            t2 = this._checkOptions(t2, n2), void 0 === t2.clusterNodeProperties.x && (t2.clusterNodeProperties.x = n2.x), void 0 === t2.clusterNodeProperties.y && (t2.clusterNodeProperties.y = n2.y), void 0 === t2.clusterNodeProperties.fixed && (t2.clusterNodeProperties.fixed = {}, t2.clusterNodeProperties.fixed.x = n2.options.fixed.x, t2.clusterNodeProperties.fixed.y = n2.options.fixed.y);
            var o2 = {}, r2 = {}, a2 = n2.id, d2 = f.cloneOptions(n2);
            o2[a2] = n2;
            for (var h2 = 0; h2 < n2.edges.length; h2++) {
              var l2 = n2.edges[h2];
              if (void 0 === this.clusteredEdges[l2.id]) {
                var u2 = this._getConnectedId(l2, a2);
                if (void 0 === this.clusteredNodes[u2])
                  if (u2 !== a2)
                    if (void 0 === t2.joinCondition)
                      r2[l2.id] = l2, o2[u2] = this.body.nodes[u2];
                    else {
                      var c2 = f.cloneOptions(this.body.nodes[u2]);
                      true === t2.joinCondition(d2, c2) && (r2[l2.id] = l2, o2[u2] = this.body.nodes[u2]);
                    }
                  else
                    r2[l2.id] = l2;
              }
            }
            var p2 = (0, s.default)(o2).map(function(e4) {
              return o2[e4].id;
            });
            for (v2 in o2)
              if (o2.hasOwnProperty(v2))
                for (var v2 = o2[v2], g2 = 0; g2 < v2.edges.length; g2++) {
                  var y2 = v2.edges[g2];
                  p2.indexOf(this._getConnectedId(y2, v2.id)) > -1 && (r2[y2.id] = y2);
                }
            this._cluster(o2, r2, t2, i2);
          } }, { key: "_createClusterEdges", value: function(e3, t2, i2, n2) {
            for (var o2 = void 0, r2 = void 0, a2 = void 0, d2 = void 0, h2 = void 0, l2 = void 0, u2 = (0, s.default)(e3), c2 = [], f2 = 0; f2 < u2.length; f2++) {
              r2 = u2[f2], a2 = e3[r2];
              for (var p2 = 0; p2 < a2.edges.length; p2++)
                o2 = a2.edges[p2], void 0 === this.clusteredEdges[o2.id] && (o2.toId == o2.fromId ? t2[o2.id] = o2 : o2.toId == r2 ? (d2 = i2.id, h2 = o2.fromId, l2 = h2) : (d2 = o2.toId, h2 = i2.id, l2 = d2), void 0 === e3[l2] && c2.push({ edge: o2, fromId: h2, toId: d2 }));
            }
            for (var v2 = [], g2 = 0; g2 < c2.length; g2++) {
              var y2 = c2[g2], m = y2.edge, b = function(e4) {
                for (var t3 = 0; t3 < v2.length; t3++) {
                  var i3 = v2[t3], n3 = e4.fromId === i3.fromId && e4.toId === i3.toId, o3 = e4.fromId === i3.toId && e4.toId === i3.fromId;
                  if (n3 || o3)
                    return i3;
                }
                return null;
              }(y2);
              null === b ? (b = this._createClusteredEdge(y2.fromId, y2.toId, m, n2), v2.push(b)) : b.clusteringEdgeReplacingIds.push(m.id), this.body.edges[m.id].edgeReplacedById = b.id, this._backupEdgeOptions(m), m.setOptions({ physics: false });
            }
          } }, { key: "_checkOptions", value: function() {
            var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            return void 0 === e3.clusterEdgeProperties && (e3.clusterEdgeProperties = {}), void 0 === e3.clusterNodeProperties && (e3.clusterNodeProperties = {}), e3;
          } }, { key: "_cluster", value: function(e3, t2, i2) {
            var n2 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3], o2 = [];
            for (var r2 in e3)
              e3.hasOwnProperty(r2) && void 0 !== this.clusteredNodes[r2] && o2.push(r2);
            for (var a2 = 0; a2 < o2.length; ++a2)
              delete e3[o2[a2]];
            if (0 != (0, s.default)(e3).length && (1 != (0, s.default)(e3).length || 1 == i2.clusterNodeProperties.allowSingleNodeCluster)) {
              var d2 = c.deepExtend({}, i2.clusterNodeProperties);
              if (void 0 !== i2.processProperties) {
                var h2 = [];
                for (var l2 in e3)
                  if (e3.hasOwnProperty(l2)) {
                    var u2 = f.cloneOptions(e3[l2]);
                    h2.push(u2);
                  }
                var v2 = [];
                for (var g2 in t2)
                  if (t2.hasOwnProperty(g2) && "clusterEdge:" !== g2.substr(0, 12)) {
                    var y2 = f.cloneOptions(t2[g2], "edge");
                    v2.push(y2);
                  }
                if (!(d2 = i2.processProperties(d2, h2, v2)))
                  throw new Error("The processProperties function does not return properties!");
              }
              void 0 === d2.id && (d2.id = "cluster:" + c.randomUUID());
              var m = d2.id;
              void 0 === d2.label && (d2.label = "cluster");
              var b = void 0;
              void 0 === d2.x && (b = this._getClusterPosition(e3), d2.x = b.x), void 0 === d2.y && (void 0 === b && (b = this._getClusterPosition(e3)), d2.y = b.y), d2.id = m;
              var _ = this.body.functions.createNode(d2, p);
              _.containedNodes = e3, _.containedEdges = t2, _.clusterEdgeProperties = i2.clusterEdgeProperties, this.body.nodes[d2.id] = _, this._clusterEdges(e3, t2, d2, i2.clusterEdgeProperties), d2.id = void 0, true === n2 && this.body.emitter.emit("_dataChanged");
            }
          } }, { key: "_backupEdgeOptions", value: function(e3) {
            void 0 === this.clusteredEdges[e3.id] && (this.clusteredEdges[e3.id] = { physics: e3.options.physics });
          } }, { key: "_restoreEdge", value: function(e3) {
            var t2 = this.clusteredEdges[e3.id];
            void 0 !== t2 && (e3.setOptions({ physics: t2.physics }), delete this.clusteredEdges[e3.id]);
          } }, { key: "isCluster", value: function(e3) {
            return void 0 !== this.body.nodes[e3] ? true === this.body.nodes[e3].isCluster : (console.log("Node does not exist."), false);
          } }, { key: "_getClusterPosition", value: function(e3) {
            for (var t2 = (0, s.default)(e3), i2 = e3[t2[0]].x, n2 = e3[t2[0]].x, o2 = e3[t2[0]].y, r2 = e3[t2[0]].y, a2 = void 0, d2 = 1; d2 < t2.length; d2++)
              a2 = e3[t2[d2]], i2 = a2.x < i2 ? a2.x : i2, n2 = a2.x > n2 ? a2.x : n2, o2 = a2.y < o2 ? a2.y : o2, r2 = a2.y > r2 ? a2.y : r2;
            return { x: 0.5 * (i2 + n2), y: 0.5 * (o2 + r2) };
          } }, { key: "openCluster", value: function(e3, t2) {
            var i2 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
            if (void 0 === e3)
              throw new Error("No clusterNodeId supplied to openCluster.");
            var n2 = this.body.nodes[e3];
            if (void 0 === n2)
              throw new Error("The clusterNodeId supplied to openCluster does not exist.");
            if (true !== n2.isCluster || void 0 === n2.containedNodes || void 0 === n2.containedEdges)
              throw new Error("The node:" + e3 + " is not a valid cluster.");
            var o2 = this.findNode(e3), s2 = o2.indexOf(e3) - 1;
            if (s2 >= 0) {
              var r2 = o2[s2];
              return this.body.nodes[r2]._openChildCluster(e3), delete this.body.nodes[e3], void (true === i2 && this.body.emitter.emit("_dataChanged"));
            }
            var a2 = n2.containedNodes, d2 = n2.containedEdges;
            if (void 0 !== t2 && void 0 !== t2.releaseFunction && "function" == typeof t2.releaseFunction) {
              var h2 = {}, l2 = { x: n2.x, y: n2.y };
              for (var u2 in a2)
                if (a2.hasOwnProperty(u2)) {
                  var f2 = this.body.nodes[u2];
                  h2[u2] = { x: f2.x, y: f2.y };
                }
              var p2 = t2.releaseFunction(l2, h2);
              for (var v2 in a2)
                if (a2.hasOwnProperty(v2)) {
                  var g2 = this.body.nodes[v2];
                  void 0 !== p2[v2] && (g2.x = void 0 === p2[v2].x ? n2.x : p2[v2].x, g2.y = void 0 === p2[v2].y ? n2.y : p2[v2].y);
                }
            } else
              c.forEach(a2, function(e4) {
                false === e4.options.fixed.x && (e4.x = n2.x), false === e4.options.fixed.y && (e4.y = n2.y);
              });
            for (var y2 in a2)
              if (a2.hasOwnProperty(y2)) {
                var m = this.body.nodes[y2];
                m.vx = n2.vx, m.vy = n2.vy, m.setOptions({ physics: true }), delete this.clusteredNodes[y2];
              }
            for (var b = [], _ = 0; _ < n2.edges.length; _++)
              b.push(n2.edges[_]);
            for (var w = 0; w < b.length; w++) {
              for (var k = b[w], x = this._getConnectedId(k, e3), O = this.clusteredNodes[x], M = 0; M < k.clusteringEdgeReplacingIds.length; M++) {
                var E = k.clusteringEdgeReplacingIds[M], S = this.body.edges[E];
                if (void 0 !== S)
                  if (void 0 !== O) {
                    var D = this.body.nodes[O.clusterId];
                    D.containedEdges[S.id] = S, delete d2[S.id];
                    var C = S.fromId, T = S.toId;
                    S.toId == x ? T = O.clusterId : C = O.clusterId, this._createClusteredEdge(C, T, S, D.clusterEdgeProperties, { hidden: false, physics: true });
                  } else
                    this._restoreEdge(S);
              }
              k.remove();
            }
            for (var P in d2)
              d2.hasOwnProperty(P) && this._restoreEdge(d2[P]);
            delete this.body.nodes[e3], true === i2 && this.body.emitter.emit("_dataChanged");
          } }, { key: "getNodesInCluster", value: function(e3) {
            var t2 = [];
            if (true === this.isCluster(e3)) {
              var i2 = this.body.nodes[e3].containedNodes;
              for (var n2 in i2)
                i2.hasOwnProperty(n2) && t2.push(this.body.nodes[n2].id);
            }
            return t2;
          } }, { key: "findNode", value: function(e3) {
            for (var t2 = [], i2 = 0, n2 = void 0; void 0 !== this.clusteredNodes[e3] && i2 < 100; ) {
              if (void 0 === (n2 = this.body.nodes[e3]))
                return [];
              t2.push(n2.id), e3 = this.clusteredNodes[e3].clusterId, i2++;
            }
            return void 0 === (n2 = this.body.nodes[e3]) ? [] : (t2.push(n2.id), t2.reverse(), t2);
          } }, { key: "updateClusteredNode", value: function(e3, t2) {
            if (void 0 === e3)
              throw new Error("No clusteredNodeId supplied to updateClusteredNode.");
            if (void 0 === t2)
              throw new Error("No newOptions supplied to updateClusteredNode.");
            if (void 0 === this.body.nodes[e3])
              throw new Error("The clusteredNodeId supplied to updateClusteredNode does not exist.");
            this.body.nodes[e3].setOptions(t2), this.body.emitter.emit("_dataChanged");
          } }, { key: "updateEdge", value: function(e3, t2) {
            if (void 0 === e3)
              throw new Error("No startEdgeId supplied to updateEdge.");
            if (void 0 === t2)
              throw new Error("No newOptions supplied to updateEdge.");
            if (void 0 === this.body.edges[e3])
              throw new Error("The startEdgeId supplied to updateEdge does not exist.");
            for (var i2 = this.getClusteredEdges(e3), n2 = 0; n2 < i2.length; n2++) {
              this.body.edges[i2[n2]].setOptions(t2);
            }
            this.body.emitter.emit("_dataChanged");
          } }, { key: "getClusteredEdges", value: function(e3) {
            for (var t2 = [], i2 = 0; void 0 !== e3 && void 0 !== this.body.edges[e3] && i2 < 100; )
              t2.push(this.body.edges[e3].id), e3 = this.body.edges[e3].edgeReplacedById, i2++;
            return t2.reverse(), t2;
          } }, { key: "getBaseEdge", value: function(e3) {
            return this.getBaseEdges(e3)[0];
          } }, { key: "getBaseEdges", value: function(e3) {
            for (var t2 = [e3], i2 = [], n2 = [], o2 = 0; t2.length > 0 && o2 < 100; ) {
              var s2 = t2.pop();
              if (void 0 !== s2) {
                var r2 = this.body.edges[s2];
                if (void 0 !== r2) {
                  o2++;
                  var a2 = r2.clusteringEdgeReplacingIds;
                  if (void 0 === a2)
                    n2.push(s2);
                  else
                    for (var d2 = 0; d2 < a2.length; ++d2) {
                      var h2 = a2[d2];
                      -1 === t2.indexOf(a2) && -1 === i2.indexOf(a2) && t2.push(h2);
                    }
                  i2.push(s2);
                }
              }
            }
            return n2;
          } }, { key: "_getConnectedId", value: function(e3, t2) {
            return e3.toId != t2 ? e3.toId : (e3.fromId, e3.fromId);
          } }, { key: "_getHubSize", value: function() {
            for (var e3 = 0, t2 = 0, i2 = 0, n2 = 0, o2 = 0; o2 < this.body.nodeIndices.length; o2++) {
              var s2 = this.body.nodes[this.body.nodeIndices[o2]];
              s2.edges.length > n2 && (n2 = s2.edges.length), e3 += s2.edges.length, t2 += Math.pow(s2.edges.length, 2), i2 += 1;
            }
            e3 /= i2, t2 /= i2;
            var r2 = t2 - Math.pow(e3, 2), a2 = Math.sqrt(r2), d2 = Math.floor(e3 + 2 * a2);
            return d2 > n2 && (d2 = n2), d2;
          } }, { key: "_createClusteredEdge", value: function(e3, t2, i2, n2, o2) {
            var s2 = f.cloneOptions(i2, "edge");
            c.deepExtend(s2, n2), s2.from = e3, s2.to = t2, s2.id = "clusterEdge:" + c.randomUUID(), void 0 !== o2 && c.deepExtend(s2, o2);
            var r2 = this.body.functions.createEdge(s2);
            return r2.clusteringEdgeReplacingIds = [i2.id], r2.connect(), this.body.edges[r2.id] = r2, r2;
          } }, { key: "_clusterEdges", value: function(e3, t2, i2, n2) {
            if (t2 instanceof v) {
              var o2 = t2, s2 = {};
              s2[o2.id] = o2, t2 = s2;
            }
            if (e3 instanceof g) {
              var r2 = e3, a2 = {};
              a2[r2.id] = r2, e3 = a2;
            }
            if (void 0 === i2 || null === i2)
              throw new Error("_clusterEdges: parameter clusterNode required");
            void 0 === n2 && (n2 = i2.clusterEdgeProperties), this._createClusterEdges(e3, t2, i2, n2);
            for (var d2 in t2)
              if (t2.hasOwnProperty(d2) && void 0 !== this.body.edges[d2]) {
                var h2 = this.body.edges[d2];
                this._backupEdgeOptions(h2), h2.setOptions({ physics: false });
              }
            for (var l2 in e3)
              e3.hasOwnProperty(l2) && (this.clusteredNodes[l2] = { clusterId: i2.id, node: this.body.nodes[l2] }, this.body.nodes[l2].setOptions({ physics: false }));
          } }, { key: "_getClusterNodeForNode", value: function(e3) {
            if (void 0 !== e3) {
              var t2 = this.clusteredNodes[e3];
              if (void 0 !== t2) {
                var i2 = t2.clusterId;
                if (void 0 !== i2)
                  return this.body.nodes[i2];
              }
            }
          } }, { key: "_filter", value: function(e3, t2) {
            var i2 = [];
            return c.forEach(e3, function(e4) {
              t2(e4) && i2.push(e4);
            }), i2;
          } }, { key: "_updateState", value: function() {
            var e3 = this, t2 = void 0, i2 = [], n2 = [], o2 = function(t3) {
              c.forEach(e3.body.nodes, function(e4) {
                true === e4.isCluster && t3(e4);
              });
            };
            for (t2 in this.clusteredNodes)
              if (this.clusteredNodes.hasOwnProperty(t2)) {
                var r2 = this.body.nodes[t2];
                void 0 === r2 && i2.push(t2);
              }
            o2(function(e4) {
              for (var t3 = 0; t3 < i2.length; t3++)
                delete e4.containedNodes[i2[t3]];
            });
            for (var a2 = 0; a2 < i2.length; a2++)
              delete this.clusteredNodes[i2[a2]];
            c.forEach(this.clusteredEdges, function(t3) {
              var i3 = e3.body.edges[t3];
              void 0 !== i3 && i3.endPointsValid() || n2.push(t3);
            }), o2(function(e4) {
              c.forEach(e4.containedEdges, function(e5, t3) {
                e5.endPointsValid() || -1 !== n2.indexOf(t3) || n2.push(t3);
              });
            }), c.forEach(this.body.edges, function(t3, i3) {
              var o3 = true, s2 = t3.clusteringEdgeReplacingIds;
              if (void 0 !== s2) {
                var r3 = 0;
                c.forEach(s2, function(t4) {
                  var i4 = e3.body.edges[t4];
                  void 0 !== i4 && i4.endPointsValid() && (r3 += 1);
                }), o3 = r3 > 0;
              }
              t3.endPointsValid() && o3 || n2.push(i3);
            }), o2(function(t3) {
              c.forEach(n2, function(i3) {
                delete t3.containedEdges[i3], c.forEach(t3.edges, function(o3, s2) {
                  if (o3.id === i3)
                    return void (t3.edges[s2] = null);
                  o3.clusteringEdgeReplacingIds = e3._filter(o3.clusteringEdgeReplacingIds, function(e4) {
                    return -1 === n2.indexOf(e4);
                  });
                }), t3.edges = e3._filter(t3.edges, function(e4) {
                  return null !== e4;
                });
              });
            }), c.forEach(n2, function(t3) {
              delete e3.clusteredEdges[t3];
            }), c.forEach(n2, function(t3) {
              delete e3.body.edges[t3];
            });
            var d2 = (0, s.default)(this.body.edges);
            c.forEach(d2, function(t3) {
              var i3 = e3.body.edges[t3], n3 = e3._isClusteredNode(i3.fromId) || e3._isClusteredNode(i3.toId);
              if (n3 !== e3._isClusteredEdge(i3.id)) {
                if (!n3)
                  throw new Error("remove edge from clustering not implemented!");
                var o3 = e3._getClusterNodeForNode(i3.fromId);
                void 0 !== o3 && e3._clusterEdges(e3.body.nodes[i3.fromId], i3, o3);
                var s2 = e3._getClusterNodeForNode(i3.toId);
                void 0 !== s2 && e3._clusterEdges(e3.body.nodes[i3.toId], i3, s2);
              }
            });
            for (var h2 = false, l2 = true; l2; )
              !function() {
                var t3 = [];
                o2(function(e4) {
                  var i4 = (0, s.default)(e4.containedNodes).length, n3 = true === e4.options.allowSingleNodeCluster;
                  (n3 && i4 < 1 || !n3 && i4 < 2) && t3.push(e4.id);
                });
                for (var i3 = 0; i3 < t3.length; ++i3)
                  e3.openCluster(t3[i3], {}, false);
                l2 = t3.length > 0, h2 = h2 || l2;
              }();
            h2 && this._updateState();
          } }, { key: "_isClusteredNode", value: function(e3) {
            return void 0 !== this.clusteredNodes[e3];
          } }, { key: "_isClusteredEdge", value: function(e3) {
            return void 0 !== this.clusteredEdges[e3];
          } }]), e2;
        }();
        t.default = y;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(2), s = n(o), r = i(0), a = n(r), d = i(1), h = n(d), l = i(3), u = n(l), c = i(4), f = n(c), p = i(5), v = i(33).default, g = function(e2) {
          function t2(e3, i2, n2, o2, r2, d2) {
            (0, a.default)(this, t2);
            var h2 = (0, u.default)(this, (t2.__proto__ || (0, s.default)(t2)).call(this, e3, i2, n2, o2, r2, d2));
            return h2.isCluster = true, h2.containedNodes = {}, h2.containedEdges = {}, h2;
          }
          return (0, f.default)(t2, e2), (0, h.default)(t2, [{ key: "_openChildCluster", value: function(e3) {
            var t3 = this, i2 = this.body.nodes[e3];
            if (void 0 === this.containedNodes[e3])
              throw new Error("node with id: " + e3 + " not in current cluster");
            if (!i2.isCluster)
              throw new Error("node with id: " + e3 + " is not a cluster");
            delete this.containedNodes[e3], p.forEach(i2.edges, function(e4) {
              delete t3.containedEdges[e4.id];
            }), p.forEach(i2.containedNodes, function(e4, i3) {
              t3.containedNodes[i3] = e4;
            }), i2.containedNodes = {}, p.forEach(i2.containedEdges, function(e4, i3) {
              t3.containedEdges[i3] = e4;
            }), i2.containedEdges = {}, p.forEach(i2.edges, function(e4) {
              p.forEach(t3.edges, function(i3) {
                var n2 = i3.clusteringEdgeReplacingIds.indexOf(e4.id);
                -1 !== n2 && (p.forEach(e4.clusteringEdgeReplacingIds, function(e5) {
                  i3.clusteringEdgeReplacingIds.push(e5), t3.body.edges[e5].edgeReplacedById = i3.id;
                }), i3.clusteringEdgeReplacingIds.splice(n2, 1));
              });
            }), i2.edges = [];
          } }]), t2;
        }(v);
        t.default = g;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        function o() {
          var e2;
          void 0 !== window && (e2 = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame), window.requestAnimationFrame = void 0 === e2 ? function(e3) {
            e3();
          } : e2;
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var s = i(0), r = n(s), a = i(1), d = n(a), h = i(5), l = function() {
          function e2(t2, i2) {
            (0, r.default)(this, e2), o(), this.body = t2, this.canvas = i2, this.redrawRequested = false, this.renderTimer = void 0, this.requiresTimeout = true, this.renderingActive = false, this.renderRequests = 0, this.allowRedraw = true, this.dragging = false, this.options = {}, this.defaultOptions = { hideEdgesOnDrag: false, hideNodesOnDrag: false }, h.extend(this.options, this.defaultOptions), this._determineBrowserMethod(), this.bindEventListeners();
          }
          return (0, d.default)(e2, [{ key: "bindEventListeners", value: function() {
            var e3 = this;
            this.body.emitter.on("dragStart", function() {
              e3.dragging = true;
            }), this.body.emitter.on("dragEnd", function() {
              e3.dragging = false;
            }), this.body.emitter.on("_resizeNodes", function() {
              e3._resizeNodes();
            }), this.body.emitter.on("_redraw", function() {
              false === e3.renderingActive && e3._redraw();
            }), this.body.emitter.on("_blockRedraw", function() {
              e3.allowRedraw = false;
            }), this.body.emitter.on("_allowRedraw", function() {
              e3.allowRedraw = true, e3.redrawRequested = false;
            }), this.body.emitter.on("_requestRedraw", this._requestRedraw.bind(this)), this.body.emitter.on("_startRendering", function() {
              e3.renderRequests += 1, e3.renderingActive = true, e3._startRendering();
            }), this.body.emitter.on("_stopRendering", function() {
              e3.renderRequests -= 1, e3.renderingActive = e3.renderRequests > 0, e3.renderTimer = void 0;
            }), this.body.emitter.on("destroy", function() {
              e3.renderRequests = 0, e3.allowRedraw = false, e3.renderingActive = false, true === e3.requiresTimeout ? clearTimeout(e3.renderTimer) : window.cancelAnimationFrame(e3.renderTimer), e3.body.emitter.off();
            });
          } }, { key: "setOptions", value: function(e3) {
            if (void 0 !== e3) {
              var t2 = ["hideEdgesOnDrag", "hideNodesOnDrag"];
              h.selectiveDeepExtend(t2, this.options, e3);
            }
          } }, { key: "_requestNextFrame", value: function(e3, t2) {
            if ("undefined" != typeof window) {
              var i2 = void 0, n2 = window;
              return true === this.requiresTimeout ? i2 = n2.setTimeout(e3, t2) : n2.requestAnimationFrame && (i2 = n2.requestAnimationFrame(e3)), i2;
            }
          } }, { key: "_startRendering", value: function() {
            true === this.renderingActive && void 0 === this.renderTimer && (this.renderTimer = this._requestNextFrame(this._renderStep.bind(this), this.simulationInterval));
          } }, { key: "_renderStep", value: function() {
            true === this.renderingActive && (this.renderTimer = void 0, true === this.requiresTimeout && this._startRendering(), this._redraw(), false === this.requiresTimeout && this._startRendering());
          } }, { key: "redraw", value: function() {
            this.body.emitter.emit("setSize"), this._redraw();
          } }, { key: "_requestRedraw", value: function() {
            var e3 = this;
            true !== this.redrawRequested && false === this.renderingActive && true === this.allowRedraw && (this.redrawRequested = true, this._requestNextFrame(function() {
              e3._redraw(false);
            }, 0));
          } }, { key: "_redraw", value: function() {
            var e3 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            if (true === this.allowRedraw) {
              this.body.emitter.emit("initRedraw"), this.redrawRequested = false, 0 !== this.canvas.frame.canvas.width && 0 !== this.canvas.frame.canvas.height || this.canvas.setSize(), this.canvas.setTransform();
              var t2 = this.canvas.getContext(), i2 = this.canvas.frame.canvas.clientWidth, n2 = this.canvas.frame.canvas.clientHeight;
              if (t2.clearRect(0, 0, i2, n2), 0 === this.canvas.frame.clientWidth)
                return;
              t2.save(), t2.translate(this.body.view.translation.x, this.body.view.translation.y), t2.scale(this.body.view.scale, this.body.view.scale), t2.beginPath(), this.body.emitter.emit("beforeDrawing", t2), t2.closePath(), false === e3 && (false === this.dragging || true === this.dragging && false === this.options.hideEdgesOnDrag) && this._drawEdges(t2), (false === this.dragging || true === this.dragging && false === this.options.hideNodesOnDrag) && this._drawNodes(t2, e3), t2.beginPath(), this.body.emitter.emit("afterDrawing", t2), t2.closePath(), t2.restore(), true === e3 && t2.clearRect(0, 0, i2, n2);
            }
          } }, { key: "_resizeNodes", value: function() {
            this.canvas.setTransform();
            var e3 = this.canvas.getContext();
            e3.save(), e3.translate(this.body.view.translation.x, this.body.view.translation.y), e3.scale(this.body.view.scale, this.body.view.scale);
            var t2 = this.body.nodes, i2 = void 0;
            for (var n2 in t2)
              t2.hasOwnProperty(n2) && (i2 = t2[n2], i2.resize(e3), i2.updateBoundingBox(e3, i2.selected));
            e3.restore();
          } }, { key: "_drawNodes", value: function(e3) {
            for (var t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], i2 = this.body.nodes, n2 = this.body.nodeIndices, o2 = void 0, s2 = [], r2 = this.canvas.DOMtoCanvas({ x: -20, y: -20 }), a2 = this.canvas.DOMtoCanvas({ x: this.canvas.frame.canvas.clientWidth + 20, y: this.canvas.frame.canvas.clientHeight + 20 }), d2 = { top: r2.y, left: r2.x, bottom: a2.y, right: a2.x }, h2 = 0; h2 < n2.length; h2++)
              o2 = i2[n2[h2]], o2.isSelected() ? s2.push(n2[h2]) : true === t2 ? o2.draw(e3) : true === o2.isBoundingBoxOverlappingWith(d2) ? o2.draw(e3) : o2.updateBoundingBox(e3, o2.selected);
            for (var l2 = 0; l2 < s2.length; l2++)
              o2 = i2[s2[l2]], o2.draw(e3);
          } }, { key: "_drawEdges", value: function(e3) {
            for (var t2 = this.body.edges, i2 = this.body.edgeIndices, n2 = void 0, o2 = 0; o2 < i2.length; o2++)
              n2 = t2[i2[o2]], true === n2.connected && n2.draw(e3);
          } }, { key: "_determineBrowserMethod", value: function() {
            if ("undefined" != typeof window) {
              var e3 = navigator.userAgent.toLowerCase();
              this.requiresTimeout = false, -1 != e3.indexOf("msie 9.0") ? this.requiresTimeout = true : -1 != e3.indexOf("safari") && e3.indexOf("chrome") <= -1 && (this.requiresTimeout = true);
            } else
              this.requiresTimeout = true;
          } }]), e2;
        }();
        t.default = l;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(0), s = n(o), r = i(1), a = n(r), d = i(22), h = i(35), l = i(5), u = function() {
          function e2(t2) {
            (0, s.default)(this, e2), this.body = t2, this.pixelRatio = 1, this.resizeTimer = void 0, this.resizeFunction = this._onResize.bind(this), this.cameraState = {}, this.initialized = false, this.canvasViewCenter = {}, this.options = {}, this.defaultOptions = { autoResize: true, height: "100%", width: "100%" }, l.extend(this.options, this.defaultOptions), this.bindEventListeners();
          }
          return (0, a.default)(e2, [{ key: "bindEventListeners", value: function() {
            var e3 = this;
            this.body.emitter.once("resize", function(t2) {
              0 !== t2.width && (e3.body.view.translation.x = 0.5 * t2.width), 0 !== t2.height && (e3.body.view.translation.y = 0.5 * t2.height);
            }), this.body.emitter.on("setSize", this.setSize.bind(this)), this.body.emitter.on("destroy", function() {
              e3.hammerFrame.destroy(), e3.hammer.destroy(), e3._cleanUp();
            });
          } }, { key: "setOptions", value: function(e3) {
            var t2 = this;
            if (void 0 !== e3) {
              var i2 = ["width", "height", "autoResize"];
              l.selectiveDeepExtend(i2, this.options, e3);
            }
            true === this.options.autoResize && (this._cleanUp(), this.resizeTimer = setInterval(function() {
              true === t2.setSize() && t2.body.emitter.emit("_requestRedraw");
            }, 1e3), this.resizeFunction = this._onResize.bind(this), l.addEventListener(window, "resize", this.resizeFunction));
          } }, { key: "_cleanUp", value: function() {
            void 0 !== this.resizeTimer && clearInterval(this.resizeTimer), l.removeEventListener(window, "resize", this.resizeFunction), this.resizeFunction = void 0;
          } }, { key: "_onResize", value: function() {
            this.setSize(), this.body.emitter.emit("_redraw");
          } }, { key: "_getCameraState", value: function() {
            var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.pixelRatio;
            true === this.initialized && (this.cameraState.previousWidth = this.frame.canvas.width / e3, this.cameraState.previousHeight = this.frame.canvas.height / e3, this.cameraState.scale = this.body.view.scale, this.cameraState.position = this.DOMtoCanvas({ x: 0.5 * this.frame.canvas.width / e3, y: 0.5 * this.frame.canvas.height / e3 }));
          } }, { key: "_setCameraState", value: function() {
            if (void 0 !== this.cameraState.scale && 0 !== this.frame.canvas.clientWidth && 0 !== this.frame.canvas.clientHeight && 0 !== this.pixelRatio && this.cameraState.previousWidth > 0) {
              var e3 = this.frame.canvas.width / this.pixelRatio / this.cameraState.previousWidth, t2 = this.frame.canvas.height / this.pixelRatio / this.cameraState.previousHeight, i2 = this.cameraState.scale;
              1 != e3 && 1 != t2 ? i2 = 0.5 * this.cameraState.scale * (e3 + t2) : 1 != e3 ? i2 = this.cameraState.scale * e3 : 1 != t2 && (i2 = this.cameraState.scale * t2), this.body.view.scale = i2;
              var n2 = this.DOMtoCanvas({ x: 0.5 * this.frame.canvas.clientWidth, y: 0.5 * this.frame.canvas.clientHeight }), o2 = { x: n2.x - this.cameraState.position.x, y: n2.y - this.cameraState.position.y };
              this.body.view.translation.x += o2.x * this.body.view.scale, this.body.view.translation.y += o2.y * this.body.view.scale;
            }
          } }, { key: "_prepareValue", value: function(e3) {
            if ("number" == typeof e3)
              return e3 + "px";
            if ("string" == typeof e3) {
              if (-1 !== e3.indexOf("%") || -1 !== e3.indexOf("px"))
                return e3;
              if (-1 === e3.indexOf("%"))
                return e3 + "px";
            }
            throw new Error("Could not use the value supplied for width or height:" + e3);
          } }, { key: "_create", value: function() {
            for (; this.body.container.hasChildNodes(); )
              this.body.container.removeChild(this.body.container.firstChild);
            if (this.frame = document.createElement("div"), this.frame.className = "vis-network", this.frame.style.position = "relative", this.frame.style.overflow = "hidden", this.frame.tabIndex = 900, this.frame.canvas = document.createElement("canvas"), this.frame.canvas.style.position = "relative", this.frame.appendChild(this.frame.canvas), this.frame.canvas.getContext)
              this._setPixelRatio(), this.setTransform();
            else {
              var e3 = document.createElement("DIV");
              e3.style.color = "red", e3.style.fontWeight = "bold", e3.style.padding = "10px", e3.innerHTML = "Error: your browser does not support HTML canvas", this.frame.canvas.appendChild(e3);
            }
            this.body.container.appendChild(this.frame), this.body.view.scale = 1, this.body.view.translation = { x: 0.5 * this.frame.canvas.clientWidth, y: 0.5 * this.frame.canvas.clientHeight }, this._bindHammer();
          } }, { key: "_bindHammer", value: function() {
            var e3 = this;
            void 0 !== this.hammer && this.hammer.destroy(), this.drag = {}, this.pinch = {}, this.hammer = new d(this.frame.canvas), this.hammer.get("pinch").set({ enable: true }), this.hammer.get("pan").set({ threshold: 5, direction: d.DIRECTION_ALL }), h.onTouch(this.hammer, function(t2) {
              e3.body.eventListeners.onTouch(t2);
            }), this.hammer.on("tap", function(t2) {
              e3.body.eventListeners.onTap(t2);
            }), this.hammer.on("doubletap", function(t2) {
              e3.body.eventListeners.onDoubleTap(t2);
            }), this.hammer.on("press", function(t2) {
              e3.body.eventListeners.onHold(t2);
            }), this.hammer.on("panstart", function(t2) {
              e3.body.eventListeners.onDragStart(t2);
            }), this.hammer.on("panmove", function(t2) {
              e3.body.eventListeners.onDrag(t2);
            }), this.hammer.on("panend", function(t2) {
              e3.body.eventListeners.onDragEnd(t2);
            }), this.hammer.on("pinch", function(t2) {
              e3.body.eventListeners.onPinch(t2);
            }), this.frame.canvas.addEventListener("mousewheel", function(t2) {
              e3.body.eventListeners.onMouseWheel(t2);
            }), this.frame.canvas.addEventListener("DOMMouseScroll", function(t2) {
              e3.body.eventListeners.onMouseWheel(t2);
            }), this.frame.canvas.addEventListener("mousemove", function(t2) {
              e3.body.eventListeners.onMouseMove(t2);
            }), this.frame.canvas.addEventListener("contextmenu", function(t2) {
              e3.body.eventListeners.onContext(t2);
            }), this.hammerFrame = new d(this.frame), h.onRelease(this.hammerFrame, function(t2) {
              e3.body.eventListeners.onRelease(t2);
            });
          } }, { key: "setSize", value: function() {
            var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.options.width, t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.options.height;
            e3 = this._prepareValue(e3), t2 = this._prepareValue(t2);
            var i2 = false, n2 = this.frame.canvas.width, o2 = this.frame.canvas.height, s2 = this.pixelRatio;
            if (this._setPixelRatio(), e3 != this.options.width || t2 != this.options.height || this.frame.style.width != e3 || this.frame.style.height != t2)
              this._getCameraState(s2), this.frame.style.width = e3, this.frame.style.height = t2, this.frame.canvas.style.width = "100%", this.frame.canvas.style.height = "100%", this.frame.canvas.width = Math.round(this.frame.canvas.clientWidth * this.pixelRatio), this.frame.canvas.height = Math.round(this.frame.canvas.clientHeight * this.pixelRatio), this.options.width = e3, this.options.height = t2, this.canvasViewCenter = { x: 0.5 * this.frame.clientWidth, y: 0.5 * this.frame.clientHeight }, i2 = true;
            else {
              var r2 = Math.round(this.frame.canvas.clientWidth * this.pixelRatio), a2 = Math.round(this.frame.canvas.clientHeight * this.pixelRatio);
              this.frame.canvas.width === r2 && this.frame.canvas.height === a2 || this._getCameraState(s2), this.frame.canvas.width !== r2 && (this.frame.canvas.width = r2, i2 = true), this.frame.canvas.height !== a2 && (this.frame.canvas.height = a2, i2 = true);
            }
            return true === i2 && (this.body.emitter.emit("resize", { width: Math.round(this.frame.canvas.width / this.pixelRatio), height: Math.round(this.frame.canvas.height / this.pixelRatio), oldWidth: Math.round(n2 / this.pixelRatio), oldHeight: Math.round(o2 / this.pixelRatio) }), this._setCameraState()), this.initialized = true, i2;
          } }, { key: "getContext", value: function() {
            return this.frame.canvas.getContext("2d");
          } }, { key: "_determinePixelRatio", value: function() {
            var e3 = this.getContext();
            if (void 0 === e3)
              throw new Error("Could not get canvax context");
            var t2 = 1;
            return "undefined" != typeof window && (t2 = window.devicePixelRatio || 1), t2 / (e3.webkitBackingStorePixelRatio || e3.mozBackingStorePixelRatio || e3.msBackingStorePixelRatio || e3.oBackingStorePixelRatio || e3.backingStorePixelRatio || 1);
          } }, { key: "_setPixelRatio", value: function() {
            this.pixelRatio = this._determinePixelRatio();
          } }, { key: "setTransform", value: function() {
            var e3 = this.getContext();
            if (void 0 === e3)
              throw new Error("Could not get canvax context");
            e3.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
          } }, { key: "_XconvertDOMtoCanvas", value: function(e3) {
            return (e3 - this.body.view.translation.x) / this.body.view.scale;
          } }, { key: "_XconvertCanvasToDOM", value: function(e3) {
            return e3 * this.body.view.scale + this.body.view.translation.x;
          } }, { key: "_YconvertDOMtoCanvas", value: function(e3) {
            return (e3 - this.body.view.translation.y) / this.body.view.scale;
          } }, { key: "_YconvertCanvasToDOM", value: function(e3) {
            return e3 * this.body.view.scale + this.body.view.translation.y;
          } }, { key: "canvasToDOM", value: function(e3) {
            return { x: this._XconvertCanvasToDOM(e3.x), y: this._YconvertCanvasToDOM(e3.y) };
          } }, { key: "DOMtoCanvas", value: function(e3) {
            return { x: this._XconvertDOMtoCanvas(e3.x), y: this._YconvertDOMtoCanvas(e3.y) };
          } }]), e2;
        }();
        t.default = u;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(0), s = n(o), r = i(1), a = n(r), d = i(5), h = i(57).default, l = function() {
          function e2(t2, i2) {
            var n2 = this;
            (0, s.default)(this, e2), this.body = t2, this.canvas = i2, this.animationSpeed = 1 / this.renderRefreshRate, this.animationEasingFunction = "easeInOutQuint", this.easingTime = 0, this.sourceScale = 0, this.targetScale = 0, this.sourceTranslation = 0, this.targetTranslation = 0, this.lockedOnNodeId = void 0, this.lockedOnNodeOffset = void 0, this.touchTime = 0, this.viewFunction = void 0, this.body.emitter.on("fit", this.fit.bind(this)), this.body.emitter.on("animationFinished", function() {
              n2.body.emitter.emit("_stopRendering");
            }), this.body.emitter.on("unlockNode", this.releaseNode.bind(this));
          }
          return (0, a.default)(e2, [{ key: "setOptions", value: function() {
            var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            this.options = e3;
          } }, { key: "fit", value: function() {
            var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : { nodes: [] }, t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], i2 = void 0, n2 = void 0;
            if (void 0 !== e3.nodes && 0 !== e3.nodes.length || (e3.nodes = this.body.nodeIndices), true === t2) {
              var o2 = 0;
              for (var s2 in this.body.nodes)
                if (this.body.nodes.hasOwnProperty(s2)) {
                  var r2 = this.body.nodes[s2];
                  true === r2.predefinedPosition && (o2 += 1);
                }
              if (o2 > 0.5 * this.body.nodeIndices.length)
                return void this.fit(e3, false);
              i2 = h.getRange(this.body.nodes, e3.nodes);
              n2 = 12.662 / (this.body.nodeIndices.length + 7.4147) + 0.0964822;
              n2 *= Math.min(this.canvas.frame.canvas.clientWidth / 600, this.canvas.frame.canvas.clientHeight / 600);
            } else {
              this.body.emitter.emit("_resizeNodes"), i2 = h.getRange(this.body.nodes, e3.nodes);
              var a2 = 1.1 * Math.abs(i2.maxX - i2.minX), d2 = 1.1 * Math.abs(i2.maxY - i2.minY), l2 = this.canvas.frame.canvas.clientWidth / a2, u = this.canvas.frame.canvas.clientHeight / d2;
              n2 = l2 <= u ? l2 : u;
            }
            n2 > 1 ? n2 = 1 : 0 === n2 && (n2 = 1);
            var c = h.findCenter(i2), f = { position: c, scale: n2, animation: e3.animation };
            this.moveTo(f);
          } }, { key: "focus", value: function(e3) {
            var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            if (void 0 !== this.body.nodes[e3]) {
              var i2 = { x: this.body.nodes[e3].x, y: this.body.nodes[e3].y };
              t2.position = i2, t2.lockedOnNode = e3, this.moveTo(t2);
            } else
              console.log("Node: " + e3 + " cannot be found.");
          } }, { key: "moveTo", value: function(e3) {
            if (void 0 === e3)
              return void (e3 = {});
            void 0 === e3.offset && (e3.offset = { x: 0, y: 0 }), void 0 === e3.offset.x && (e3.offset.x = 0), void 0 === e3.offset.y && (e3.offset.y = 0), void 0 === e3.scale && (e3.scale = this.body.view.scale), void 0 === e3.position && (e3.position = this.getViewPosition()), void 0 === e3.animation && (e3.animation = { duration: 0 }), false === e3.animation && (e3.animation = { duration: 0 }), true === e3.animation && (e3.animation = {}), void 0 === e3.animation.duration && (e3.animation.duration = 1e3), void 0 === e3.animation.easingFunction && (e3.animation.easingFunction = "easeInOutQuad"), this.animateView(e3);
          } }, { key: "animateView", value: function(e3) {
            if (void 0 !== e3) {
              this.animationEasingFunction = e3.animation.easingFunction, this.releaseNode(), true === e3.locked && (this.lockedOnNodeId = e3.lockedOnNode, this.lockedOnNodeOffset = e3.offset), 0 != this.easingTime && this._transitionRedraw(true), this.sourceScale = this.body.view.scale, this.sourceTranslation = this.body.view.translation, this.targetScale = e3.scale, this.body.view.scale = this.targetScale;
              var t2 = this.canvas.DOMtoCanvas({ x: 0.5 * this.canvas.frame.canvas.clientWidth, y: 0.5 * this.canvas.frame.canvas.clientHeight }), i2 = { x: t2.x - e3.position.x, y: t2.y - e3.position.y };
              this.targetTranslation = { x: this.sourceTranslation.x + i2.x * this.targetScale + e3.offset.x, y: this.sourceTranslation.y + i2.y * this.targetScale + e3.offset.y }, 0 === e3.animation.duration ? void 0 != this.lockedOnNodeId ? (this.viewFunction = this._lockedRedraw.bind(this), this.body.emitter.on("initRedraw", this.viewFunction)) : (this.body.view.scale = this.targetScale, this.body.view.translation = this.targetTranslation, this.body.emitter.emit("_requestRedraw")) : (this.animationSpeed = 1 / (60 * e3.animation.duration * 1e-3) || 1 / 60, this.animationEasingFunction = e3.animation.easingFunction, this.viewFunction = this._transitionRedraw.bind(this), this.body.emitter.on("initRedraw", this.viewFunction), this.body.emitter.emit("_startRendering"));
            }
          } }, { key: "_lockedRedraw", value: function() {
            var e3 = { x: this.body.nodes[this.lockedOnNodeId].x, y: this.body.nodes[this.lockedOnNodeId].y }, t2 = this.canvas.DOMtoCanvas({ x: 0.5 * this.canvas.frame.canvas.clientWidth, y: 0.5 * this.canvas.frame.canvas.clientHeight }), i2 = { x: t2.x - e3.x, y: t2.y - e3.y }, n2 = this.body.view.translation, o2 = { x: n2.x + i2.x * this.body.view.scale + this.lockedOnNodeOffset.x, y: n2.y + i2.y * this.body.view.scale + this.lockedOnNodeOffset.y };
            this.body.view.translation = o2;
          } }, { key: "releaseNode", value: function() {
            void 0 !== this.lockedOnNodeId && void 0 !== this.viewFunction && (this.body.emitter.off("initRedraw", this.viewFunction), this.lockedOnNodeId = void 0, this.lockedOnNodeOffset = void 0);
          } }, { key: "_transitionRedraw", value: function() {
            var e3 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            this.easingTime += this.animationSpeed, this.easingTime = true === e3 ? 1 : this.easingTime;
            var t2 = d.easingFunctions[this.animationEasingFunction](this.easingTime);
            this.body.view.scale = this.sourceScale + (this.targetScale - this.sourceScale) * t2, this.body.view.translation = { x: this.sourceTranslation.x + (this.targetTranslation.x - this.sourceTranslation.x) * t2, y: this.sourceTranslation.y + (this.targetTranslation.y - this.sourceTranslation.y) * t2 }, this.easingTime >= 1 && (this.body.emitter.off("initRedraw", this.viewFunction), this.easingTime = 0, void 0 != this.lockedOnNodeId && (this.viewFunction = this._lockedRedraw.bind(this), this.body.emitter.on("initRedraw", this.viewFunction)), this.body.emitter.emit("animationFinished"));
          } }, { key: "getScale", value: function() {
            return this.body.view.scale;
          } }, { key: "getViewPosition", value: function() {
            return this.canvas.DOMtoCanvas({ x: 0.5 * this.canvas.frame.canvas.clientWidth, y: 0.5 * this.canvas.frame.canvas.clientHeight });
          } }]), e2;
        }();
        t.default = l;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(0), s = n(o), r = i(1), a = n(r), d = i(5), h = i(182).default, l = i(183).default, u = function() {
          function e2(t2, i2, n2) {
            (0, s.default)(this, e2), this.body = t2, this.canvas = i2, this.selectionHandler = n2, this.navigationHandler = new h(t2, i2), this.body.eventListeners.onTap = this.onTap.bind(this), this.body.eventListeners.onTouch = this.onTouch.bind(this), this.body.eventListeners.onDoubleTap = this.onDoubleTap.bind(this), this.body.eventListeners.onHold = this.onHold.bind(this), this.body.eventListeners.onDragStart = this.onDragStart.bind(this), this.body.eventListeners.onDrag = this.onDrag.bind(this), this.body.eventListeners.onDragEnd = this.onDragEnd.bind(this), this.body.eventListeners.onMouseWheel = this.onMouseWheel.bind(this), this.body.eventListeners.onPinch = this.onPinch.bind(this), this.body.eventListeners.onMouseMove = this.onMouseMove.bind(this), this.body.eventListeners.onRelease = this.onRelease.bind(this), this.body.eventListeners.onContext = this.onContext.bind(this), this.touchTime = 0, this.drag = {}, this.pinch = {}, this.popup = void 0, this.popupObj = void 0, this.popupTimer = void 0, this.body.functions.getPointer = this.getPointer.bind(this), this.options = {}, this.defaultOptions = { dragNodes: true, dragView: true, hover: false, keyboard: { enabled: false, speed: { x: 10, y: 10, zoom: 0.02 }, bindToWindow: true }, navigationButtons: false, tooltipDelay: 300, zoomView: true }, d.extend(this.options, this.defaultOptions), this.bindEventListeners();
          }
          return (0, a.default)(e2, [{ key: "bindEventListeners", value: function() {
            var e3 = this;
            this.body.emitter.on("destroy", function() {
              clearTimeout(e3.popupTimer), delete e3.body.functions.getPointer;
            });
          } }, { key: "setOptions", value: function(e3) {
            if (void 0 !== e3) {
              var t2 = ["hideEdgesOnDrag", "hideNodesOnDrag", "keyboard", "multiselect", "selectable", "selectConnectedEdges"];
              d.selectiveNotDeepExtend(t2, this.options, e3), d.mergeOptions(this.options, e3, "keyboard"), e3.tooltip && (d.extend(this.options.tooltip, e3.tooltip), e3.tooltip.color && (this.options.tooltip.color = d.parseColor(e3.tooltip.color)));
            }
            this.navigationHandler.setOptions(this.options);
          } }, { key: "getPointer", value: function(e3) {
            return { x: e3.x - d.getAbsoluteLeft(this.canvas.frame.canvas), y: e3.y - d.getAbsoluteTop(this.canvas.frame.canvas) };
          } }, { key: "onTouch", value: function(e3) {
            new Date().valueOf() - this.touchTime > 50 && (this.drag.pointer = this.getPointer(e3.center), this.drag.pinched = false, this.pinch.scale = this.body.view.scale, this.touchTime = new Date().valueOf());
          } }, { key: "onTap", value: function(e3) {
            var t2 = this.getPointer(e3.center), i2 = this.selectionHandler.options.multiselect && (e3.changedPointers[0].ctrlKey || e3.changedPointers[0].metaKey);
            this.checkSelectionChanges(t2, e3, i2), this.selectionHandler._generateClickEvent("click", e3, t2);
          } }, { key: "onDoubleTap", value: function(e3) {
            var t2 = this.getPointer(e3.center);
            this.selectionHandler._generateClickEvent("doubleClick", e3, t2);
          } }, { key: "onHold", value: function(e3) {
            var t2 = this.getPointer(e3.center), i2 = this.selectionHandler.options.multiselect;
            this.checkSelectionChanges(t2, e3, i2), this.selectionHandler._generateClickEvent("click", e3, t2), this.selectionHandler._generateClickEvent("hold", e3, t2);
          } }, { key: "onRelease", value: function(e3) {
            if (new Date().valueOf() - this.touchTime > 10) {
              var t2 = this.getPointer(e3.center);
              this.selectionHandler._generateClickEvent("release", e3, t2), this.touchTime = new Date().valueOf();
            }
          } }, { key: "onContext", value: function(e3) {
            var t2 = this.getPointer({ x: e3.clientX, y: e3.clientY });
            this.selectionHandler._generateClickEvent("oncontext", e3, t2);
          } }, { key: "checkSelectionChanges", value: function(e3, t2) {
            var i2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], n2 = this.selectionHandler.getSelection(), o2 = false;
            o2 = true === i2 ? this.selectionHandler.selectAdditionalOnPoint(e3) : this.selectionHandler.selectOnPoint(e3);
            var s2 = this.selectionHandler.getSelection(), r2 = this._determineDifference(n2, s2), a2 = this._determineDifference(s2, n2);
            r2.edges.length > 0 && (this.selectionHandler._generateClickEvent("deselectEdge", t2, e3, n2), o2 = true), r2.nodes.length > 0 && (this.selectionHandler._generateClickEvent("deselectNode", t2, e3, n2), o2 = true), a2.nodes.length > 0 && (this.selectionHandler._generateClickEvent("selectNode", t2, e3), o2 = true), a2.edges.length > 0 && (this.selectionHandler._generateClickEvent("selectEdge", t2, e3), o2 = true), true === o2 && this.selectionHandler._generateClickEvent("select", t2, e3);
          } }, { key: "_determineDifference", value: function(e3, t2) {
            var i2 = function(e4, t3) {
              for (var i3 = [], n2 = 0; n2 < e4.length; n2++) {
                var o2 = e4[n2];
                -1 === t3.indexOf(o2) && i3.push(o2);
              }
              return i3;
            };
            return { nodes: i2(e3.nodes, t2.nodes), edges: i2(e3.edges, t2.edges) };
          } }, { key: "onDragStart", value: function(e3) {
            void 0 === this.drag.pointer && this.onTouch(e3);
            var t2 = this.selectionHandler.getNodeAt(this.drag.pointer);
            if (this.drag.dragging = true, this.drag.selection = [], this.drag.translation = d.extend({}, this.body.view.translation), this.drag.nodeId = void 0, void 0 !== t2 && true === this.options.dragNodes) {
              this.drag.nodeId = t2.id, false === t2.isSelected() && (this.selectionHandler.unselectAll(), this.selectionHandler.selectObject(t2)), this.selectionHandler._generateClickEvent("dragStart", e3, this.drag.pointer);
              var i2 = this.selectionHandler.selectionObj.nodes;
              for (var n2 in i2)
                if (i2.hasOwnProperty(n2)) {
                  var o2 = i2[n2], s2 = { id: o2.id, node: o2, x: o2.x, y: o2.y, xFixed: o2.options.fixed.x, yFixed: o2.options.fixed.y };
                  o2.options.fixed.x = true, o2.options.fixed.y = true, this.drag.selection.push(s2);
                }
            } else
              this.selectionHandler._generateClickEvent("dragStart", e3, this.drag.pointer, void 0, true);
          } }, { key: "onDrag", value: function(e3) {
            var t2 = this;
            if (true !== this.drag.pinched) {
              this.body.emitter.emit("unlockNode");
              var i2 = this.getPointer(e3.center), n2 = this.drag.selection;
              if (n2 && n2.length && true === this.options.dragNodes) {
                this.selectionHandler._generateClickEvent("dragging", e3, i2);
                var o2 = i2.x - this.drag.pointer.x, s2 = i2.y - this.drag.pointer.y;
                n2.forEach(function(e4) {
                  var i3 = e4.node;
                  false === e4.xFixed && (i3.x = t2.canvas._XconvertDOMtoCanvas(t2.canvas._XconvertCanvasToDOM(e4.x) + o2)), false === e4.yFixed && (i3.y = t2.canvas._YconvertDOMtoCanvas(t2.canvas._YconvertCanvasToDOM(e4.y) + s2));
                }), this.body.emitter.emit("startSimulation");
              } else if (true === this.options.dragView) {
                if (this.selectionHandler._generateClickEvent("dragging", e3, i2, void 0, true), void 0 === this.drag.pointer)
                  return void this.onDragStart(e3);
                var r2 = i2.x - this.drag.pointer.x, a2 = i2.y - this.drag.pointer.y;
                this.body.view.translation = { x: this.drag.translation.x + r2, y: this.drag.translation.y + a2 }, this.body.emitter.emit("_requestRedraw");
              }
            }
          } }, { key: "onDragEnd", value: function(e3) {
            this.drag.dragging = false;
            var t2 = this.drag.selection;
            t2 && t2.length ? (t2.forEach(function(e4) {
              e4.node.options.fixed.x = e4.xFixed, e4.node.options.fixed.y = e4.yFixed;
            }), this.selectionHandler._generateClickEvent("dragEnd", e3, this.getPointer(e3.center)), this.body.emitter.emit("startSimulation")) : (this.selectionHandler._generateClickEvent("dragEnd", e3, this.getPointer(e3.center), void 0, true), this.body.emitter.emit("_requestRedraw"));
          } }, { key: "onPinch", value: function(e3) {
            var t2 = this.getPointer(e3.center);
            this.drag.pinched = true, void 0 === this.pinch.scale && (this.pinch.scale = 1);
            var i2 = this.pinch.scale * e3.scale;
            this.zoom(i2, t2);
          } }, { key: "zoom", value: function(e3, t2) {
            if (true === this.options.zoomView) {
              var i2 = this.body.view.scale;
              e3 < 1e-5 && (e3 = 1e-5), e3 > 10 && (e3 = 10);
              var n2 = void 0;
              void 0 !== this.drag && true === this.drag.dragging && (n2 = this.canvas.DOMtoCanvas(this.drag.pointer));
              var o2 = this.body.view.translation, s2 = e3 / i2, r2 = (1 - s2) * t2.x + o2.x * s2, a2 = (1 - s2) * t2.y + o2.y * s2;
              if (this.body.view.scale = e3, this.body.view.translation = { x: r2, y: a2 }, void 0 != n2) {
                var d2 = this.canvas.canvasToDOM(n2);
                this.drag.pointer.x = d2.x, this.drag.pointer.y = d2.y;
              }
              this.body.emitter.emit("_requestRedraw"), i2 < e3 ? this.body.emitter.emit("zoom", { direction: "+", scale: this.body.view.scale, pointer: t2 }) : this.body.emitter.emit("zoom", { direction: "-", scale: this.body.view.scale, pointer: t2 });
            }
          } }, { key: "onMouseWheel", value: function(e3) {
            if (true === this.options.zoomView) {
              var t2 = 0;
              if (e3.wheelDelta ? t2 = e3.wheelDelta / 120 : e3.detail && (t2 = -e3.detail / 3), 0 !== t2) {
                var i2 = this.body.view.scale, n2 = t2 / 10;
                t2 < 0 && (n2 /= 1 - n2), i2 *= 1 + n2;
                var o2 = this.getPointer({ x: e3.clientX, y: e3.clientY });
                this.zoom(i2, o2);
              }
              e3.preventDefault();
            }
          } }, { key: "onMouseMove", value: function(e3) {
            var t2 = this, i2 = this.getPointer({ x: e3.clientX, y: e3.clientY }), n2 = false;
            void 0 !== this.popup && (false === this.popup.hidden && this._checkHidePopup(i2), false === this.popup.hidden && (n2 = true, this.popup.setPosition(i2.x + 3, i2.y - 5), this.popup.show())), false === this.options.keyboard.bindToWindow && true === this.options.keyboard.enabled && this.canvas.frame.focus(), false === n2 && (void 0 !== this.popupTimer && (clearInterval(this.popupTimer), this.popupTimer = void 0), this.drag.dragging || (this.popupTimer = setTimeout(function() {
              return t2._checkShowPopup(i2);
            }, this.options.tooltipDelay))), true === this.options.hover && this.selectionHandler.hoverObject(e3, i2);
          } }, { key: "_checkShowPopup", value: function(e3) {
            var t2 = this.canvas._XconvertDOMtoCanvas(e3.x), i2 = this.canvas._YconvertDOMtoCanvas(e3.y), n2 = { left: t2, top: i2, right: t2, bottom: i2 }, o2 = void 0 === this.popupObj ? void 0 : this.popupObj.id, s2 = false, r2 = "node";
            if (void 0 === this.popupObj) {
              for (var a2 = this.body.nodeIndices, d2 = this.body.nodes, h2 = void 0, u2 = [], c = 0; c < a2.length; c++)
                h2 = d2[a2[c]], true === h2.isOverlappingWith(n2) && void 0 !== h2.getTitle() && u2.push(a2[c]);
              u2.length > 0 && (this.popupObj = d2[u2[u2.length - 1]], s2 = true);
            }
            if (void 0 === this.popupObj && false === s2) {
              for (var f = this.body.edgeIndices, p = this.body.edges, v = void 0, g = [], y = 0; y < f.length; y++)
                v = p[f[y]], true === v.isOverlappingWith(n2) && true === v.connected && void 0 !== v.getTitle() && g.push(f[y]);
              g.length > 0 && (this.popupObj = p[g[g.length - 1]], r2 = "edge");
            }
            void 0 !== this.popupObj ? this.popupObj.id !== o2 && (void 0 === this.popup && (this.popup = new l(this.canvas.frame)), this.popup.popupTargetType = r2, this.popup.popupTargetId = this.popupObj.id, this.popup.setPosition(e3.x + 3, e3.y - 5), this.popup.setText(this.popupObj.getTitle()), this.popup.show(), this.body.emitter.emit("showPopup", this.popupObj.id)) : void 0 !== this.popup && (this.popup.hide(), this.body.emitter.emit("hidePopup"));
          } }, { key: "_checkHidePopup", value: function(e3) {
            var t2 = this.selectionHandler._pointerToPositionObject(e3), i2 = false;
            if ("node" === this.popup.popupTargetType) {
              if (void 0 !== this.body.nodes[this.popup.popupTargetId] && true === (i2 = this.body.nodes[this.popup.popupTargetId].isOverlappingWith(t2))) {
                var n2 = this.selectionHandler.getNodeAt(e3);
                i2 = void 0 !== n2 && n2.id === this.popup.popupTargetId;
              }
            } else
              void 0 === this.selectionHandler.getNodeAt(e3) && void 0 !== this.body.edges[this.popup.popupTargetId] && (i2 = this.body.edges[this.popup.popupTargetId].isOverlappingWith(t2));
            false === i2 && (this.popupObj = void 0, this.popup.hide(), this.body.emitter.emit("hidePopup"));
          } }]), e2;
        }();
        t.default = u;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(0), s = n(o), r = i(1), a = n(r), d = i(22), h = i(35), l = i(52), u = function() {
          function e2(t2, i2) {
            var n2 = this;
            (0, s.default)(this, e2), this.body = t2, this.canvas = i2, this.iconsCreated = false, this.navigationHammers = [], this.boundFunctions = {}, this.touchTime = 0, this.activated = false, this.body.emitter.on("activate", function() {
              n2.activated = true, n2.configureKeyboardBindings();
            }), this.body.emitter.on("deactivate", function() {
              n2.activated = false, n2.configureKeyboardBindings();
            }), this.body.emitter.on("destroy", function() {
              void 0 !== n2.keycharm && n2.keycharm.destroy();
            }), this.options = {};
          }
          return (0, a.default)(e2, [{ key: "setOptions", value: function(e3) {
            void 0 !== e3 && (this.options = e3, this.create());
          } }, { key: "create", value: function() {
            true === this.options.navigationButtons ? false === this.iconsCreated && this.loadNavigationElements() : true === this.iconsCreated && this.cleanNavigation(), this.configureKeyboardBindings();
          } }, { key: "cleanNavigation", value: function() {
            if (0 != this.navigationHammers.length) {
              for (var e3 = 0; e3 < this.navigationHammers.length; e3++)
                this.navigationHammers[e3].destroy();
              this.navigationHammers = [];
            }
            this.navigationDOM && this.navigationDOM.wrapper && this.navigationDOM.wrapper.parentNode && this.navigationDOM.wrapper.parentNode.removeChild(this.navigationDOM.wrapper), this.iconsCreated = false;
          } }, { key: "loadNavigationElements", value: function() {
            var e3 = this;
            this.cleanNavigation(), this.navigationDOM = {};
            var t2 = ["up", "down", "left", "right", "zoomIn", "zoomOut", "zoomExtends"], i2 = ["_moveUp", "_moveDown", "_moveLeft", "_moveRight", "_zoomIn", "_zoomOut", "_fit"];
            this.navigationDOM.wrapper = document.createElement("div"), this.navigationDOM.wrapper.className = "vis-navigation", this.canvas.frame.appendChild(this.navigationDOM.wrapper);
            for (var n2 = 0; n2 < t2.length; n2++) {
              this.navigationDOM[t2[n2]] = document.createElement("div"), this.navigationDOM[t2[n2]].className = "vis-button vis-" + t2[n2], this.navigationDOM.wrapper.appendChild(this.navigationDOM[t2[n2]]);
              var o2 = new d(this.navigationDOM[t2[n2]]);
              "_fit" === i2[n2] ? h.onTouch(o2, this._fit.bind(this)) : h.onTouch(o2, this.bindToRedraw.bind(this, i2[n2])), this.navigationHammers.push(o2);
            }
            var s2 = new d(this.canvas.frame);
            h.onRelease(s2, function() {
              e3._stopMovement();
            }), this.navigationHammers.push(s2), this.iconsCreated = true;
          } }, { key: "bindToRedraw", value: function(e3) {
            void 0 === this.boundFunctions[e3] && (this.boundFunctions[e3] = this[e3].bind(this), this.body.emitter.on("initRedraw", this.boundFunctions[e3]), this.body.emitter.emit("_startRendering"));
          } }, { key: "unbindFromRedraw", value: function(e3) {
            void 0 !== this.boundFunctions[e3] && (this.body.emitter.off("initRedraw", this.boundFunctions[e3]), this.body.emitter.emit("_stopRendering"), delete this.boundFunctions[e3]);
          } }, { key: "_fit", value: function() {
            new Date().valueOf() - this.touchTime > 700 && (this.body.emitter.emit("fit", { duration: 700 }), this.touchTime = new Date().valueOf());
          } }, { key: "_stopMovement", value: function() {
            for (var e3 in this.boundFunctions)
              this.boundFunctions.hasOwnProperty(e3) && (this.body.emitter.off("initRedraw", this.boundFunctions[e3]), this.body.emitter.emit("_stopRendering"));
            this.boundFunctions = {};
          } }, { key: "_moveUp", value: function() {
            this.body.view.translation.y += this.options.keyboard.speed.y;
          } }, { key: "_moveDown", value: function() {
            this.body.view.translation.y -= this.options.keyboard.speed.y;
          } }, { key: "_moveLeft", value: function() {
            this.body.view.translation.x += this.options.keyboard.speed.x;
          } }, { key: "_moveRight", value: function() {
            this.body.view.translation.x -= this.options.keyboard.speed.x;
          } }, { key: "_zoomIn", value: function() {
            var e3 = this.body.view.scale, t2 = this.body.view.scale * (1 + this.options.keyboard.speed.zoom), i2 = this.body.view.translation, n2 = t2 / e3, o2 = (1 - n2) * this.canvas.canvasViewCenter.x + i2.x * n2, s2 = (1 - n2) * this.canvas.canvasViewCenter.y + i2.y * n2;
            this.body.view.scale = t2, this.body.view.translation = { x: o2, y: s2 }, this.body.emitter.emit("zoom", { direction: "+", scale: this.body.view.scale, pointer: null });
          } }, { key: "_zoomOut", value: function() {
            var e3 = this.body.view.scale, t2 = this.body.view.scale / (1 + this.options.keyboard.speed.zoom), i2 = this.body.view.translation, n2 = t2 / e3, o2 = (1 - n2) * this.canvas.canvasViewCenter.x + i2.x * n2, s2 = (1 - n2) * this.canvas.canvasViewCenter.y + i2.y * n2;
            this.body.view.scale = t2, this.body.view.translation = { x: o2, y: s2 }, this.body.emitter.emit("zoom", { direction: "-", scale: this.body.view.scale, pointer: null });
          } }, { key: "configureKeyboardBindings", value: function() {
            var e3 = this;
            void 0 !== this.keycharm && this.keycharm.destroy(), true === this.options.keyboard.enabled && (true === this.options.keyboard.bindToWindow ? this.keycharm = l({ container: window, preventDefault: true }) : this.keycharm = l({ container: this.canvas.frame, preventDefault: true }), this.keycharm.reset(), true === this.activated && (this.keycharm.bind("up", function() {
              e3.bindToRedraw("_moveUp");
            }, "keydown"), this.keycharm.bind("down", function() {
              e3.bindToRedraw("_moveDown");
            }, "keydown"), this.keycharm.bind("left", function() {
              e3.bindToRedraw("_moveLeft");
            }, "keydown"), this.keycharm.bind("right", function() {
              e3.bindToRedraw("_moveRight");
            }, "keydown"), this.keycharm.bind("=", function() {
              e3.bindToRedraw("_zoomIn");
            }, "keydown"), this.keycharm.bind("num+", function() {
              e3.bindToRedraw("_zoomIn");
            }, "keydown"), this.keycharm.bind("num-", function() {
              e3.bindToRedraw("_zoomOut");
            }, "keydown"), this.keycharm.bind("-", function() {
              e3.bindToRedraw("_zoomOut");
            }, "keydown"), this.keycharm.bind("[", function() {
              e3.bindToRedraw("_zoomOut");
            }, "keydown"), this.keycharm.bind("]", function() {
              e3.bindToRedraw("_zoomIn");
            }, "keydown"), this.keycharm.bind("pageup", function() {
              e3.bindToRedraw("_zoomIn");
            }, "keydown"), this.keycharm.bind("pagedown", function() {
              e3.bindToRedraw("_zoomOut");
            }, "keydown"), this.keycharm.bind("up", function() {
              e3.unbindFromRedraw("_moveUp");
            }, "keyup"), this.keycharm.bind("down", function() {
              e3.unbindFromRedraw("_moveDown");
            }, "keyup"), this.keycharm.bind("left", function() {
              e3.unbindFromRedraw("_moveLeft");
            }, "keyup"), this.keycharm.bind("right", function() {
              e3.unbindFromRedraw("_moveRight");
            }, "keyup"), this.keycharm.bind("=", function() {
              e3.unbindFromRedraw("_zoomIn");
            }, "keyup"), this.keycharm.bind("num+", function() {
              e3.unbindFromRedraw("_zoomIn");
            }, "keyup"), this.keycharm.bind("num-", function() {
              e3.unbindFromRedraw("_zoomOut");
            }, "keyup"), this.keycharm.bind("-", function() {
              e3.unbindFromRedraw("_zoomOut");
            }, "keyup"), this.keycharm.bind("[", function() {
              e3.unbindFromRedraw("_zoomOut");
            }, "keyup"), this.keycharm.bind("]", function() {
              e3.unbindFromRedraw("_zoomIn");
            }, "keyup"), this.keycharm.bind("pageup", function() {
              e3.unbindFromRedraw("_zoomIn");
            }, "keyup"), this.keycharm.bind("pagedown", function() {
              e3.unbindFromRedraw("_zoomOut");
            }, "keyup")));
          } }]), e2;
        }();
        t.default = u;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(0), s = n(o), r = i(1), a = n(r), d = function() {
          function e2(t2, i2) {
            (0, s.default)(this, e2), this.container = t2, this.overflowMethod = i2 || "cap", this.x = 0, this.y = 0, this.padding = 5, this.hidden = false, this.frame = document.createElement("div"), this.frame.className = "vis-tooltip", this.container.appendChild(this.frame);
          }
          return (0, a.default)(e2, [{ key: "setPosition", value: function(e3, t2) {
            this.x = parseInt(e3), this.y = parseInt(t2);
          } }, { key: "setText", value: function(e3) {
            e3 instanceof Element ? (this.frame.innerHTML = "", this.frame.appendChild(e3)) : this.frame.innerHTML = e3;
          } }, { key: "show", value: function(e3) {
            if (void 0 === e3 && (e3 = true), true === e3) {
              var t2 = this.frame.clientHeight, i2 = this.frame.clientWidth, n2 = this.frame.parentNode.clientHeight, o2 = this.frame.parentNode.clientWidth, s2 = 0, r2 = 0;
              if ("flip" == this.overflowMethod) {
                var a2 = false, d2 = true;
                this.y - t2 < this.padding && (d2 = false), this.x + i2 > o2 - this.padding && (a2 = true), s2 = a2 ? this.x - i2 : this.x, r2 = d2 ? this.y - t2 : this.y;
              } else
                r2 = this.y - t2, r2 + t2 + this.padding > n2 && (r2 = n2 - t2 - this.padding), r2 < this.padding && (r2 = this.padding), s2 = this.x, s2 + i2 + this.padding > o2 && (s2 = o2 - i2 - this.padding), s2 < this.padding && (s2 = this.padding);
              this.frame.style.left = s2 + "px", this.frame.style.top = r2 + "px", this.frame.style.visibility = "visible", this.hidden = false;
            } else
              this.hide();
          } }, { key: "hide", value: function() {
            this.hidden = true, this.frame.style.left = "0", this.frame.style.top = "0", this.frame.style.visibility = "hidden";
          } }, { key: "destroy", value: function() {
            this.frame.parentNode.removeChild(this.frame);
          } }]), e2;
        }();
        t.default = d;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(0), s = n(o), r = i(1), a = n(r), d = i(33).default, h = i(55).default, l = i(5), u = function() {
          function e2(t2, i2) {
            var n2 = this;
            (0, s.default)(this, e2), this.body = t2, this.canvas = i2, this.selectionObj = { nodes: [], edges: [] }, this.hoverObj = { nodes: {}, edges: {} }, this.options = {}, this.defaultOptions = { multiselect: false, selectable: true, selectConnectedEdges: true, hoverConnectedEdges: true }, l.extend(this.options, this.defaultOptions), this.body.emitter.on("_dataChanged", function() {
              n2.updateSelection();
            });
          }
          return (0, a.default)(e2, [{ key: "setOptions", value: function(e3) {
            if (void 0 !== e3) {
              var t2 = ["multiselect", "hoverConnectedEdges", "selectable", "selectConnectedEdges"];
              l.selectiveDeepExtend(t2, this.options, e3);
            }
          } }, { key: "selectOnPoint", value: function(e3) {
            var t2 = false;
            if (true === this.options.selectable) {
              var i2 = this.getNodeAt(e3) || this.getEdgeAt(e3);
              this.unselectAll(), void 0 !== i2 && (t2 = this.selectObject(i2)), this.body.emitter.emit("_requestRedraw");
            }
            return t2;
          } }, { key: "selectAdditionalOnPoint", value: function(e3) {
            var t2 = false;
            if (true === this.options.selectable) {
              var i2 = this.getNodeAt(e3) || this.getEdgeAt(e3);
              void 0 !== i2 && (t2 = true, true === i2.isSelected() ? this.deselectObject(i2) : this.selectObject(i2), this.body.emitter.emit("_requestRedraw"));
            }
            return t2;
          } }, { key: "_initBaseEvent", value: function(e3, t2) {
            var i2 = {};
            return i2.pointer = { DOM: { x: t2.x, y: t2.y }, canvas: this.canvas.DOMtoCanvas(t2) }, i2.event = e3, i2;
          } }, { key: "_generateClickEvent", value: function(e3, t2, i2, n2) {
            var o2 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4], s2 = this._initBaseEvent(t2, i2);
            if (true === o2)
              s2.nodes = [], s2.edges = [];
            else {
              var r2 = this.getSelection();
              s2.nodes = r2.nodes, s2.edges = r2.edges;
            }
            void 0 !== n2 && (s2.previousSelection = n2), "click" == e3 && (s2.items = this.getClickedItems(i2)), this.body.emitter.emit(e3, s2);
          } }, { key: "selectObject", value: function(e3) {
            var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.options.selectConnectedEdges;
            return void 0 !== e3 && (e3 instanceof d && true === t2 && this._selectConnectedEdges(e3), e3.select(), this._addToSelection(e3), true);
          } }, { key: "deselectObject", value: function(e3) {
            true === e3.isSelected() && (e3.selected = false, this._removeFromSelection(e3));
          } }, { key: "_getAllNodesOverlappingWith", value: function(e3) {
            for (var t2 = [], i2 = this.body.nodes, n2 = 0; n2 < this.body.nodeIndices.length; n2++) {
              var o2 = this.body.nodeIndices[n2];
              i2[o2].isOverlappingWith(e3) && t2.push(o2);
            }
            return t2;
          } }, { key: "_pointerToPositionObject", value: function(e3) {
            var t2 = this.canvas.DOMtoCanvas(e3);
            return { left: t2.x - 1, top: t2.y + 1, right: t2.x + 1, bottom: t2.y - 1 };
          } }, { key: "getNodeAt", value: function(e3) {
            var t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i2 = this._pointerToPositionObject(e3), n2 = this._getAllNodesOverlappingWith(i2);
            return n2.length > 0 ? true === t2 ? this.body.nodes[n2[n2.length - 1]] : n2[n2.length - 1] : void 0;
          } }, { key: "_getEdgesOverlappingWith", value: function(e3, t2) {
            for (var i2 = this.body.edges, n2 = 0; n2 < this.body.edgeIndices.length; n2++) {
              var o2 = this.body.edgeIndices[n2];
              i2[o2].isOverlappingWith(e3) && t2.push(o2);
            }
          } }, { key: "_getAllEdgesOverlappingWith", value: function(e3) {
            var t2 = [];
            return this._getEdgesOverlappingWith(e3, t2), t2;
          } }, { key: "getEdgeAt", value: function(e3) {
            for (var t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i2 = this.canvas.DOMtoCanvas(e3), n2 = 10, o2 = null, s2 = this.body.edges, r2 = 0; r2 < this.body.edgeIndices.length; r2++) {
              var a2 = this.body.edgeIndices[r2], d2 = s2[a2];
              if (d2.connected) {
                var h2 = d2.from.x, l2 = d2.from.y, u2 = d2.to.x, c = d2.to.y, f = d2.edgeType.getDistanceToEdge(h2, l2, u2, c, i2.x, i2.y);
                f < n2 && (o2 = a2, n2 = f);
              }
            }
            return null !== o2 ? true === t2 ? this.body.edges[o2] : o2 : void 0;
          } }, { key: "_addToSelection", value: function(e3) {
            e3 instanceof d ? this.selectionObj.nodes[e3.id] = e3 : this.selectionObj.edges[e3.id] = e3;
          } }, { key: "_addToHover", value: function(e3) {
            e3 instanceof d ? this.hoverObj.nodes[e3.id] = e3 : this.hoverObj.edges[e3.id] = e3;
          } }, { key: "_removeFromSelection", value: function(e3) {
            e3 instanceof d ? (delete this.selectionObj.nodes[e3.id], this._unselectConnectedEdges(e3)) : delete this.selectionObj.edges[e3.id];
          } }, { key: "unselectAll", value: function() {
            for (var e3 in this.selectionObj.nodes)
              this.selectionObj.nodes.hasOwnProperty(e3) && this.selectionObj.nodes[e3].unselect();
            for (var t2 in this.selectionObj.edges)
              this.selectionObj.edges.hasOwnProperty(t2) && this.selectionObj.edges[t2].unselect();
            this.selectionObj = { nodes: {}, edges: {} };
          } }, { key: "_getSelectedNodeCount", value: function() {
            var e3 = 0;
            for (var t2 in this.selectionObj.nodes)
              this.selectionObj.nodes.hasOwnProperty(t2) && (e3 += 1);
            return e3;
          } }, { key: "_getSelectedNode", value: function() {
            for (var e3 in this.selectionObj.nodes)
              if (this.selectionObj.nodes.hasOwnProperty(e3))
                return this.selectionObj.nodes[e3];
          } }, { key: "_getSelectedEdge", value: function() {
            for (var e3 in this.selectionObj.edges)
              if (this.selectionObj.edges.hasOwnProperty(e3))
                return this.selectionObj.edges[e3];
          } }, { key: "_getSelectedEdgeCount", value: function() {
            var e3 = 0;
            for (var t2 in this.selectionObj.edges)
              this.selectionObj.edges.hasOwnProperty(t2) && (e3 += 1);
            return e3;
          } }, { key: "_getSelectedObjectCount", value: function() {
            var e3 = 0;
            for (var t2 in this.selectionObj.nodes)
              this.selectionObj.nodes.hasOwnProperty(t2) && (e3 += 1);
            for (var i2 in this.selectionObj.edges)
              this.selectionObj.edges.hasOwnProperty(i2) && (e3 += 1);
            return e3;
          } }, { key: "_selectionIsEmpty", value: function() {
            for (var e3 in this.selectionObj.nodes)
              if (this.selectionObj.nodes.hasOwnProperty(e3))
                return false;
            for (var t2 in this.selectionObj.edges)
              if (this.selectionObj.edges.hasOwnProperty(t2))
                return false;
            return true;
          } }, { key: "_clusterInSelection", value: function() {
            for (var e3 in this.selectionObj.nodes)
              if (this.selectionObj.nodes.hasOwnProperty(e3) && this.selectionObj.nodes[e3].clusterSize > 1)
                return true;
            return false;
          } }, { key: "_selectConnectedEdges", value: function(e3) {
            for (var t2 = 0; t2 < e3.edges.length; t2++) {
              var i2 = e3.edges[t2];
              i2.select(), this._addToSelection(i2);
            }
          } }, { key: "_hoverConnectedEdges", value: function(e3) {
            for (var t2 = 0; t2 < e3.edges.length; t2++) {
              var i2 = e3.edges[t2];
              i2.hover = true, this._addToHover(i2);
            }
          } }, { key: "_unselectConnectedEdges", value: function(e3) {
            for (var t2 = 0; t2 < e3.edges.length; t2++) {
              var i2 = e3.edges[t2];
              i2.unselect(), this._removeFromSelection(i2);
            }
          } }, { key: "emitBlurEvent", value: function(e3, t2, i2) {
            var n2 = this._initBaseEvent(e3, t2);
            true === i2.hover && (i2.hover = false, i2 instanceof d ? (n2.node = i2.id, this.body.emitter.emit("blurNode", n2)) : (n2.edge = i2.id, this.body.emitter.emit("blurEdge", n2)));
          } }, { key: "emitHoverEvent", value: function(e3, t2, i2) {
            var n2 = this._initBaseEvent(e3, t2), o2 = false;
            return false === i2.hover && (i2.hover = true, this._addToHover(i2), o2 = true, i2 instanceof d ? (n2.node = i2.id, this.body.emitter.emit("hoverNode", n2)) : (n2.edge = i2.id, this.body.emitter.emit("hoverEdge", n2))), o2;
          } }, { key: "hoverObject", value: function(e3, t2) {
            var i2 = this.getNodeAt(t2);
            void 0 === i2 && (i2 = this.getEdgeAt(t2));
            var n2 = false;
            for (var o2 in this.hoverObj.nodes)
              this.hoverObj.nodes.hasOwnProperty(o2) && (void 0 === i2 || i2 instanceof d && i2.id != o2 || i2 instanceof h) && (this.emitBlurEvent(e3, t2, this.hoverObj.nodes[o2]), delete this.hoverObj.nodes[o2], n2 = true);
            for (var s2 in this.hoverObj.edges)
              this.hoverObj.edges.hasOwnProperty(s2) && (true === n2 ? (this.hoverObj.edges[s2].hover = false, delete this.hoverObj.edges[s2]) : (void 0 === i2 || i2 instanceof h && i2.id != s2 || i2 instanceof d && !i2.hover) && (this.emitBlurEvent(e3, t2, this.hoverObj.edges[s2]), delete this.hoverObj.edges[s2], n2 = true));
            void 0 !== i2 && (n2 = n2 || this.emitHoverEvent(e3, t2, i2), i2 instanceof d && true === this.options.hoverConnectedEdges && this._hoverConnectedEdges(i2)), true === n2 && this.body.emitter.emit("_requestRedraw");
          } }, { key: "getSelection", value: function() {
            return { nodes: this.getSelectedNodes(), edges: this.getSelectedEdges() };
          } }, { key: "getSelectedNodes", value: function() {
            var e3 = [];
            if (true === this.options.selectable)
              for (var t2 in this.selectionObj.nodes)
                this.selectionObj.nodes.hasOwnProperty(t2) && e3.push(this.selectionObj.nodes[t2].id);
            return e3;
          } }, { key: "getSelectedEdges", value: function() {
            var e3 = [];
            if (true === this.options.selectable)
              for (var t2 in this.selectionObj.edges)
                this.selectionObj.edges.hasOwnProperty(t2) && e3.push(this.selectionObj.edges[t2].id);
            return e3;
          } }, { key: "setSelection", value: function(e3) {
            var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, i2 = void 0, n2 = void 0;
            if (!e3 || !e3.nodes && !e3.edges)
              throw "Selection must be an object with nodes and/or edges properties";
            if ((t2.unselectAll || void 0 === t2.unselectAll) && this.unselectAll(), e3.nodes)
              for (i2 = 0; i2 < e3.nodes.length; i2++) {
                n2 = e3.nodes[i2];
                var o2 = this.body.nodes[n2];
                if (!o2)
                  throw new RangeError('Node with id "' + n2 + '" not found');
                this.selectObject(o2, t2.highlightEdges);
              }
            if (e3.edges)
              for (i2 = 0; i2 < e3.edges.length; i2++) {
                n2 = e3.edges[i2];
                var s2 = this.body.edges[n2];
                if (!s2)
                  throw new RangeError('Edge with id "' + n2 + '" not found');
                this.selectObject(s2);
              }
            this.body.emitter.emit("_requestRedraw");
          } }, { key: "selectNodes", value: function(e3) {
            var t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
            if (!e3 || void 0 === e3.length)
              throw "Selection must be an array with ids";
            this.setSelection({ nodes: e3 }, { highlightEdges: t2 });
          } }, { key: "selectEdges", value: function(e3) {
            if (!e3 || void 0 === e3.length)
              throw "Selection must be an array with ids";
            this.setSelection({ edges: e3 });
          } }, { key: "updateSelection", value: function() {
            for (var e3 in this.selectionObj.nodes)
              this.selectionObj.nodes.hasOwnProperty(e3) && (this.body.nodes.hasOwnProperty(e3) || delete this.selectionObj.nodes[e3]);
            for (var t2 in this.selectionObj.edges)
              this.selectionObj.edges.hasOwnProperty(t2) && (this.body.edges.hasOwnProperty(t2) || delete this.selectionObj.edges[t2]);
          } }, { key: "getClickedItems", value: function(e3) {
            for (var t2 = this.canvas.DOMtoCanvas(e3), i2 = [], n2 = this.body.nodeIndices, o2 = this.body.nodes, s2 = n2.length - 1; s2 >= 0; s2--) {
              var r2 = o2[n2[s2]], a2 = r2.getItemsOnPoint(t2);
              i2.push.apply(i2, a2);
            }
            for (var d2 = this.body.edgeIndices, h2 = this.body.edges, l2 = d2.length - 1; l2 >= 0; l2--) {
              var u2 = h2[d2[l2]], c = u2.getItemsOnPoint(t2);
              i2.push.apply(i2, c);
            }
            return i2;
          } }]), e2;
        }();
        t.default = u;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(23), s = n(o), r = i(7), a = n(r), d = i(10), h = n(d), l = i(0), u = n(l), c = i(1), f = n(c), p = i(5), v = i(57).default, g = i(186), y = g.HorizontalStrategy, m = g.VerticalStrategy, b = function() {
          function e2() {
            (0, u.default)(this, e2), this.childrenReference = {}, this.parentReference = {}, this.trees = {}, this.distributionOrdering = {}, this.levels = {}, this.distributionIndex = {}, this.isTree = false, this.treeIndex = -1;
          }
          return (0, f.default)(e2, [{ key: "addRelation", value: function(e3, t2) {
            void 0 === this.childrenReference[e3] && (this.childrenReference[e3] = []), this.childrenReference[e3].push(t2), void 0 === this.parentReference[t2] && (this.parentReference[t2] = []), this.parentReference[t2].push(e3);
          } }, { key: "checkIfTree", value: function() {
            for (var e3 in this.parentReference)
              if (this.parentReference[e3].length > 1)
                return void (this.isTree = false);
            this.isTree = true;
          } }, { key: "numTrees", value: function() {
            return this.treeIndex + 1;
          } }, { key: "setTreeIndex", value: function(e3, t2) {
            void 0 !== t2 && void 0 === this.trees[e3.id] && (this.trees[e3.id] = t2, this.treeIndex = Math.max(t2, this.treeIndex));
          } }, { key: "ensureLevel", value: function(e3) {
            void 0 === this.levels[e3] && (this.levels[e3] = 0);
          } }, { key: "getMaxLevel", value: function(e3) {
            var t2 = this, i2 = {};
            return function e4(n2) {
              if (void 0 !== i2[n2])
                return i2[n2];
              var o2 = t2.levels[n2];
              if (t2.childrenReference[n2]) {
                var s2 = t2.childrenReference[n2];
                if (s2.length > 0)
                  for (var r2 = 0; r2 < s2.length; r2++)
                    o2 = Math.max(o2, e4(s2[r2]));
              }
              return i2[n2] = o2, o2;
            }(e3);
          } }, { key: "levelDownstream", value: function(e3, t2) {
            void 0 === this.levels[t2.id] && (void 0 === this.levels[e3.id] && (this.levels[e3.id] = 0), this.levels[t2.id] = this.levels[e3.id] + 1);
          } }, { key: "setMinLevelToZero", value: function(e3) {
            var t2 = 1e9;
            for (var i2 in e3)
              e3.hasOwnProperty(i2) && void 0 !== this.levels[i2] && (t2 = Math.min(this.levels[i2], t2));
            for (var n2 in e3)
              e3.hasOwnProperty(n2) && void 0 !== this.levels[n2] && (this.levels[n2] -= t2);
          } }, { key: "getTreeSize", value: function(e3, t2) {
            var i2 = 1e9, n2 = -1e9, o2 = 1e9, s2 = -1e9;
            for (var r2 in this.trees)
              if (this.trees.hasOwnProperty(r2) && this.trees[r2] === t2) {
                var a2 = e3[r2];
                i2 = Math.min(a2.x, i2), n2 = Math.max(a2.x, n2), o2 = Math.min(a2.y, o2), s2 = Math.max(a2.y, s2);
              }
            return { min_x: i2, max_x: n2, min_y: o2, max_y: s2 };
          } }, { key: "hasSameParent", value: function(e3, t2) {
            var i2 = this.parentReference[e3.id], n2 = this.parentReference[t2.id];
            if (void 0 === i2 || void 0 === n2)
              return false;
            for (var o2 = 0; o2 < i2.length; o2++)
              for (var s2 = 0; s2 < n2.length; s2++)
                if (i2[o2] == n2[s2])
                  return true;
            return false;
          } }, { key: "inSameSubNetwork", value: function(e3, t2) {
            return this.trees[e3.id] === this.trees[t2.id];
          } }, { key: "getLevels", value: function() {
            return (0, h.default)(this.distributionOrdering);
          } }, { key: "addToOrdering", value: function(e3, t2) {
            void 0 === this.distributionOrdering[t2] && (this.distributionOrdering[t2] = []);
            var i2 = false, n2 = this.distributionOrdering[t2];
            for (var o2 in n2)
              if (n2[o2] === e3) {
                i2 = true;
                break;
              }
            i2 || (this.distributionOrdering[t2].push(e3), this.distributionIndex[e3.id] = this.distributionOrdering[t2].length - 1);
          } }]), e2;
        }(), _ = function() {
          function e2(t2) {
            (0, u.default)(this, e2), this.body = t2, this.initialRandomSeed = Math.round(1e6 * Math.random()), this.randomSeed = this.initialRandomSeed, this.setPhysics = false, this.options = {}, this.optionsBackup = { physics: {} }, this.defaultOptions = { randomSeed: void 0, improvedLayout: true, hierarchical: { enabled: false, levelSeparation: 150, nodeSpacing: 100, treeSpacing: 200, blockShifting: true, edgeMinimization: true, parentCentralization: true, direction: "UD", sortMethod: "hubsize" } }, p.extend(this.options, this.defaultOptions), this.bindEventListeners();
          }
          return (0, f.default)(e2, [{ key: "bindEventListeners", value: function() {
            var e3 = this;
            this.body.emitter.on("_dataChanged", function() {
              e3.setupHierarchicalLayout();
            }), this.body.emitter.on("_dataLoaded", function() {
              e3.layoutNetwork();
            }), this.body.emitter.on("_resetHierarchicalLayout", function() {
              e3.setupHierarchicalLayout();
            }), this.body.emitter.on("_adjustEdgesForHierarchicalLayout", function() {
              if (true === e3.options.hierarchical.enabled) {
                var t2 = e3.direction.curveType();
                e3.body.emitter.emit("_forceDisableDynamicCurves", t2, false);
              }
            });
          } }, { key: "setOptions", value: function(e3, t2) {
            if (void 0 !== e3) {
              var i2 = this.options.hierarchical, n2 = i2.enabled;
              if (p.selectiveDeepExtend(["randomSeed", "improvedLayout"], this.options, e3), p.mergeOptions(this.options, e3, "hierarchical"), void 0 !== e3.randomSeed && (this.initialRandomSeed = e3.randomSeed), true === i2.enabled)
                return true === n2 && this.body.emitter.emit("refresh", true), "RL" === i2.direction || "DU" === i2.direction ? i2.levelSeparation > 0 && (i2.levelSeparation *= -1) : i2.levelSeparation < 0 && (i2.levelSeparation *= -1), this.setDirectionStrategy(), this.body.emitter.emit("_resetHierarchicalLayout"), this.adaptAllOptionsForHierarchicalLayout(t2);
              if (true === n2)
                return this.body.emitter.emit("refresh"), p.deepExtend(t2, this.optionsBackup);
            }
            return t2;
          } }, { key: "adaptAllOptionsForHierarchicalLayout", value: function(e3) {
            if (true === this.options.hierarchical.enabled) {
              var t2 = this.optionsBackup.physics;
              void 0 === e3.physics || true === e3.physics ? (e3.physics = { enabled: void 0 === t2.enabled || t2.enabled, solver: "hierarchicalRepulsion" }, t2.enabled = void 0 === t2.enabled || t2.enabled, t2.solver = t2.solver || "barnesHut") : "object" === (0, a.default)(e3.physics) ? (t2.enabled = void 0 === e3.physics.enabled || e3.physics.enabled, t2.solver = e3.physics.solver || "barnesHut", e3.physics.solver = "hierarchicalRepulsion") : false !== e3.physics && (t2.solver = "barnesHut", e3.physics = { solver: "hierarchicalRepulsion" });
              var i2 = this.direction.curveType();
              if (void 0 === e3.edges)
                this.optionsBackup.edges = { smooth: { enabled: true, type: "dynamic" } }, e3.edges = { smooth: false };
              else if (void 0 === e3.edges.smooth)
                this.optionsBackup.edges = { smooth: { enabled: true, type: "dynamic" } }, e3.edges.smooth = false;
              else if ("boolean" == typeof e3.edges.smooth)
                this.optionsBackup.edges = { smooth: e3.edges.smooth }, e3.edges.smooth = { enabled: e3.edges.smooth, type: i2 };
              else {
                var n2 = e3.edges.smooth;
                void 0 !== n2.type && "dynamic" !== n2.type && (i2 = n2.type), this.optionsBackup.edges = { smooth: void 0 === n2.enabled || n2.enabled, type: void 0 === n2.type ? "dynamic" : n2.type, roundness: void 0 === n2.roundness ? 0.5 : n2.roundness, forceDirection: void 0 !== n2.forceDirection && n2.forceDirection }, e3.edges.smooth = { enabled: void 0 === n2.enabled || n2.enabled, type: i2, roundness: void 0 === n2.roundness ? 0.5 : n2.roundness, forceDirection: void 0 !== n2.forceDirection && n2.forceDirection };
              }
              this.body.emitter.emit("_forceDisableDynamicCurves", i2);
            }
            return e3;
          } }, { key: "seededRandom", value: function() {
            var e3 = 1e4 * Math.sin(this.randomSeed++);
            return e3 - Math.floor(e3);
          } }, { key: "positionInitially", value: function(e3) {
            if (true !== this.options.hierarchical.enabled) {
              this.randomSeed = this.initialRandomSeed;
              for (var t2 = e3.length + 50, i2 = 0; i2 < e3.length; i2++) {
                var n2 = e3[i2], o2 = 2 * Math.PI * this.seededRandom();
                void 0 === n2.x && (n2.x = t2 * Math.cos(o2)), void 0 === n2.y && (n2.y = t2 * Math.sin(o2));
              }
            }
          } }, { key: "layoutNetwork", value: function() {
            if (true !== this.options.hierarchical.enabled && true === this.options.improvedLayout) {
              for (var e3 = this.body.nodeIndices, t2 = 0, i2 = 0; i2 < e3.length; i2++) {
                true === this.body.nodes[e3[i2]].predefinedPosition && (t2 += 1);
              }
              if (t2 < 0.5 * e3.length) {
                var n2 = 0, o2 = { clusterNodeProperties: { shape: "ellipse", label: "", group: "", font: { multi: false } }, clusterEdgeProperties: { label: "", font: { multi: false }, smooth: { enabled: false } } };
                if (e3.length > 150) {
                  for (var s2 = e3.length; e3.length > 150 && n2 <= 10; ) {
                    n2 += 1;
                    var r2 = e3.length;
                    n2 % 3 == 0 ? this.body.modules.clustering.clusterBridges(o2) : this.body.modules.clustering.clusterOutliers(o2);
                    if (r2 == e3.length && n2 % 3 != 0)
                      return this._declusterAll(), this.body.emitter.emit("_layoutFailed"), void console.info("This network could not be positioned by this version of the improved layout algorithm. Please disable improvedLayout for better performance.");
                  }
                  this.body.modules.kamadaKawai.setOptions({ springLength: Math.max(150, 2 * s2) });
                }
                n2 > 10 && console.info("The clustering didn't succeed within the amount of interations allowed, progressing with partial result."), this.body.modules.kamadaKawai.solve(e3, this.body.edgeIndices, true), this._shiftToCenter();
                for (var a2 = 0; a2 < e3.length; a2++) {
                  var d2 = this.body.nodes[e3[a2]];
                  false === d2.predefinedPosition && (d2.x += 70 * (0.5 - this.seededRandom()), d2.y += 70 * (0.5 - this.seededRandom()));
                }
                this._declusterAll(), this.body.emitter.emit("_repositionBezierNodes");
              }
            }
          } }, { key: "_shiftToCenter", value: function() {
            for (var e3 = v.getRangeCore(this.body.nodes, this.body.nodeIndices), t2 = v.findCenter(e3), i2 = 0; i2 < this.body.nodeIndices.length; i2++) {
              var n2 = this.body.nodes[this.body.nodeIndices[i2]];
              n2.x -= t2.x, n2.y -= t2.y;
            }
          } }, { key: "_declusterAll", value: function() {
            for (var e3 = true; true === e3; ) {
              e3 = false;
              for (var t2 = 0; t2 < this.body.nodeIndices.length; t2++)
                true === this.body.nodes[this.body.nodeIndices[t2]].isCluster && (e3 = true, this.body.modules.clustering.openCluster(this.body.nodeIndices[t2], {}, false));
              true === e3 && this.body.emitter.emit("_dataChanged");
            }
          } }, { key: "getSeed", value: function() {
            return this.initialRandomSeed;
          } }, { key: "setupHierarchicalLayout", value: function() {
            if (true === this.options.hierarchical.enabled && this.body.nodeIndices.length > 0) {
              var e3 = void 0, t2 = void 0, i2 = false, n2 = false;
              this.lastNodeOnLevel = {}, this.hierarchical = new b();
              for (t2 in this.body.nodes)
                this.body.nodes.hasOwnProperty(t2) && (e3 = this.body.nodes[t2], void 0 !== e3.options.level ? (i2 = true, this.hierarchical.levels[t2] = e3.options.level) : n2 = true);
              if (true === n2 && true === i2)
                throw new Error("To use the hierarchical layout, nodes require either no predefined levels or levels have to be defined for all nodes.");
              if (true === n2) {
                var o2 = this.options.hierarchical.sortMethod;
                "hubsize" === o2 ? this._determineLevelsByHubsize() : "directed" === o2 ? this._determineLevelsDirected() : "custom" === o2 && this._determineLevelsCustomCallback();
              }
              for (var s2 in this.body.nodes)
                this.body.nodes.hasOwnProperty(s2) && this.hierarchical.ensureLevel(s2);
              var r2 = this._getDistribution();
              this._generateMap(), this._placeNodesByHierarchy(r2), this._condenseHierarchy(), this._shiftToCenter();
            }
          } }, { key: "_condenseHierarchy", value: function() {
            var e3 = this, t2 = false, i2 = {}, n2 = function(t3, i3) {
              var n3 = e3.hierarchical.trees;
              for (var o3 in n3)
                n3.hasOwnProperty(o3) && n3[o3] === t3 && e3.direction.shift(o3, i3);
            }, o2 = function() {
              for (var t3 = [], i3 = 0; i3 < e3.hierarchical.numTrees(); i3++)
                t3.push(e3.direction.getTreeSize(i3));
              return t3;
            }, r2 = function t3(i3, n3) {
              if (!n3[i3.id] && (n3[i3.id] = true, e3.hierarchical.childrenReference[i3.id])) {
                var o3 = e3.hierarchical.childrenReference[i3.id];
                if (o3.length > 0)
                  for (var s2 = 0; s2 < o3.length; s2++)
                    t3(e3.body.nodes[o3[s2]], n3);
              }
            }, a2 = function(t3) {
              var i3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1e9, n3 = 1e9, o3 = 1e9, r3 = 1e9, a3 = -1e9;
              for (var d3 in t3)
                if (t3.hasOwnProperty(d3)) {
                  var h3 = e3.body.nodes[d3], l3 = e3.hierarchical.levels[h3.id], u3 = e3.direction.getPosition(h3), c2 = e3._getSpaceAroundNode(h3, t3), f2 = (0, s.default)(c2, 2), p2 = f2[0], v2 = f2[1];
                  n3 = Math.min(p2, n3), o3 = Math.min(v2, o3), l3 <= i3 && (r3 = Math.min(u3, r3), a3 = Math.max(u3, a3));
                }
              return [r3, a3, n3, o3];
            }, d2 = function(t3, i3) {
              var n3 = e3.hierarchical.getMaxLevel(t3.id), o3 = e3.hierarchical.getMaxLevel(i3.id);
              return Math.min(n3, o3);
            }, h2 = function(t3, i3, n3) {
              for (var o3 = e3.hierarchical, s2 = 0; s2 < i3.length; s2++) {
                var r3 = i3[s2], a3 = o3.distributionOrdering[r3];
                if (a3.length > 1)
                  for (var d3 = 0; d3 < a3.length - 1; d3++) {
                    var h3 = a3[d3], l3 = a3[d3 + 1];
                    o3.hasSameParent(h3, l3) && o3.inSameSubNetwork(h3, l3) && t3(h3, l3, n3);
                  }
              }
            }, l2 = function(i3, n3) {
              var o3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], s2 = e3.direction.getPosition(i3), h3 = e3.direction.getPosition(n3), l3 = Math.abs(h3 - s2), u3 = e3.options.hierarchical.nodeSpacing;
              if (l3 > u3) {
                var c2 = {}, f2 = {};
                r2(i3, c2), r2(n3, f2);
                var p2 = d2(i3, n3), v2 = a2(c2, p2), g2 = a2(f2, p2), y2 = v2[1], m2 = g2[0], b2 = g2[2];
                if (Math.abs(y2 - m2) > u3) {
                  var _2 = y2 - m2 + u3;
                  _2 < -b2 + u3 && (_2 = -b2 + u3), _2 < 0 && (e3._shiftBlock(n3.id, _2), t2 = true, true === o3 && e3._centerParent(n3));
                }
              }
            }, u2 = function(n3, o3) {
              for (var d3 = o3.id, h3 = o3.edges, l3 = e3.hierarchical.levels[o3.id], u3 = e3.options.hierarchical.levelSeparation * e3.options.hierarchical.levelSeparation, c2 = {}, f2 = [], p2 = 0; p2 < h3.length; p2++) {
                var v2 = h3[p2];
                if (v2.toId != v2.fromId) {
                  var g2 = v2.toId == d3 ? v2.from : v2.to;
                  c2[h3[p2].id] = g2, e3.hierarchical.levels[g2.id] < l3 && f2.push(v2);
                }
              }
              var y2 = function(t3, i3) {
                for (var n4 = 0, o4 = 0; o4 < i3.length; o4++)
                  if (void 0 !== c2[i3[o4].id]) {
                    var s2 = e3.direction.getPosition(c2[i3[o4].id]) - t3;
                    n4 += s2 / Math.sqrt(s2 * s2 + u3);
                  }
                return n4;
              }, m2 = function(t3, i3) {
                for (var n4 = 0, o4 = 0; o4 < i3.length; o4++)
                  if (void 0 !== c2[i3[o4].id]) {
                    var s2 = e3.direction.getPosition(c2[i3[o4].id]) - t3;
                    n4 -= u3 * Math.pow(s2 * s2 + u3, -1.5);
                  }
                return n4;
              }, b2 = function(t3, i3) {
                for (var n4 = e3.direction.getPosition(o3), s2 = {}, r3 = 0; r3 < t3; r3++) {
                  var a3 = y2(n4, i3), d4 = m2(n4, i3);
                  if (n4 -= Math.max(-40, Math.min(40, Math.round(a3 / d4))), void 0 !== s2[n4])
                    break;
                  s2[n4] = r3;
                }
                return n4;
              }, _2 = b2(n3, f2);
              !function(n4) {
                var s2 = e3.direction.getPosition(o3);
                if (void 0 === i2[o3.id]) {
                  var d4 = {};
                  r2(o3, d4), i2[o3.id] = d4;
                }
                var h4 = a2(i2[o3.id]), l4 = h4[2], u4 = h4[3], c3 = n4 - s2, f3 = 0;
                c3 > 0 ? f3 = Math.min(c3, u4 - e3.options.hierarchical.nodeSpacing) : c3 < 0 && (f3 = -Math.min(-c3, l4 - e3.options.hierarchical.nodeSpacing)), 0 != f3 && (e3._shiftBlock(o3.id, f3), t2 = true);
              }(_2), _2 = b2(n3, h3), function(i3) {
                var n4 = e3.direction.getPosition(o3), r3 = e3._getSpaceAroundNode(o3), a3 = (0, s.default)(r3, 2), d4 = a3[0], h4 = a3[1], l4 = i3 - n4, u4 = n4;
                l4 > 0 ? u4 = Math.min(n4 + (h4 - e3.options.hierarchical.nodeSpacing), i3) : l4 < 0 && (u4 = Math.max(n4 - (d4 - e3.options.hierarchical.nodeSpacing), i3)), u4 !== n4 && (e3.direction.setPosition(o3, u4), t2 = true);
              }(_2);
            };
            true === this.options.hierarchical.blockShifting && (function(i3) {
              var n3 = e3.hierarchical.getLevels();
              n3 = n3.reverse();
              for (var o3 = 0; o3 < i3 && (t2 = false, h2(l2, n3, true), true === t2); o3++)
                ;
            }(5), function() {
              for (var t3 in e3.body.nodes)
                e3.body.nodes.hasOwnProperty(t3) && e3._centerParent(e3.body.nodes[t3]);
            }()), true === this.options.hierarchical.edgeMinimization && function(i3) {
              var n3 = e3.hierarchical.getLevels();
              n3 = n3.reverse();
              for (var o3 = 0; o3 < i3; o3++) {
                t2 = false;
                for (var s2 = 0; s2 < n3.length; s2++)
                  for (var r3 = n3[s2], a3 = e3.hierarchical.distributionOrdering[r3], d3 = 0; d3 < a3.length; d3++)
                    u2(1e3, a3[d3]);
                if (true !== t2)
                  break;
              }
            }(20), true === this.options.hierarchical.parentCentralization && function() {
              var t3 = e3.hierarchical.getLevels();
              t3 = t3.reverse();
              for (var i3 = 0; i3 < t3.length; i3++)
                for (var n3 = t3[i3], o3 = e3.hierarchical.distributionOrdering[n3], s2 = 0; s2 < o3.length; s2++)
                  e3._centerParent(o3[s2]);
            }(), function() {
              for (var t3 = o2(), i3 = 0, s2 = 0; s2 < t3.length - 1; s2++) {
                i3 += t3[s2].max - t3[s2 + 1].min + e3.options.hierarchical.treeSpacing, n2(s2 + 1, i3);
              }
            }();
          } }, { key: "_getSpaceAroundNode", value: function(e3, t2) {
            var i2 = true;
            void 0 === t2 && (i2 = false);
            var n2 = this.hierarchical.levels[e3.id];
            if (void 0 !== n2) {
              var o2 = this.hierarchical.distributionIndex[e3.id], s2 = this.direction.getPosition(e3), r2 = this.hierarchical.distributionOrdering[n2], a2 = 1e9, d2 = 1e9;
              if (0 !== o2) {
                var h2 = r2[o2 - 1];
                if (true === i2 && void 0 === t2[h2.id] || false === i2) {
                  a2 = s2 - this.direction.getPosition(h2);
                }
              }
              if (o2 != r2.length - 1) {
                var l2 = r2[o2 + 1];
                if (true === i2 && void 0 === t2[l2.id] || false === i2) {
                  var u2 = this.direction.getPosition(l2);
                  d2 = Math.min(d2, u2 - s2);
                }
              }
              return [a2, d2];
            }
            return [0, 0];
          } }, { key: "_centerParent", value: function(e3) {
            if (this.hierarchical.parentReference[e3.id])
              for (var t2 = this.hierarchical.parentReference[e3.id], i2 = 0; i2 < t2.length; i2++) {
                var n2 = t2[i2], o2 = this.body.nodes[n2], r2 = this.hierarchical.childrenReference[n2];
                if (void 0 !== r2) {
                  var a2 = this._getCenterPosition(r2), d2 = this.direction.getPosition(o2), h2 = this._getSpaceAroundNode(o2), l2 = (0, s.default)(h2, 2), u2 = l2[0], c2 = l2[1], f2 = d2 - a2;
                  (f2 < 0 && Math.abs(f2) < c2 - this.options.hierarchical.nodeSpacing || f2 > 0 && Math.abs(f2) < u2 - this.options.hierarchical.nodeSpacing) && this.direction.setPosition(o2, a2);
                }
              }
          } }, { key: "_placeNodesByHierarchy", value: function(e3) {
            this.positionedNodes = {};
            for (var t2 in e3)
              if (e3.hasOwnProperty(t2)) {
                var i2 = (0, h.default)(e3[t2]);
                i2 = this._indexArrayToNodes(i2), this.direction.sort(i2);
                for (var n2 = 0, o2 = 0; o2 < i2.length; o2++) {
                  var s2 = i2[o2];
                  if (void 0 === this.positionedNodes[s2.id]) {
                    var r2 = this.options.hierarchical.nodeSpacing, a2 = r2 * n2;
                    n2 > 0 && (a2 = this.direction.getPosition(i2[o2 - 1]) + r2), this.direction.setPosition(s2, a2, t2), this._validatePositionAndContinue(s2, t2, a2), n2++;
                  }
                }
              }
          } }, { key: "_placeBranchNodes", value: function(e3, t2) {
            var i2 = this.hierarchical.childrenReference[e3];
            if (void 0 !== i2) {
              for (var n2 = [], o2 = 0; o2 < i2.length; o2++)
                n2.push(this.body.nodes[i2[o2]]);
              this.direction.sort(n2);
              for (var s2 = 0; s2 < n2.length; s2++) {
                var r2 = n2[s2], a2 = this.hierarchical.levels[r2.id];
                if (!(a2 > t2 && void 0 === this.positionedNodes[r2.id]))
                  return;
                var d2 = this.options.hierarchical.nodeSpacing, h2 = void 0;
                h2 = 0 === s2 ? this.direction.getPosition(this.body.nodes[e3]) : this.direction.getPosition(n2[s2 - 1]) + d2, this.direction.setPosition(r2, h2, a2), this._validatePositionAndContinue(r2, a2, h2);
              }
              var l2 = this._getCenterPosition(n2);
              this.direction.setPosition(this.body.nodes[e3], l2, t2);
            }
          } }, { key: "_validatePositionAndContinue", value: function(e3, t2, i2) {
            if (this.hierarchical.isTree) {
              if (void 0 !== this.lastNodeOnLevel[t2]) {
                var n2 = this.direction.getPosition(this.body.nodes[this.lastNodeOnLevel[t2]]);
                if (i2 - n2 < this.options.hierarchical.nodeSpacing) {
                  var o2 = n2 + this.options.hierarchical.nodeSpacing - i2, s2 = this._findCommonParent(this.lastNodeOnLevel[t2], e3.id);
                  this._shiftBlock(s2.withChild, o2);
                }
              }
              this.lastNodeOnLevel[t2] = e3.id, this.positionedNodes[e3.id] = true, this._placeBranchNodes(e3.id, t2);
            }
          } }, { key: "_indexArrayToNodes", value: function(e3) {
            for (var t2 = [], i2 = 0; i2 < e3.length; i2++)
              t2.push(this.body.nodes[e3[i2]]);
            return t2;
          } }, { key: "_getDistribution", value: function() {
            var e3 = {}, t2 = void 0, i2 = void 0;
            for (t2 in this.body.nodes)
              if (this.body.nodes.hasOwnProperty(t2)) {
                i2 = this.body.nodes[t2];
                var n2 = void 0 === this.hierarchical.levels[t2] ? 0 : this.hierarchical.levels[t2];
                this.direction.fix(i2, n2), void 0 === e3[n2] && (e3[n2] = {}), e3[n2][t2] = i2;
              }
            return e3;
          } }, { key: "_getActiveEdges", value: function(e3) {
            var t2 = this, i2 = [];
            return p.forEach(e3.edges, function(e4) {
              -1 !== t2.body.edgeIndices.indexOf(e4.id) && i2.push(e4);
            }), i2;
          } }, { key: "_getHubSizes", value: function() {
            var e3 = this, t2 = {}, i2 = this.body.nodeIndices;
            p.forEach(i2, function(i3) {
              var n3 = e3.body.nodes[i3], o2 = e3._getActiveEdges(n3).length;
              t2[o2] = true;
            });
            var n2 = [];
            return p.forEach(t2, function(e4) {
              n2.push(Number(e4));
            }), n2.sort(function(e4, t3) {
              return t3 - e4;
            }), n2;
          } }, { key: "_determineLevelsByHubsize", value: function() {
            for (var e3 = this, t2 = function(t3, i3) {
              e3.hierarchical.levelDownstream(t3, i3);
            }, i2 = this._getHubSizes(), n2 = 0; n2 < i2.length; ++n2) {
              if ("break" === function(n3) {
                var o2 = i2[n3];
                if (0 === o2)
                  return "break";
                p.forEach(e3.body.nodeIndices, function(i3) {
                  var n4 = e3.body.nodes[i3];
                  o2 === e3._getActiveEdges(n4).length && e3._crawlNetwork(t2, i3);
                });
              }(n2))
                break;
            }
          } }, { key: "_determineLevelsCustomCallback", value: function() {
            var e3 = this, t2 = function(t3, i2, n2) {
              var o2 = e3.hierarchical.levels[t3.id];
              void 0 === o2 && (o2 = e3.hierarchical.levels[t3.id] = 1e5);
              var s2 = (v.cloneOptions(t3, "node"), v.cloneOptions(i2, "node"), void v.cloneOptions(n2, "edge"));
              e3.hierarchical.levels[i2.id] = o2 + s2;
            };
            this._crawlNetwork(t2), this.hierarchical.setMinLevelToZero(this.body.nodes);
          } }, { key: "_determineLevelsDirected", value: function() {
            var e3 = this, t2 = function(t3) {
              return p.forEach(e3.body.edges, function(e4) {
                if (e4.toId === t3.fromId && e4.fromId === t3.toId)
                  return true;
              }), false;
            }, i2 = function(i3, n2, o2) {
              var s2 = e3.hierarchical.levels[i3.id], r2 = e3.hierarchical.levels[n2.id];
              t2(o2) && void 0 !== s2 && void 0 !== r2 || (void 0 === s2 && (s2 = e3.hierarchical.levels[i3.id] = 1e4), o2.toId == n2.id ? e3.hierarchical.levels[n2.id] = s2 + 1 : e3.hierarchical.levels[n2.id] = s2 - 1);
            };
            this._crawlNetwork(i2), this.hierarchical.setMinLevelToZero(this.body.nodes);
          } }, { key: "_generateMap", value: function() {
            var e3 = this, t2 = function(t3, i2) {
              e3.hierarchical.levels[i2.id] > e3.hierarchical.levels[t3.id] && e3.hierarchical.addRelation(t3.id, i2.id);
            };
            this._crawlNetwork(t2), this.hierarchical.checkIfTree();
          } }, { key: "_crawlNetwork", value: function() {
            var e3 = this, t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : function() {
            }, i2 = arguments[1], n2 = {}, o2 = function i3(o3, s3) {
              if (void 0 === n2[o3.id]) {
                e3.hierarchical.setTreeIndex(o3, s3), n2[o3.id] = true;
                for (var r3 = void 0, a3 = e3._getActiveEdges(o3), d3 = 0; d3 < a3.length; d3++) {
                  var h3 = a3[d3];
                  true === h3.connected && (r3 = h3.toId == o3.id ? h3.from : h3.to, o3.id != r3.id && (t2(o3, r3, h3), i3(r3, s3)));
                }
              }
            };
            if (void 0 === i2)
              for (var s2 = 0, r2 = 0; r2 < this.body.nodeIndices.length; r2++) {
                var a2 = this.body.nodeIndices[r2];
                if (void 0 === n2[a2]) {
                  var d2 = this.body.nodes[a2];
                  o2(d2, s2), s2 += 1;
                }
              }
            else {
              var h2 = this.body.nodes[i2];
              if (void 0 === h2)
                return void console.error("Node not found:", i2);
              o2(h2);
            }
          } }, { key: "_shiftBlock", value: function(e3, t2) {
            var i2 = this, n2 = {};
            !function e4(o2) {
              if (!n2[o2]) {
                n2[o2] = true, i2.direction.shift(o2, t2);
                var s2 = i2.hierarchical.childrenReference[o2];
                if (void 0 !== s2)
                  for (var r2 = 0; r2 < s2.length; r2++)
                    e4(s2[r2]);
              }
            }(e3);
          } }, { key: "_findCommonParent", value: function(e3, t2) {
            var i2 = this, n2 = {};
            return function e4(t3, n3) {
              var o2 = i2.hierarchical.parentReference[n3];
              if (void 0 !== o2)
                for (var s2 = 0; s2 < o2.length; s2++) {
                  var r2 = o2[s2];
                  t3[r2] = true, e4(t3, r2);
                }
            }(n2, e3), function e4(t3, n3) {
              var o2 = i2.hierarchical.parentReference[n3];
              if (void 0 !== o2)
                for (var s2 = 0; s2 < o2.length; s2++) {
                  var r2 = o2[s2];
                  if (void 0 !== t3[r2])
                    return { foundParent: r2, withChild: n3 };
                  var a2 = e4(t3, r2);
                  if (null !== a2.foundParent)
                    return a2;
                }
              return { foundParent: null, withChild: n3 };
            }(n2, t2);
          } }, { key: "setDirectionStrategy", value: function() {
            var e3 = "UD" === this.options.hierarchical.direction || "DU" === this.options.hierarchical.direction;
            this.direction = e3 ? new m(this) : new y(this);
          } }, { key: "_getCenterPosition", value: function(e3) {
            for (var t2 = 1e9, i2 = -1e9, n2 = 0; n2 < e3.length; n2++) {
              var o2 = void 0;
              if (void 0 !== e3[n2].id)
                o2 = e3[n2];
              else {
                var s2 = e3[n2];
                o2 = this.body.nodes[s2];
              }
              var r2 = this.direction.getPosition(o2);
              t2 = Math.min(t2, r2), i2 = Math.max(i2, r2);
            }
            return 0.5 * (t2 + i2);
          } }]), e2;
        }();
        t.default = _;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true }), t.VerticalStrategy = t.HorizontalStrategy = void 0;
        var o = i(2), s = n(o), r = i(3), a = n(r), d = i(4), h = n(d), l = i(0), u = n(l), c = i(1), f = n(c), p = function() {
          function e2() {
            (0, u.default)(this, e2);
          }
          return (0, f.default)(e2, [{ key: "abstract", value: function() {
            throw new Error("Can't instantiate abstract class!");
          } }, { key: "fake_use", value: function() {
          } }, { key: "curveType", value: function() {
            return this.abstract();
          } }, { key: "getPosition", value: function(e3) {
            return this.fake_use(e3), this.abstract();
          } }, { key: "setPosition", value: function(e3, t2) {
            var i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0;
            this.fake_use(e3, t2, i2), this.abstract();
          } }, { key: "getTreeSize", value: function(e3) {
            return this.fake_use(e3), this.abstract();
          } }, { key: "sort", value: function(e3) {
            this.fake_use(e3), this.abstract();
          } }, { key: "fix", value: function(e3, t2) {
            this.fake_use(e3, t2), this.abstract();
          } }, { key: "shift", value: function(e3, t2) {
            this.fake_use(e3, t2), this.abstract();
          } }]), e2;
        }(), v = function(e2) {
          function t2(e3) {
            (0, u.default)(this, t2);
            var i2 = (0, a.default)(this, (t2.__proto__ || (0, s.default)(t2)).call(this));
            return i2.layout = e3, i2;
          }
          return (0, h.default)(t2, e2), (0, f.default)(t2, [{ key: "curveType", value: function() {
            return "horizontal";
          } }, { key: "getPosition", value: function(e3) {
            return e3.x;
          } }, { key: "setPosition", value: function(e3, t3) {
            var i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0;
            void 0 !== i2 && this.layout.hierarchical.addToOrdering(e3, i2), e3.x = t3;
          } }, { key: "getTreeSize", value: function(e3) {
            var t3 = this.layout.hierarchical.getTreeSize(this.layout.body.nodes, e3);
            return { min: t3.min_x, max: t3.max_x };
          } }, { key: "sort", value: function(e3) {
            e3.sort(function(e4, t3) {
              return void 0 === e4.x || void 0 === t3.x ? 0 : e4.x - t3.x;
            });
          } }, { key: "fix", value: function(e3, t3) {
            e3.y = this.layout.options.hierarchical.levelSeparation * t3, e3.options.fixed.y = true;
          } }, { key: "shift", value: function(e3, t3) {
            this.layout.body.nodes[e3].x += t3;
          } }]), t2;
        }(p), g = function(e2) {
          function t2(e3) {
            (0, u.default)(this, t2);
            var i2 = (0, a.default)(this, (t2.__proto__ || (0, s.default)(t2)).call(this));
            return i2.layout = e3, i2;
          }
          return (0, h.default)(t2, e2), (0, f.default)(t2, [{ key: "curveType", value: function() {
            return "vertical";
          } }, { key: "getPosition", value: function(e3) {
            return e3.y;
          } }, { key: "setPosition", value: function(e3, t3) {
            var i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0;
            void 0 !== i2 && this.layout.hierarchical.addToOrdering(e3, i2), e3.y = t3;
          } }, { key: "getTreeSize", value: function(e3) {
            var t3 = this.layout.hierarchical.getTreeSize(this.layout.body.nodes, e3);
            return { min: t3.min_y, max: t3.max_y };
          } }, { key: "sort", value: function(e3) {
            e3.sort(function(e4, t3) {
              return void 0 === e4.y || void 0 === t3.y ? 0 : e4.y - t3.y;
            });
          } }, { key: "fix", value: function(e3, t3) {
            e3.x = this.layout.options.hierarchical.levelSeparation * t3, e3.options.fixed.x = true;
          } }, { key: "shift", value: function(e3, t3) {
            this.layout.body.nodes[e3].y += t3;
          } }]), t2;
        }(p);
        t.HorizontalStrategy = g, t.VerticalStrategy = v;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(10), s = n(o), r = i(21), a = n(r), d = i(7), h = n(d), l = i(0), u = n(l), c = i(1), f = n(c), p = i(5), v = i(22), g = i(35), y = function() {
          function e2(t2, i2, n2) {
            var o2 = this;
            (0, u.default)(this, e2), this.body = t2, this.canvas = i2, this.selectionHandler = n2, this.editMode = false, this.manipulationDiv = void 0, this.editModeDiv = void 0, this.closeDiv = void 0, this.manipulationHammers = [], this.temporaryUIFunctions = {}, this.temporaryEventFunctions = [], this.touchTime = 0, this.temporaryIds = { nodes: [], edges: [] }, this.guiEnabled = false, this.inMode = false, this.selectedControlNode = void 0, this.options = {}, this.defaultOptions = { enabled: false, initiallyActive: false, addNode: true, addEdge: true, editNode: void 0, editEdge: true, deleteNode: true, deleteEdge: true, controlNodeStyle: { shape: "dot", size: 6, color: { background: "#ff0000", border: "#3c3c3c", highlight: { background: "#07f968", border: "#3c3c3c" } }, borderWidth: 2, borderWidthSelected: 2 } }, p.extend(this.options, this.defaultOptions), this.body.emitter.on("destroy", function() {
              o2._clean();
            }), this.body.emitter.on("_dataChanged", this._restore.bind(this)), this.body.emitter.on("_resetData", this._restore.bind(this));
          }
          return (0, f.default)(e2, [{ key: "_restore", value: function() {
            false !== this.inMode && (true === this.options.initiallyActive ? this.enableEditMode() : this.disableEditMode());
          } }, { key: "setOptions", value: function(e3, t2, i2) {
            void 0 !== t2 && (void 0 !== t2.locale ? this.options.locale = t2.locale : this.options.locale = i2.locale, void 0 !== t2.locales ? this.options.locales = t2.locales : this.options.locales = i2.locales), void 0 !== e3 && ("boolean" == typeof e3 ? this.options.enabled = e3 : (this.options.enabled = true, p.deepExtend(this.options, e3)), true === this.options.initiallyActive && (this.editMode = true), this._setup());
          } }, { key: "toggleEditMode", value: function() {
            true === this.editMode ? this.disableEditMode() : this.enableEditMode();
          } }, { key: "enableEditMode", value: function() {
            this.editMode = true, this._clean(), true === this.guiEnabled && (this.manipulationDiv.style.display = "block", this.closeDiv.style.display = "block", this.editModeDiv.style.display = "none", this.showManipulatorToolbar());
          } }, { key: "disableEditMode", value: function() {
            this.editMode = false, this._clean(), true === this.guiEnabled && (this.manipulationDiv.style.display = "none", this.closeDiv.style.display = "none", this.editModeDiv.style.display = "block", this._createEditButton());
          } }, { key: "showManipulatorToolbar", value: function() {
            if (this._clean(), this.manipulationDOM = {}, true === this.guiEnabled) {
              this.editMode = true, this.manipulationDiv.style.display = "block", this.closeDiv.style.display = "block";
              var e3 = this.selectionHandler._getSelectedNodeCount(), t2 = this.selectionHandler._getSelectedEdgeCount(), i2 = e3 + t2, n2 = this.options.locales[this.options.locale], o2 = false;
              false !== this.options.addNode && (this._createAddNodeButton(n2), o2 = true), false !== this.options.addEdge && (true === o2 ? this._createSeperator(1) : o2 = true, this._createAddEdgeButton(n2)), 1 === e3 && "function" == typeof this.options.editNode ? (true === o2 ? this._createSeperator(2) : o2 = true, this._createEditNodeButton(n2)) : 1 === t2 && 0 === e3 && false !== this.options.editEdge && (true === o2 ? this._createSeperator(3) : o2 = true, this._createEditEdgeButton(n2)), 0 !== i2 && (e3 > 0 && false !== this.options.deleteNode ? (true === o2 && this._createSeperator(4), this._createDeleteButton(n2)) : 0 === e3 && false !== this.options.deleteEdge && (true === o2 && this._createSeperator(4), this._createDeleteButton(n2))), this._bindHammerToDiv(this.closeDiv, this.toggleEditMode.bind(this)), this._temporaryBindEvent("select", this.showManipulatorToolbar.bind(this));
            }
            this.body.emitter.emit("_redraw");
          } }, { key: "addNodeMode", value: function() {
            if (true !== this.editMode && this.enableEditMode(), this._clean(), this.inMode = "addNode", true === this.guiEnabled) {
              var e3 = this.options.locales[this.options.locale];
              this.manipulationDOM = {}, this._createBackButton(e3), this._createSeperator(), this._createDescription(e3.addDescription || this.options.locales.en.addDescription), this._bindHammerToDiv(this.closeDiv, this.toggleEditMode.bind(this));
            }
            this._temporaryBindEvent("click", this._performAddNode.bind(this));
          } }, { key: "editNode", value: function() {
            var e3 = this;
            true !== this.editMode && this.enableEditMode(), this._clean();
            var t2 = this.selectionHandler._getSelectedNode();
            if (void 0 !== t2) {
              if (this.inMode = "editNode", "function" != typeof this.options.editNode)
                throw new Error("No function has been configured to handle the editing of nodes.");
              if (true !== t2.isCluster) {
                var i2 = p.deepExtend({}, t2.options, false);
                if (i2.x = t2.x, i2.y = t2.y, 2 !== this.options.editNode.length)
                  throw new Error("The function for edit does not support two arguments (data, callback)");
                this.options.editNode(i2, function(t3) {
                  null !== t3 && void 0 !== t3 && "editNode" === e3.inMode && e3.body.data.nodes.getDataSet().update(t3), e3.showManipulatorToolbar();
                });
              } else
                alert(this.options.locales[this.options.locale].editClusterError || this.options.locales.en.editClusterError);
            } else
              this.showManipulatorToolbar();
          } }, { key: "addEdgeMode", value: function() {
            if (true !== this.editMode && this.enableEditMode(), this._clean(), this.inMode = "addEdge", true === this.guiEnabled) {
              var e3 = this.options.locales[this.options.locale];
              this.manipulationDOM = {}, this._createBackButton(e3), this._createSeperator(), this._createDescription(e3.edgeDescription || this.options.locales.en.edgeDescription), this._bindHammerToDiv(this.closeDiv, this.toggleEditMode.bind(this));
            }
            this._temporaryBindUI("onTouch", this._handleConnect.bind(this)), this._temporaryBindUI("onDragEnd", this._finishConnect.bind(this)), this._temporaryBindUI("onDrag", this._dragControlNode.bind(this)), this._temporaryBindUI("onRelease", this._finishConnect.bind(this)), this._temporaryBindUI("onDragStart", this._dragStartEdge.bind(this)), this._temporaryBindUI("onHold", function() {
            });
          } }, { key: "editEdgeMode", value: function() {
            if (true !== this.editMode && this.enableEditMode(), this._clean(), this.inMode = "editEdge", "object" === (0, h.default)(this.options.editEdge) && "function" == typeof this.options.editEdge.editWithoutDrag && (this.edgeBeingEditedId = this.selectionHandler.getSelectedEdges()[0], void 0 !== this.edgeBeingEditedId)) {
              var e3 = this.body.edges[this.edgeBeingEditedId];
              return void this._performEditEdge(e3.from, e3.to);
            }
            if (true === this.guiEnabled) {
              var t2 = this.options.locales[this.options.locale];
              this.manipulationDOM = {}, this._createBackButton(t2), this._createSeperator(), this._createDescription(t2.editEdgeDescription || this.options.locales.en.editEdgeDescription), this._bindHammerToDiv(this.closeDiv, this.toggleEditMode.bind(this));
            }
            if (this.edgeBeingEditedId = this.selectionHandler.getSelectedEdges()[0], void 0 !== this.edgeBeingEditedId) {
              var i2 = this.body.edges[this.edgeBeingEditedId], n2 = this._getNewTargetNode(i2.from.x, i2.from.y), o2 = this._getNewTargetNode(i2.to.x, i2.to.y);
              this.temporaryIds.nodes.push(n2.id), this.temporaryIds.nodes.push(o2.id), this.body.nodes[n2.id] = n2, this.body.nodeIndices.push(n2.id), this.body.nodes[o2.id] = o2, this.body.nodeIndices.push(o2.id), this._temporaryBindUI("onTouch", this._controlNodeTouch.bind(this)), this._temporaryBindUI("onTap", function() {
              }), this._temporaryBindUI("onHold", function() {
              }), this._temporaryBindUI("onDragStart", this._controlNodeDragStart.bind(this)), this._temporaryBindUI("onDrag", this._controlNodeDrag.bind(this)), this._temporaryBindUI("onDragEnd", this._controlNodeDragEnd.bind(this)), this._temporaryBindUI("onMouseMove", function() {
              }), this._temporaryBindEvent("beforeDrawing", function(e4) {
                var t3 = i2.edgeType.findBorderPositions(e4);
                false === n2.selected && (n2.x = t3.from.x, n2.y = t3.from.y), false === o2.selected && (o2.x = t3.to.x, o2.y = t3.to.y);
              }), this.body.emitter.emit("_redraw");
            } else
              this.showManipulatorToolbar();
          } }, { key: "deleteSelected", value: function() {
            var e3 = this;
            true !== this.editMode && this.enableEditMode(), this._clean(), this.inMode = "delete";
            var t2 = this.selectionHandler.getSelectedNodes(), i2 = this.selectionHandler.getSelectedEdges(), n2 = void 0;
            if (t2.length > 0) {
              for (var o2 = 0; o2 < t2.length; o2++)
                if (true === this.body.nodes[t2[o2]].isCluster)
                  return void alert(this.options.locales[this.options.locale].deleteClusterError || this.options.locales.en.deleteClusterError);
              "function" == typeof this.options.deleteNode && (n2 = this.options.deleteNode);
            } else
              i2.length > 0 && "function" == typeof this.options.deleteEdge && (n2 = this.options.deleteEdge);
            if ("function" == typeof n2) {
              var s2 = { nodes: t2, edges: i2 };
              if (2 !== n2.length)
                throw new Error("The function for delete does not support two arguments (data, callback)");
              n2(s2, function(t3) {
                null !== t3 && void 0 !== t3 && "delete" === e3.inMode ? (e3.body.data.edges.getDataSet().remove(t3.edges), e3.body.data.nodes.getDataSet().remove(t3.nodes), e3.body.emitter.emit("startSimulation"), e3.showManipulatorToolbar()) : (e3.body.emitter.emit("startSimulation"), e3.showManipulatorToolbar());
              });
            } else
              this.body.data.edges.getDataSet().remove(i2), this.body.data.nodes.getDataSet().remove(t2), this.body.emitter.emit("startSimulation"), this.showManipulatorToolbar();
          } }, { key: "_setup", value: function() {
            true === this.options.enabled ? (this.guiEnabled = true, this._createWrappers(), false === this.editMode ? this._createEditButton() : this.showManipulatorToolbar()) : (this._removeManipulationDOM(), this.guiEnabled = false);
          } }, { key: "_createWrappers", value: function() {
            void 0 === this.manipulationDiv && (this.manipulationDiv = document.createElement("div"), this.manipulationDiv.className = "vis-manipulation", true === this.editMode ? this.manipulationDiv.style.display = "block" : this.manipulationDiv.style.display = "none", this.canvas.frame.appendChild(this.manipulationDiv)), void 0 === this.editModeDiv && (this.editModeDiv = document.createElement("div"), this.editModeDiv.className = "vis-edit-mode", true === this.editMode ? this.editModeDiv.style.display = "none" : this.editModeDiv.style.display = "block", this.canvas.frame.appendChild(this.editModeDiv)), void 0 === this.closeDiv && (this.closeDiv = document.createElement("div"), this.closeDiv.className = "vis-close", this.closeDiv.style.display = this.manipulationDiv.style.display, this.canvas.frame.appendChild(this.closeDiv));
          } }, { key: "_getNewTargetNode", value: function(e3, t2) {
            var i2 = p.deepExtend({}, this.options.controlNodeStyle);
            i2.id = "targetNode" + p.randomUUID(), i2.hidden = false, i2.physics = false, i2.x = e3, i2.y = t2;
            var n2 = this.body.functions.createNode(i2);
            return n2.shape.boundingBox = { left: e3, right: e3, top: t2, bottom: t2 }, n2;
          } }, { key: "_createEditButton", value: function() {
            this._clean(), this.manipulationDOM = {}, p.recursiveDOMDelete(this.editModeDiv);
            var e3 = this.options.locales[this.options.locale], t2 = this._createButton("editMode", "vis-button vis-edit vis-edit-mode", e3.edit || this.options.locales.en.edit);
            this.editModeDiv.appendChild(t2), this._bindHammerToDiv(t2, this.toggleEditMode.bind(this));
          } }, { key: "_clean", value: function() {
            this.inMode = false, true === this.guiEnabled && (p.recursiveDOMDelete(this.editModeDiv), p.recursiveDOMDelete(this.manipulationDiv), this._cleanManipulatorHammers()), this._cleanupTemporaryNodesAndEdges(), this._unbindTemporaryUIs(), this._unbindTemporaryEvents(), this.body.emitter.emit("restorePhysics");
          } }, { key: "_cleanManipulatorHammers", value: function() {
            if (0 != this.manipulationHammers.length) {
              for (var e3 = 0; e3 < this.manipulationHammers.length; e3++)
                this.manipulationHammers[e3].destroy();
              this.manipulationHammers = [];
            }
          } }, { key: "_removeManipulationDOM", value: function() {
            this._clean(), p.recursiveDOMDelete(this.manipulationDiv), p.recursiveDOMDelete(this.editModeDiv), p.recursiveDOMDelete(this.closeDiv), this.manipulationDiv && this.canvas.frame.removeChild(this.manipulationDiv), this.editModeDiv && this.canvas.frame.removeChild(this.editModeDiv), this.closeDiv && this.canvas.frame.removeChild(this.closeDiv), this.manipulationDiv = void 0, this.editModeDiv = void 0, this.closeDiv = void 0;
          } }, { key: "_createSeperator", value: function() {
            var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
            this.manipulationDOM["seperatorLineDiv" + e3] = document.createElement("div"), this.manipulationDOM["seperatorLineDiv" + e3].className = "vis-separator-line", this.manipulationDiv.appendChild(this.manipulationDOM["seperatorLineDiv" + e3]);
          } }, { key: "_createAddNodeButton", value: function(e3) {
            var t2 = this._createButton("addNode", "vis-button vis-add", e3.addNode || this.options.locales.en.addNode);
            this.manipulationDiv.appendChild(t2), this._bindHammerToDiv(t2, this.addNodeMode.bind(this));
          } }, { key: "_createAddEdgeButton", value: function(e3) {
            var t2 = this._createButton("addEdge", "vis-button vis-connect", e3.addEdge || this.options.locales.en.addEdge);
            this.manipulationDiv.appendChild(t2), this._bindHammerToDiv(t2, this.addEdgeMode.bind(this));
          } }, { key: "_createEditNodeButton", value: function(e3) {
            var t2 = this._createButton("editNode", "vis-button vis-edit", e3.editNode || this.options.locales.en.editNode);
            this.manipulationDiv.appendChild(t2), this._bindHammerToDiv(t2, this.editNode.bind(this));
          } }, { key: "_createEditEdgeButton", value: function(e3) {
            var t2 = this._createButton("editEdge", "vis-button vis-edit", e3.editEdge || this.options.locales.en.editEdge);
            this.manipulationDiv.appendChild(t2), this._bindHammerToDiv(t2, this.editEdgeMode.bind(this));
          } }, { key: "_createDeleteButton", value: function(e3) {
            var t2;
            t2 = this.options.rtl ? "vis-button vis-delete-rtl" : "vis-button vis-delete";
            var i2 = this._createButton("delete", t2, e3.del || this.options.locales.en.del);
            this.manipulationDiv.appendChild(i2), this._bindHammerToDiv(i2, this.deleteSelected.bind(this));
          } }, { key: "_createBackButton", value: function(e3) {
            var t2 = this._createButton("back", "vis-button vis-back", e3.back || this.options.locales.en.back);
            this.manipulationDiv.appendChild(t2), this._bindHammerToDiv(t2, this.showManipulatorToolbar.bind(this));
          } }, { key: "_createButton", value: function(e3, t2, i2) {
            var n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "vis-label";
            return this.manipulationDOM[e3 + "Div"] = document.createElement("div"), this.manipulationDOM[e3 + "Div"].className = t2, this.manipulationDOM[e3 + "Label"] = document.createElement("div"), this.manipulationDOM[e3 + "Label"].className = n2, this.manipulationDOM[e3 + "Label"].innerHTML = i2, this.manipulationDOM[e3 + "Div"].appendChild(this.manipulationDOM[e3 + "Label"]), this.manipulationDOM[e3 + "Div"];
          } }, { key: "_createDescription", value: function(e3) {
            this.manipulationDiv.appendChild(this._createButton("description", "vis-button vis-none", e3));
          } }, { key: "_temporaryBindEvent", value: function(e3, t2) {
            this.temporaryEventFunctions.push({ event: e3, boundFunction: t2 }), this.body.emitter.on(e3, t2);
          } }, { key: "_temporaryBindUI", value: function(e3, t2) {
            if (void 0 === this.body.eventListeners[e3])
              throw new Error("This UI function does not exist. Typo? You tried: " + e3 + " possible are: " + (0, a.default)((0, s.default)(this.body.eventListeners)));
            this.temporaryUIFunctions[e3] = this.body.eventListeners[e3], this.body.eventListeners[e3] = t2;
          } }, { key: "_unbindTemporaryUIs", value: function() {
            for (var e3 in this.temporaryUIFunctions)
              this.temporaryUIFunctions.hasOwnProperty(e3) && (this.body.eventListeners[e3] = this.temporaryUIFunctions[e3], delete this.temporaryUIFunctions[e3]);
            this.temporaryUIFunctions = {};
          } }, { key: "_unbindTemporaryEvents", value: function() {
            for (var e3 = 0; e3 < this.temporaryEventFunctions.length; e3++) {
              var t2 = this.temporaryEventFunctions[e3].event, i2 = this.temporaryEventFunctions[e3].boundFunction;
              this.body.emitter.off(t2, i2);
            }
            this.temporaryEventFunctions = [];
          } }, { key: "_bindHammerToDiv", value: function(e3, t2) {
            var i2 = new v(e3, {});
            g.onTouch(i2, t2), this.manipulationHammers.push(i2);
          } }, { key: "_cleanupTemporaryNodesAndEdges", value: function() {
            for (var e3 = 0; e3 < this.temporaryIds.edges.length; e3++) {
              this.body.edges[this.temporaryIds.edges[e3]].disconnect(), delete this.body.edges[this.temporaryIds.edges[e3]];
              var t2 = this.body.edgeIndices.indexOf(this.temporaryIds.edges[e3]);
              -1 !== t2 && this.body.edgeIndices.splice(t2, 1);
            }
            for (var i2 = 0; i2 < this.temporaryIds.nodes.length; i2++) {
              delete this.body.nodes[this.temporaryIds.nodes[i2]];
              var n2 = this.body.nodeIndices.indexOf(this.temporaryIds.nodes[i2]);
              -1 !== n2 && this.body.nodeIndices.splice(n2, 1);
            }
            this.temporaryIds = { nodes: [], edges: [] };
          } }, { key: "_controlNodeTouch", value: function(e3) {
            this.selectionHandler.unselectAll(), this.lastTouch = this.body.functions.getPointer(e3.center), this.lastTouch.translation = p.extend({}, this.body.view.translation);
          } }, { key: "_controlNodeDragStart", value: function(e3) {
            var t2 = this.lastTouch, i2 = this.selectionHandler._pointerToPositionObject(t2), n2 = this.body.nodes[this.temporaryIds.nodes[0]], o2 = this.body.nodes[this.temporaryIds.nodes[1]], s2 = this.body.edges[this.edgeBeingEditedId];
            this.selectedControlNode = void 0;
            var r2 = n2.isOverlappingWith(i2), a2 = o2.isOverlappingWith(i2);
            true === r2 ? (this.selectedControlNode = n2, s2.edgeType.from = n2) : true === a2 && (this.selectedControlNode = o2, s2.edgeType.to = o2), void 0 !== this.selectedControlNode && this.selectionHandler.selectObject(this.selectedControlNode), this.body.emitter.emit("_redraw");
          } }, { key: "_controlNodeDrag", value: function(e3) {
            this.body.emitter.emit("disablePhysics");
            var t2 = this.body.functions.getPointer(e3.center), i2 = this.canvas.DOMtoCanvas(t2);
            if (void 0 !== this.selectedControlNode)
              this.selectedControlNode.x = i2.x, this.selectedControlNode.y = i2.y;
            else {
              var n2 = t2.x - this.lastTouch.x, o2 = t2.y - this.lastTouch.y;
              this.body.view.translation = { x: this.lastTouch.translation.x + n2, y: this.lastTouch.translation.y + o2 };
            }
            this.body.emitter.emit("_redraw");
          } }, { key: "_controlNodeDragEnd", value: function(e3) {
            var t2 = this.body.functions.getPointer(e3.center), i2 = this.selectionHandler._pointerToPositionObject(t2), n2 = this.body.edges[this.edgeBeingEditedId];
            if (void 0 !== this.selectedControlNode) {
              this.selectionHandler.unselectAll();
              for (var o2 = this.selectionHandler._getAllNodesOverlappingWith(i2), s2 = void 0, r2 = o2.length - 1; r2 >= 0; r2--)
                if (o2[r2] !== this.selectedControlNode.id) {
                  s2 = this.body.nodes[o2[r2]];
                  break;
                }
              if (void 0 !== s2 && void 0 !== this.selectedControlNode)
                if (true === s2.isCluster)
                  alert(this.options.locales[this.options.locale].createEdgeError || this.options.locales.en.createEdgeError);
                else {
                  var a2 = this.body.nodes[this.temporaryIds.nodes[0]];
                  this.selectedControlNode.id === a2.id ? this._performEditEdge(s2.id, n2.to.id) : this._performEditEdge(n2.from.id, s2.id);
                }
              else
                n2.updateEdgeType(), this.body.emitter.emit("restorePhysics");
              this.body.emitter.emit("_redraw");
            }
          } }, { key: "_handleConnect", value: function(e3) {
            if (new Date().valueOf() - this.touchTime > 100) {
              this.lastTouch = this.body.functions.getPointer(e3.center), this.lastTouch.translation = p.extend({}, this.body.view.translation);
              var t2 = this.lastTouch, i2 = this.selectionHandler.getNodeAt(t2);
              if (void 0 !== i2)
                if (true === i2.isCluster)
                  alert(this.options.locales[this.options.locale].createEdgeError || this.options.locales.en.createEdgeError);
                else {
                  var n2 = this._getNewTargetNode(i2.x, i2.y);
                  this.body.nodes[n2.id] = n2, this.body.nodeIndices.push(n2.id);
                  var o2 = this.body.functions.createEdge({ id: "connectionEdge" + p.randomUUID(), from: i2.id, to: n2.id, physics: false, smooth: { enabled: true, type: "continuous", roundness: 0.5 } });
                  this.body.edges[o2.id] = o2, this.body.edgeIndices.push(o2.id), this.temporaryIds.nodes.push(n2.id), this.temporaryIds.edges.push(o2.id);
                }
              this.touchTime = new Date().valueOf();
            }
          } }, { key: "_dragControlNode", value: function(e3) {
            var t2 = this.body.functions.getPointer(e3.center);
            if (void 0 !== this.temporaryIds.nodes[0]) {
              var i2 = this.body.nodes[this.temporaryIds.nodes[0]];
              i2.x = this.canvas._XconvertDOMtoCanvas(t2.x), i2.y = this.canvas._YconvertDOMtoCanvas(t2.y), this.body.emitter.emit("_redraw");
            } else {
              var n2 = t2.x - this.lastTouch.x, o2 = t2.y - this.lastTouch.y;
              this.body.view.translation = { x: this.lastTouch.translation.x + n2, y: this.lastTouch.translation.y + o2 };
            }
          } }, { key: "_finishConnect", value: function(e3) {
            var t2 = this.body.functions.getPointer(e3.center), i2 = this.selectionHandler._pointerToPositionObject(t2), n2 = void 0;
            void 0 !== this.temporaryIds.edges[0] && (n2 = this.body.edges[this.temporaryIds.edges[0]].fromId);
            for (var o2 = this.selectionHandler._getAllNodesOverlappingWith(i2), s2 = void 0, r2 = o2.length - 1; r2 >= 0; r2--)
              if (-1 === this.temporaryIds.nodes.indexOf(o2[r2])) {
                s2 = this.body.nodes[o2[r2]];
                break;
              }
            this._cleanupTemporaryNodesAndEdges(), void 0 !== s2 && (true === s2.isCluster ? alert(this.options.locales[this.options.locale].createEdgeError || this.options.locales.en.createEdgeError) : void 0 !== this.body.nodes[n2] && void 0 !== this.body.nodes[s2.id] && this._performAddEdge(n2, s2.id)), this.body.emitter.emit("_redraw");
          } }, { key: "_dragStartEdge", value: function(e3) {
            var t2 = this.lastTouch;
            this.selectionHandler._generateClickEvent("dragStart", e3, t2, void 0, true);
          } }, { key: "_performAddNode", value: function(e3) {
            var t2 = this, i2 = { id: p.randomUUID(), x: e3.pointer.canvas.x, y: e3.pointer.canvas.y, label: "new" };
            if ("function" == typeof this.options.addNode) {
              if (2 !== this.options.addNode.length)
                throw this.showManipulatorToolbar(), new Error("The function for add does not support two arguments (data,callback)");
              this.options.addNode(i2, function(e4) {
                null !== e4 && void 0 !== e4 && "addNode" === t2.inMode && (t2.body.data.nodes.getDataSet().add(e4), t2.showManipulatorToolbar());
              });
            } else
              this.body.data.nodes.getDataSet().add(i2), this.showManipulatorToolbar();
          } }, { key: "_performAddEdge", value: function(e3, t2) {
            var i2 = this, n2 = { from: e3, to: t2 };
            if ("function" == typeof this.options.addEdge) {
              if (2 !== this.options.addEdge.length)
                throw new Error("The function for connect does not support two arguments (data,callback)");
              this.options.addEdge(n2, function(e4) {
                null !== e4 && void 0 !== e4 && "addEdge" === i2.inMode && (i2.body.data.edges.getDataSet().add(e4), i2.selectionHandler.unselectAll(), i2.showManipulatorToolbar());
              });
            } else
              this.body.data.edges.getDataSet().add(n2), this.selectionHandler.unselectAll(), this.showManipulatorToolbar();
          } }, { key: "_performEditEdge", value: function(e3, t2) {
            var i2 = this, n2 = { id: this.edgeBeingEditedId, from: e3, to: t2, label: this.body.data.edges._data[this.edgeBeingEditedId].label }, o2 = this.options.editEdge;
            if ("object" === (void 0 === o2 ? "undefined" : (0, h.default)(o2)) && (o2 = o2.editWithoutDrag), "function" == typeof o2) {
              if (2 !== o2.length)
                throw new Error("The function for edit does not support two arguments (data, callback)");
              o2(n2, function(e4) {
                null === e4 || void 0 === e4 || "editEdge" !== i2.inMode ? (i2.body.edges[n2.id].updateEdgeType(), i2.body.emitter.emit("_redraw"), i2.showManipulatorToolbar()) : (i2.body.data.edges.getDataSet().update(e4), i2.selectionHandler.unselectAll(), i2.showManipulatorToolbar());
              });
            } else
              this.body.data.edges.getDataSet().update(n2), this.selectionHandler.unselectAll(), this.showManipulatorToolbar();
          } }]), e2;
        }();
        t.default = y;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(21), s = n(o), r = i(7), a = n(r), d = i(0), h = n(d), l = i(1), u = n(l), c = i(5), f = i(189).default, p = function() {
          function e2(t2, i2, n2) {
            var o2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
            (0, h.default)(this, e2), this.parent = t2, this.changedOptions = [], this.container = i2, this.allowCreation = false, this.options = {}, this.initialized = false, this.popupCounter = 0, this.defaultOptions = { enabled: false, filter: true, container: void 0, showButton: true }, c.extend(this.options, this.defaultOptions), this.configureOptions = n2, this.moduleOptions = {}, this.domElements = [], this.popupDiv = {}, this.popupLimit = 5, this.popupHistory = {}, this.colorPicker = new f(o2), this.wrapper = void 0;
          }
          return (0, u.default)(e2, [{ key: "setOptions", value: function(e3) {
            if (void 0 !== e3) {
              this.popupHistory = {}, this._removePopup();
              var t2 = true;
              "string" == typeof e3 ? this.options.filter = e3 : e3 instanceof Array ? this.options.filter = e3.join() : "object" === (void 0 === e3 ? "undefined" : (0, a.default)(e3)) ? (void 0 !== e3.container && (this.options.container = e3.container), void 0 !== e3.filter && (this.options.filter = e3.filter), void 0 !== e3.showButton && (this.options.showButton = e3.showButton), void 0 !== e3.enabled && (t2 = e3.enabled)) : "boolean" == typeof e3 ? (this.options.filter = true, t2 = e3) : "function" == typeof e3 && (this.options.filter = e3, t2 = true), false === this.options.filter && (t2 = false), this.options.enabled = t2;
            }
            this._clean();
          } }, { key: "setModuleOptions", value: function(e3) {
            this.moduleOptions = e3, true === this.options.enabled && (this._clean(), void 0 !== this.options.container && (this.container = this.options.container), this._create());
          } }, { key: "_create", value: function() {
            var e3 = this;
            this._clean(), this.changedOptions = [];
            var t2 = this.options.filter, i2 = 0, n2 = false;
            for (var o2 in this.configureOptions)
              this.configureOptions.hasOwnProperty(o2) && (this.allowCreation = false, n2 = false, "function" == typeof t2 ? (n2 = t2(o2, []), n2 = n2 || this._handleObject(this.configureOptions[o2], [o2], true)) : true !== t2 && -1 === t2.indexOf(o2) || (n2 = true), false !== n2 && (this.allowCreation = true, i2 > 0 && this._makeItem([]), this._makeHeader(o2), this._handleObject(this.configureOptions[o2], [o2])), i2++);
            if (true === this.options.showButton) {
              var s2 = document.createElement("div");
              s2.className = "vis-configuration vis-config-button", s2.innerHTML = "generate options", s2.onclick = function() {
                e3._printOptions();
              }, s2.onmouseover = function() {
                s2.className = "vis-configuration vis-config-button hover";
              }, s2.onmouseout = function() {
                s2.className = "vis-configuration vis-config-button";
              }, this.optionsContainer = document.createElement("div"), this.optionsContainer.className = "vis-configuration vis-config-option-container", this.domElements.push(this.optionsContainer), this.domElements.push(s2);
            }
            this._push();
          } }, { key: "_push", value: function() {
            this.wrapper = document.createElement("div"), this.wrapper.className = "vis-configuration-wrapper", this.container.appendChild(this.wrapper);
            for (var e3 = 0; e3 < this.domElements.length; e3++)
              this.wrapper.appendChild(this.domElements[e3]);
            this._showPopupIfNeeded();
          } }, { key: "_clean", value: function() {
            for (var e3 = 0; e3 < this.domElements.length; e3++)
              this.wrapper.removeChild(this.domElements[e3]);
            void 0 !== this.wrapper && (this.container.removeChild(this.wrapper), this.wrapper = void 0), this.domElements = [], this._removePopup();
          } }, { key: "_getValue", value: function(e3) {
            for (var t2 = this.moduleOptions, i2 = 0; i2 < e3.length; i2++) {
              if (void 0 === t2[e3[i2]]) {
                t2 = void 0;
                break;
              }
              t2 = t2[e3[i2]];
            }
            return t2;
          } }, { key: "_makeItem", value: function(e3) {
            if (true === this.allowCreation) {
              var t2 = document.createElement("div");
              t2.className = "vis-configuration vis-config-item vis-config-s" + e3.length;
              for (var i2 = arguments.length, n2 = Array(i2 > 1 ? i2 - 1 : 0), o2 = 1; o2 < i2; o2++)
                n2[o2 - 1] = arguments[o2];
              return n2.forEach(function(e4) {
                t2.appendChild(e4);
              }), this.domElements.push(t2), this.domElements.length;
            }
            return 0;
          } }, { key: "_makeHeader", value: function(e3) {
            var t2 = document.createElement("div");
            t2.className = "vis-configuration vis-config-header", t2.innerHTML = e3, this._makeItem([], t2);
          } }, { key: "_makeLabel", value: function(e3, t2) {
            var i2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], n2 = document.createElement("div");
            return n2.className = "vis-configuration vis-config-label vis-config-s" + t2.length, n2.innerHTML = true === i2 ? "<i><b>" + e3 + ":</b></i>" : e3 + ":", n2;
          } }, { key: "_makeDropdown", value: function(e3, t2, i2) {
            var n2 = document.createElement("select");
            n2.className = "vis-configuration vis-config-select";
            var o2 = 0;
            void 0 !== t2 && -1 !== e3.indexOf(t2) && (o2 = e3.indexOf(t2));
            for (var s2 = 0; s2 < e3.length; s2++) {
              var r2 = document.createElement("option");
              r2.value = e3[s2], s2 === o2 && (r2.selected = "selected"), r2.innerHTML = e3[s2], n2.appendChild(r2);
            }
            var a2 = this;
            n2.onchange = function() {
              a2._update(this.value, i2);
            };
            var d2 = this._makeLabel(i2[i2.length - 1], i2);
            this._makeItem(i2, d2, n2);
          } }, { key: "_makeRange", value: function(e3, t2, i2) {
            var n2 = e3[0], o2 = e3[1], s2 = e3[2], r2 = e3[3], a2 = document.createElement("input");
            a2.className = "vis-configuration vis-config-range";
            try {
              a2.type = "range", a2.min = o2, a2.max = s2;
            } catch (e4) {
            }
            a2.step = r2;
            var d2 = "", h2 = 0;
            if (void 0 !== t2) {
              t2 < 0 && 1.2 * t2 < o2 ? (a2.min = Math.ceil(1.2 * t2), h2 = a2.min, d2 = "range increased") : t2 / 1.2 < o2 && (a2.min = Math.ceil(t2 / 1.2), h2 = a2.min, d2 = "range increased"), 1.2 * t2 > s2 && 1 !== s2 && (a2.max = Math.ceil(1.2 * t2), h2 = a2.max, d2 = "range increased"), a2.value = t2;
            } else
              a2.value = n2;
            var l2 = document.createElement("input");
            l2.className = "vis-configuration vis-config-rangeinput", l2.value = a2.value;
            var u2 = this;
            a2.onchange = function() {
              l2.value = this.value, u2._update(Number(this.value), i2);
            }, a2.oninput = function() {
              l2.value = this.value;
            };
            var c2 = this._makeLabel(i2[i2.length - 1], i2), f2 = this._makeItem(i2, c2, a2, l2);
            "" !== d2 && this.popupHistory[f2] !== h2 && (this.popupHistory[f2] = h2, this._setupPopup(d2, f2));
          } }, { key: "_setupPopup", value: function(e3, t2) {
            var i2 = this;
            if (true === this.initialized && true === this.allowCreation && this.popupCounter < this.popupLimit) {
              var n2 = document.createElement("div");
              n2.id = "vis-configuration-popup", n2.className = "vis-configuration-popup", n2.innerHTML = e3, n2.onclick = function() {
                i2._removePopup();
              }, this.popupCounter += 1, this.popupDiv = { html: n2, index: t2 };
            }
          } }, { key: "_removePopup", value: function() {
            void 0 !== this.popupDiv.html && (this.popupDiv.html.parentNode.removeChild(this.popupDiv.html), clearTimeout(this.popupDiv.hideTimeout), clearTimeout(this.popupDiv.deleteTimeout), this.popupDiv = {});
          } }, { key: "_showPopupIfNeeded", value: function() {
            var e3 = this;
            if (void 0 !== this.popupDiv.html) {
              var t2 = this.domElements[this.popupDiv.index], i2 = t2.getBoundingClientRect();
              this.popupDiv.html.style.left = i2.left + "px", this.popupDiv.html.style.top = i2.top - 30 + "px", document.body.appendChild(this.popupDiv.html), this.popupDiv.hideTimeout = setTimeout(function() {
                e3.popupDiv.html.style.opacity = 0;
              }, 1500), this.popupDiv.deleteTimeout = setTimeout(function() {
                e3._removePopup();
              }, 1800);
            }
          } }, { key: "_makeCheckbox", value: function(e3, t2, i2) {
            var n2 = document.createElement("input");
            n2.type = "checkbox", n2.className = "vis-configuration vis-config-checkbox", n2.checked = e3, void 0 !== t2 && (n2.checked = t2, t2 !== e3 && ("object" === (void 0 === e3 ? "undefined" : (0, a.default)(e3)) ? t2 !== e3.enabled && this.changedOptions.push({ path: i2, value: t2 }) : this.changedOptions.push({ path: i2, value: t2 })));
            var o2 = this;
            n2.onchange = function() {
              o2._update(this.checked, i2);
            };
            var s2 = this._makeLabel(i2[i2.length - 1], i2);
            this._makeItem(i2, s2, n2);
          } }, { key: "_makeTextInput", value: function(e3, t2, i2) {
            var n2 = document.createElement("input");
            n2.type = "text", n2.className = "vis-configuration vis-config-text", n2.value = t2, t2 !== e3 && this.changedOptions.push({ path: i2, value: t2 });
            var o2 = this;
            n2.onchange = function() {
              o2._update(this.value, i2);
            };
            var s2 = this._makeLabel(i2[i2.length - 1], i2);
            this._makeItem(i2, s2, n2);
          } }, { key: "_makeColorField", value: function(e3, t2, i2) {
            var n2 = this, o2 = e3[1], s2 = document.createElement("div");
            t2 = void 0 === t2 ? o2 : t2, "none" !== t2 ? (s2.className = "vis-configuration vis-config-colorBlock", s2.style.backgroundColor = t2) : s2.className = "vis-configuration vis-config-colorBlock none", t2 = void 0 === t2 ? o2 : t2, s2.onclick = function() {
              n2._showColorPicker(t2, s2, i2);
            };
            var r2 = this._makeLabel(i2[i2.length - 1], i2);
            this._makeItem(i2, r2, s2);
          } }, { key: "_showColorPicker", value: function(e3, t2, i2) {
            var n2 = this;
            t2.onclick = function() {
            }, this.colorPicker.insertTo(t2), this.colorPicker.show(), this.colorPicker.setColor(e3), this.colorPicker.setUpdateCallback(function(e4) {
              var o2 = "rgba(" + e4.r + "," + e4.g + "," + e4.b + "," + e4.a + ")";
              t2.style.backgroundColor = o2, n2._update(o2, i2);
            }), this.colorPicker.setCloseCallback(function() {
              t2.onclick = function() {
                n2._showColorPicker(e3, t2, i2);
              };
            });
          } }, { key: "_handleObject", value: function(e3) {
            var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [], i2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], n2 = false, o2 = this.options.filter, s2 = false;
            for (var r2 in e3)
              if (e3.hasOwnProperty(r2)) {
                n2 = true;
                var a2 = e3[r2], d2 = c.copyAndExtendArray(t2, r2);
                if ("function" == typeof o2 && false === (n2 = o2(r2, t2)) && !(a2 instanceof Array) && "string" != typeof a2 && "boolean" != typeof a2 && a2 instanceof Object && (this.allowCreation = false, n2 = this._handleObject(a2, d2, true), this.allowCreation = false === i2), false !== n2) {
                  s2 = true;
                  var h2 = this._getValue(d2);
                  if (a2 instanceof Array)
                    this._handleArray(a2, h2, d2);
                  else if ("string" == typeof a2)
                    this._makeTextInput(a2, h2, d2);
                  else if ("boolean" == typeof a2)
                    this._makeCheckbox(a2, h2, d2);
                  else if (a2 instanceof Object) {
                    var l2 = true;
                    if (-1 !== t2.indexOf("physics") && this.moduleOptions.physics.solver !== r2 && (l2 = false), true === l2)
                      if (void 0 !== a2.enabled) {
                        var u2 = c.copyAndExtendArray(d2, "enabled"), f2 = this._getValue(u2);
                        if (true === f2) {
                          var p2 = this._makeLabel(r2, d2, true);
                          this._makeItem(d2, p2), s2 = this._handleObject(a2, d2) || s2;
                        } else
                          this._makeCheckbox(a2, f2, d2);
                      } else {
                        var v = this._makeLabel(r2, d2, true);
                        this._makeItem(d2, v), s2 = this._handleObject(a2, d2) || s2;
                      }
                  } else
                    console.error("dont know how to handle", a2, r2, d2);
                }
              }
            return s2;
          } }, { key: "_handleArray", value: function(e3, t2, i2) {
            "string" == typeof e3[0] && "color" === e3[0] ? (this._makeColorField(e3, t2, i2), e3[1] !== t2 && this.changedOptions.push({ path: i2, value: t2 })) : "string" == typeof e3[0] ? (this._makeDropdown(e3, t2, i2), e3[0] !== t2 && this.changedOptions.push({ path: i2, value: t2 })) : "number" == typeof e3[0] && (this._makeRange(e3, t2, i2), e3[0] !== t2 && this.changedOptions.push({ path: i2, value: Number(t2) }));
          } }, { key: "_update", value: function(e3, t2) {
            var i2 = this._constructOptions(e3, t2);
            this.parent.body && this.parent.body.emitter && this.parent.body.emitter.emit && this.parent.body.emitter.emit("configChange", i2), this.initialized = true, this.parent.setOptions(i2);
          } }, { key: "_constructOptions", value: function(e3, t2) {
            var i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, n2 = i2;
            e3 = "true" === e3 || e3, e3 = "false" !== e3 && e3;
            for (var o2 = 0; o2 < t2.length; o2++)
              "global" !== t2[o2] && (void 0 === n2[t2[o2]] && (n2[t2[o2]] = {}), o2 !== t2.length - 1 ? n2 = n2[t2[o2]] : n2[t2[o2]] = e3);
            return i2;
          } }, { key: "_printOptions", value: function() {
            var e3 = this.getOptions();
            this.optionsContainer.innerHTML = "<pre>var options = " + (0, s.default)(e3, null, 2) + "</pre>";
          } }, { key: "getOptions", value: function() {
            for (var e3 = {}, t2 = 0; t2 < this.changedOptions.length; t2++)
              this._constructOptions(this.changedOptions[t2].value, this.changedOptions[t2].path, e3);
            return e3;
          } }]), e2;
        }();
        t.default = p;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(21), s = n(o), r = i(0), a = n(r), d = i(1), h = n(d), l = i(22), u = i(35), c = i(5), f = function() {
          function e2() {
            var t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
            (0, a.default)(this, e2), this.pixelRatio = t2, this.generated = false, this.centerCoordinates = { x: 144.5, y: 144.5 }, this.r = 289 * 0.49, this.color = { r: 255, g: 255, b: 255, a: 1 }, this.hueCircle = void 0, this.initialColor = { r: 255, g: 255, b: 255, a: 1 }, this.previousColor = void 0, this.applied = false, this.updateCallback = function() {
            }, this.closeCallback = function() {
            }, this._create();
          }
          return (0, h.default)(e2, [{ key: "insertTo", value: function(e3) {
            void 0 !== this.hammer && (this.hammer.destroy(), this.hammer = void 0), this.container = e3, this.container.appendChild(this.frame), this._bindHammer(), this._setSize();
          } }, { key: "setUpdateCallback", value: function(e3) {
            if ("function" != typeof e3)
              throw new Error("Function attempted to set as colorPicker update callback is not a function.");
            this.updateCallback = e3;
          } }, { key: "setCloseCallback", value: function(e3) {
            if ("function" != typeof e3)
              throw new Error("Function attempted to set as colorPicker closing callback is not a function.");
            this.closeCallback = e3;
          } }, { key: "_isColorString", value: function(e3) {
            var t2 = { black: "#000000", navy: "#000080", darkblue: "#00008B", mediumblue: "#0000CD", blue: "#0000FF", darkgreen: "#006400", green: "#008000", teal: "#008080", darkcyan: "#008B8B", deepskyblue: "#00BFFF", darkturquoise: "#00CED1", mediumspringgreen: "#00FA9A", lime: "#00FF00", springgreen: "#00FF7F", aqua: "#00FFFF", cyan: "#00FFFF", midnightblue: "#191970", dodgerblue: "#1E90FF", lightseagreen: "#20B2AA", forestgreen: "#228B22", seagreen: "#2E8B57", darkslategray: "#2F4F4F", limegreen: "#32CD32", mediumseagreen: "#3CB371", turquoise: "#40E0D0", royalblue: "#4169E1", steelblue: "#4682B4", darkslateblue: "#483D8B", mediumturquoise: "#48D1CC", indigo: "#4B0082", darkolivegreen: "#556B2F", cadetblue: "#5F9EA0", cornflowerblue: "#6495ED", mediumaquamarine: "#66CDAA", dimgray: "#696969", slateblue: "#6A5ACD", olivedrab: "#6B8E23", slategray: "#708090", lightslategray: "#778899", mediumslateblue: "#7B68EE", lawngreen: "#7CFC00", chartreuse: "#7FFF00", aquamarine: "#7FFFD4", maroon: "#800000", purple: "#800080", olive: "#808000", gray: "#808080", skyblue: "#87CEEB", lightskyblue: "#87CEFA", blueviolet: "#8A2BE2", darkred: "#8B0000", darkmagenta: "#8B008B", saddlebrown: "#8B4513", darkseagreen: "#8FBC8F", lightgreen: "#90EE90", mediumpurple: "#9370D8", darkviolet: "#9400D3", palegreen: "#98FB98", darkorchid: "#9932CC", yellowgreen: "#9ACD32", sienna: "#A0522D", brown: "#A52A2A", darkgray: "#A9A9A9", lightblue: "#ADD8E6", greenyellow: "#ADFF2F", paleturquoise: "#AFEEEE", lightsteelblue: "#B0C4DE", powderblue: "#B0E0E6", firebrick: "#B22222", darkgoldenrod: "#B8860B", mediumorchid: "#BA55D3", rosybrown: "#BC8F8F", darkkhaki: "#BDB76B", silver: "#C0C0C0", mediumvioletred: "#C71585", indianred: "#CD5C5C", peru: "#CD853F", chocolate: "#D2691E", tan: "#D2B48C", lightgrey: "#D3D3D3", palevioletred: "#D87093", thistle: "#D8BFD8", orchid: "#DA70D6", goldenrod: "#DAA520", crimson: "#DC143C", gainsboro: "#DCDCDC", plum: "#DDA0DD", burlywood: "#DEB887", lightcyan: "#E0FFFF", lavender: "#E6E6FA", darksalmon: "#E9967A", violet: "#EE82EE", palegoldenrod: "#EEE8AA", lightcoral: "#F08080", khaki: "#F0E68C", aliceblue: "#F0F8FF", honeydew: "#F0FFF0", azure: "#F0FFFF", sandybrown: "#F4A460", wheat: "#F5DEB3", beige: "#F5F5DC", whitesmoke: "#F5F5F5", mintcream: "#F5FFFA", ghostwhite: "#F8F8FF", salmon: "#FA8072", antiquewhite: "#FAEBD7", linen: "#FAF0E6", lightgoldenrodyellow: "#FAFAD2", oldlace: "#FDF5E6", red: "#FF0000", fuchsia: "#FF00FF", magenta: "#FF00FF", deeppink: "#FF1493", orangered: "#FF4500", tomato: "#FF6347", hotpink: "#FF69B4", coral: "#FF7F50", darkorange: "#FF8C00", lightsalmon: "#FFA07A", orange: "#FFA500", lightpink: "#FFB6C1", pink: "#FFC0CB", gold: "#FFD700", peachpuff: "#FFDAB9", navajowhite: "#FFDEAD", moccasin: "#FFE4B5", bisque: "#FFE4C4", mistyrose: "#FFE4E1", blanchedalmond: "#FFEBCD", papayawhip: "#FFEFD5", lavenderblush: "#FFF0F5", seashell: "#FFF5EE", cornsilk: "#FFF8DC", lemonchiffon: "#FFFACD", floralwhite: "#FFFAF0", snow: "#FFFAFA", yellow: "#FFFF00", lightyellow: "#FFFFE0", ivory: "#FFFFF0", white: "#FFFFFF" };
            if ("string" == typeof e3)
              return t2[e3];
          } }, { key: "setColor", value: function(e3) {
            var t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
            if ("none" !== e3) {
              var i2 = void 0, n2 = this._isColorString(e3);
              if (void 0 !== n2 && (e3 = n2), true === c.isString(e3)) {
                if (true === c.isValidRGB(e3)) {
                  var o2 = e3.substr(4).substr(0, e3.length - 5).split(",");
                  i2 = { r: o2[0], g: o2[1], b: o2[2], a: 1 };
                } else if (true === c.isValidRGBA(e3)) {
                  var r2 = e3.substr(5).substr(0, e3.length - 6).split(",");
                  i2 = { r: r2[0], g: r2[1], b: r2[2], a: r2[3] };
                } else if (true === c.isValidHex(e3)) {
                  var a2 = c.hexToRGB(e3);
                  i2 = { r: a2.r, g: a2.g, b: a2.b, a: 1 };
                }
              } else if (e3 instanceof Object && void 0 !== e3.r && void 0 !== e3.g && void 0 !== e3.b) {
                var d2 = void 0 !== e3.a ? e3.a : "1.0";
                i2 = { r: e3.r, g: e3.g, b: e3.b, a: d2 };
              }
              if (void 0 === i2)
                throw new Error("Unknown color passed to the colorPicker. Supported are strings: rgb, hex, rgba. Object: rgb ({r:r,g:g,b:b,[a:a]}). Supplied: " + (0, s.default)(e3));
              this._setColor(i2, t2);
            }
          } }, { key: "show", value: function() {
            void 0 !== this.closeCallback && (this.closeCallback(), this.closeCallback = void 0), this.applied = false, this.frame.style.display = "block", this._generateHueCircle();
          } }, { key: "_hide", value: function() {
            var e3 = this;
            true === (!(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]) && (this.previousColor = c.extend({}, this.color)), true === this.applied && this.updateCallback(this.initialColor), this.frame.style.display = "none", setTimeout(function() {
              void 0 !== e3.closeCallback && (e3.closeCallback(), e3.closeCallback = void 0);
            }, 0);
          } }, { key: "_save", value: function() {
            this.updateCallback(this.color), this.applied = false, this._hide();
          } }, { key: "_apply", value: function() {
            this.applied = true, this.updateCallback(this.color), this._updatePicker(this.color);
          } }, { key: "_loadLast", value: function() {
            void 0 !== this.previousColor ? this.setColor(this.previousColor, false) : alert("There is no last color to load...");
          } }, { key: "_setColor", value: function(e3) {
            true === (!(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]) && (this.initialColor = c.extend({}, e3)), this.color = e3;
            var t2 = c.RGBToHSV(e3.r, e3.g, e3.b), i2 = 2 * Math.PI, n2 = this.r * t2.s, o2 = this.centerCoordinates.x + n2 * Math.sin(i2 * t2.h), s2 = this.centerCoordinates.y + n2 * Math.cos(i2 * t2.h);
            this.colorPickerSelector.style.left = o2 - 0.5 * this.colorPickerSelector.clientWidth + "px", this.colorPickerSelector.style.top = s2 - 0.5 * this.colorPickerSelector.clientHeight + "px", this._updatePicker(e3);
          } }, { key: "_setOpacity", value: function(e3) {
            this.color.a = e3 / 100, this._updatePicker(this.color);
          } }, { key: "_setBrightness", value: function(e3) {
            var t2 = c.RGBToHSV(this.color.r, this.color.g, this.color.b);
            t2.v = e3 / 100;
            var i2 = c.HSVToRGB(t2.h, t2.s, t2.v);
            i2.a = this.color.a, this.color = i2, this._updatePicker();
          } }, { key: "_updatePicker", value: function() {
            var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.color, t2 = c.RGBToHSV(e3.r, e3.g, e3.b), i2 = this.colorPickerCanvas.getContext("2d");
            void 0 === this.pixelRation && (this.pixelRatio = (window.devicePixelRatio || 1) / (i2.webkitBackingStorePixelRatio || i2.mozBackingStorePixelRatio || i2.msBackingStorePixelRatio || i2.oBackingStorePixelRatio || i2.backingStorePixelRatio || 1)), i2.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
            var n2 = this.colorPickerCanvas.clientWidth, o2 = this.colorPickerCanvas.clientHeight;
            i2.clearRect(0, 0, n2, o2), i2.putImageData(this.hueCircle, 0, 0), i2.fillStyle = "rgba(0,0,0," + (1 - t2.v) + ")", i2.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r), i2.fill(), this.brightnessRange.value = 100 * t2.v, this.opacityRange.value = 100 * e3.a, this.initialColorDiv.style.backgroundColor = "rgba(" + this.initialColor.r + "," + this.initialColor.g + "," + this.initialColor.b + "," + this.initialColor.a + ")", this.newColorDiv.style.backgroundColor = "rgba(" + this.color.r + "," + this.color.g + "," + this.color.b + "," + this.color.a + ")";
          } }, { key: "_setSize", value: function() {
            this.colorPickerCanvas.style.width = "100%", this.colorPickerCanvas.style.height = "100%", this.colorPickerCanvas.width = 289 * this.pixelRatio, this.colorPickerCanvas.height = 289 * this.pixelRatio;
          } }, { key: "_create", value: function() {
            if (this.frame = document.createElement("div"), this.frame.className = "vis-color-picker", this.colorPickerDiv = document.createElement("div"), this.colorPickerSelector = document.createElement("div"), this.colorPickerSelector.className = "vis-selector", this.colorPickerDiv.appendChild(this.colorPickerSelector), this.colorPickerCanvas = document.createElement("canvas"), this.colorPickerDiv.appendChild(this.colorPickerCanvas), this.colorPickerCanvas.getContext) {
              var e3 = this.colorPickerCanvas.getContext("2d");
              this.pixelRatio = (window.devicePixelRatio || 1) / (e3.webkitBackingStorePixelRatio || e3.mozBackingStorePixelRatio || e3.msBackingStorePixelRatio || e3.oBackingStorePixelRatio || e3.backingStorePixelRatio || 1), this.colorPickerCanvas.getContext("2d").setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
            } else {
              var t2 = document.createElement("DIV");
              t2.style.color = "red", t2.style.fontWeight = "bold", t2.style.padding = "10px", t2.innerHTML = "Error: your browser does not support HTML canvas", this.colorPickerCanvas.appendChild(t2);
            }
            this.colorPickerDiv.className = "vis-color", this.opacityDiv = document.createElement("div"), this.opacityDiv.className = "vis-opacity", this.brightnessDiv = document.createElement("div"), this.brightnessDiv.className = "vis-brightness", this.arrowDiv = document.createElement("div"), this.arrowDiv.className = "vis-arrow", this.opacityRange = document.createElement("input");
            try {
              this.opacityRange.type = "range", this.opacityRange.min = "0", this.opacityRange.max = "100";
            } catch (e4) {
            }
            this.opacityRange.value = "100", this.opacityRange.className = "vis-range", this.brightnessRange = document.createElement("input");
            try {
              this.brightnessRange.type = "range", this.brightnessRange.min = "0", this.brightnessRange.max = "100";
            } catch (e4) {
            }
            this.brightnessRange.value = "100", this.brightnessRange.className = "vis-range", this.opacityDiv.appendChild(this.opacityRange), this.brightnessDiv.appendChild(this.brightnessRange);
            var i2 = this;
            this.opacityRange.onchange = function() {
              i2._setOpacity(this.value);
            }, this.opacityRange.oninput = function() {
              i2._setOpacity(this.value);
            }, this.brightnessRange.onchange = function() {
              i2._setBrightness(this.value);
            }, this.brightnessRange.oninput = function() {
              i2._setBrightness(this.value);
            }, this.brightnessLabel = document.createElement("div"), this.brightnessLabel.className = "vis-label vis-brightness", this.brightnessLabel.innerHTML = "brightness:", this.opacityLabel = document.createElement("div"), this.opacityLabel.className = "vis-label vis-opacity", this.opacityLabel.innerHTML = "opacity:", this.newColorDiv = document.createElement("div"), this.newColorDiv.className = "vis-new-color", this.newColorDiv.innerHTML = "new", this.initialColorDiv = document.createElement("div"), this.initialColorDiv.className = "vis-initial-color", this.initialColorDiv.innerHTML = "initial", this.cancelButton = document.createElement("div"), this.cancelButton.className = "vis-button vis-cancel", this.cancelButton.innerHTML = "cancel", this.cancelButton.onclick = this._hide.bind(this, false), this.applyButton = document.createElement("div"), this.applyButton.className = "vis-button vis-apply", this.applyButton.innerHTML = "apply", this.applyButton.onclick = this._apply.bind(this), this.saveButton = document.createElement("div"), this.saveButton.className = "vis-button vis-save", this.saveButton.innerHTML = "save", this.saveButton.onclick = this._save.bind(this), this.loadButton = document.createElement("div"), this.loadButton.className = "vis-button vis-load", this.loadButton.innerHTML = "load last", this.loadButton.onclick = this._loadLast.bind(this), this.frame.appendChild(this.colorPickerDiv), this.frame.appendChild(this.arrowDiv), this.frame.appendChild(this.brightnessLabel), this.frame.appendChild(this.brightnessDiv), this.frame.appendChild(this.opacityLabel), this.frame.appendChild(this.opacityDiv), this.frame.appendChild(this.newColorDiv), this.frame.appendChild(this.initialColorDiv), this.frame.appendChild(this.cancelButton), this.frame.appendChild(this.applyButton), this.frame.appendChild(this.saveButton), this.frame.appendChild(this.loadButton);
          } }, { key: "_bindHammer", value: function() {
            var e3 = this;
            this.drag = {}, this.pinch = {}, this.hammer = new l(this.colorPickerCanvas), this.hammer.get("pinch").set({ enable: true }), u.onTouch(this.hammer, function(t2) {
              e3._moveSelector(t2);
            }), this.hammer.on("tap", function(t2) {
              e3._moveSelector(t2);
            }), this.hammer.on("panstart", function(t2) {
              e3._moveSelector(t2);
            }), this.hammer.on("panmove", function(t2) {
              e3._moveSelector(t2);
            }), this.hammer.on("panend", function(t2) {
              e3._moveSelector(t2);
            });
          } }, { key: "_generateHueCircle", value: function() {
            if (false === this.generated) {
              var e3 = this.colorPickerCanvas.getContext("2d");
              void 0 === this.pixelRation && (this.pixelRatio = (window.devicePixelRatio || 1) / (e3.webkitBackingStorePixelRatio || e3.mozBackingStorePixelRatio || e3.msBackingStorePixelRatio || e3.oBackingStorePixelRatio || e3.backingStorePixelRatio || 1)), e3.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
              var t2 = this.colorPickerCanvas.clientWidth, i2 = this.colorPickerCanvas.clientHeight;
              e3.clearRect(0, 0, t2, i2);
              var n2 = void 0, o2 = void 0, s2 = void 0, r2 = void 0;
              this.centerCoordinates = { x: 0.5 * t2, y: 0.5 * i2 }, this.r = 0.49 * t2;
              var a2 = 2 * Math.PI / 360, d2 = 1 / this.r, h2 = void 0;
              for (s2 = 0; s2 < 360; s2++)
                for (r2 = 0; r2 < this.r; r2++)
                  n2 = this.centerCoordinates.x + r2 * Math.sin(a2 * s2), o2 = this.centerCoordinates.y + r2 * Math.cos(a2 * s2), h2 = c.HSVToRGB(s2 * (1 / 360), r2 * d2, 1), e3.fillStyle = "rgb(" + h2.r + "," + h2.g + "," + h2.b + ")", e3.fillRect(n2 - 0.5, o2 - 0.5, 2, 2);
              e3.strokeStyle = "rgba(0,0,0,1)", e3.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r), e3.stroke(), this.hueCircle = e3.getImageData(0, 0, t2, i2);
            }
            this.generated = true;
          } }, { key: "_moveSelector", value: function(e3) {
            var t2 = this.colorPickerDiv.getBoundingClientRect(), i2 = e3.center.x - t2.left, n2 = e3.center.y - t2.top, o2 = 0.5 * this.colorPickerDiv.clientHeight, s2 = 0.5 * this.colorPickerDiv.clientWidth, r2 = i2 - s2, a2 = n2 - o2, d2 = Math.atan2(r2, a2), h2 = 0.98 * Math.min(Math.sqrt(r2 * r2 + a2 * a2), s2), l2 = Math.cos(d2) * h2 + o2, u2 = Math.sin(d2) * h2 + s2;
            this.colorPickerSelector.style.top = l2 - 0.5 * this.colorPickerSelector.clientHeight + "px", this.colorPickerSelector.style.left = u2 - 0.5 * this.colorPickerSelector.clientWidth + "px";
            var f2 = d2 / (2 * Math.PI);
            f2 = f2 < 0 ? f2 + 1 : f2;
            var p = h2 / this.r, v = c.RGBToHSV(this.color.r, this.color.g, this.color.b);
            v.h = f2, v.s = p;
            var g = c.HSVToRGB(v.h, v.s, v.v);
            g.a = this.color.a, this.color = g, this.initialColorDiv.style.backgroundColor = "rgba(" + this.initialColor.r + "," + this.initialColor.g + "," + this.initialColor.b + "," + this.initialColor.a + ")", this.newColorDiv.style.backgroundColor = "rgba(" + this.color.r + "," + this.color.g + "," + this.color.b + "," + this.color.a + ")";
          } }]), e2;
        }();
        t.default = f;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(23), s = n(o), r = i(0), a = n(r), d = i(1), h = n(d), l = i(191), u = n(l), c = function() {
          function e2(t2, i2, n2) {
            (0, a.default)(this, e2), this.body = t2, this.springLength = i2, this.springConstant = n2, this.distanceSolver = new u.default();
          }
          return (0, h.default)(e2, [{ key: "setOptions", value: function(e3) {
            e3 && (e3.springLength && (this.springLength = e3.springLength), e3.springConstant && (this.springConstant = e3.springConstant));
          } }, { key: "solve", value: function(e3, t2) {
            var i2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], n2 = this.distanceSolver.getDistances(this.body, e3, t2);
            this._createL_matrix(n2), this._createK_matrix(n2), this._createE_matrix();
            for (var o2 = 0, r2 = Math.max(1e3, Math.min(10 * this.body.nodeIndices.length, 6e3)), a2 = 1e9, d2 = 0, h2 = 0, l2 = 0, u2 = 0, c2 = 0; a2 > 0.01 && o2 < r2; ) {
              o2 += 1;
              var f = this._getHighestEnergyNode(i2), p = (0, s.default)(f, 4);
              for (d2 = p[0], a2 = p[1], h2 = p[2], l2 = p[3], u2 = a2, c2 = 0; u2 > 1 && c2 < 5; ) {
                c2 += 1, this._moveNode(d2, h2, l2);
                var v = this._getEnergy(d2), g = (0, s.default)(v, 3);
                u2 = g[0], h2 = g[1], l2 = g[2];
              }
            }
          } }, { key: "_getHighestEnergyNode", value: function(e3) {
            for (var t2 = this.body.nodeIndices, i2 = this.body.nodes, n2 = 0, o2 = t2[0], r2 = 0, a2 = 0, d2 = 0; d2 < t2.length; d2++) {
              var h2 = t2[d2];
              if (false === i2[h2].predefinedPosition || true === i2[h2].isCluster && true === e3 || true === i2[h2].options.fixed.x || true === i2[h2].options.fixed.y) {
                var l2 = this._getEnergy(h2), u2 = (0, s.default)(l2, 3), c2 = u2[0], f = u2[1], p = u2[2];
                n2 < c2 && (n2 = c2, o2 = h2, r2 = f, a2 = p);
              }
            }
            return [o2, n2, r2, a2];
          } }, { key: "_getEnergy", value: function(e3) {
            var t2 = (0, s.default)(this.E_sums[e3], 2), i2 = t2[0], n2 = t2[1];
            return [Math.sqrt(Math.pow(i2, 2) + Math.pow(n2, 2)), i2, n2];
          } }, { key: "_moveNode", value: function(e3, t2, i2) {
            for (var n2 = this.body.nodeIndices, o2 = this.body.nodes, s2 = 0, r2 = 0, a2 = 0, d2 = o2[e3].x, h2 = o2[e3].y, l2 = this.K_matrix[e3], u2 = this.L_matrix[e3], c2 = 0; c2 < n2.length; c2++) {
              var f = n2[c2];
              if (f !== e3) {
                var p = o2[f].x, v = o2[f].y, g = l2[f], y = u2[f], m = 1 / Math.pow(Math.pow(d2 - p, 2) + Math.pow(h2 - v, 2), 1.5);
                s2 += g * (1 - y * Math.pow(h2 - v, 2) * m), r2 += g * (y * (d2 - p) * (h2 - v) * m), a2 += g * (1 - y * Math.pow(d2 - p, 2) * m);
              }
            }
            var b = s2, _ = r2, w = t2, k = a2, x = i2, O = (w / b + x / _) / (_ / b - k / _), M = -(_ * O + w) / b;
            o2[e3].x += M, o2[e3].y += O, this._updateE_matrix(e3);
          } }, { key: "_createL_matrix", value: function(e3) {
            var t2 = this.body.nodeIndices, i2 = this.springLength;
            this.L_matrix = [];
            for (var n2 = 0; n2 < t2.length; n2++) {
              this.L_matrix[t2[n2]] = {};
              for (var o2 = 0; o2 < t2.length; o2++)
                this.L_matrix[t2[n2]][t2[o2]] = i2 * e3[t2[n2]][t2[o2]];
            }
          } }, { key: "_createK_matrix", value: function(e3) {
            var t2 = this.body.nodeIndices, i2 = this.springConstant;
            this.K_matrix = [];
            for (var n2 = 0; n2 < t2.length; n2++) {
              this.K_matrix[t2[n2]] = {};
              for (var o2 = 0; o2 < t2.length; o2++)
                this.K_matrix[t2[n2]][t2[o2]] = i2 * Math.pow(e3[t2[n2]][t2[o2]], -2);
            }
          } }, { key: "_createE_matrix", value: function() {
            var e3 = this.body.nodeIndices, t2 = this.body.nodes;
            this.E_matrix = {}, this.E_sums = {};
            for (var i2 = 0; i2 < e3.length; i2++)
              this.E_matrix[e3[i2]] = [];
            for (var n2 = 0; n2 < e3.length; n2++) {
              for (var o2 = e3[n2], s2 = t2[o2].x, r2 = t2[o2].y, a2 = 0, d2 = 0, h2 = n2; h2 < e3.length; h2++) {
                var l2 = e3[h2];
                if (l2 !== o2) {
                  var u2 = t2[l2].x, c2 = t2[l2].y, f = 1 / Math.sqrt(Math.pow(s2 - u2, 2) + Math.pow(r2 - c2, 2));
                  this.E_matrix[o2][h2] = [this.K_matrix[o2][l2] * (s2 - u2 - this.L_matrix[o2][l2] * (s2 - u2) * f), this.K_matrix[o2][l2] * (r2 - c2 - this.L_matrix[o2][l2] * (r2 - c2) * f)], this.E_matrix[l2][n2] = this.E_matrix[o2][h2], a2 += this.E_matrix[o2][h2][0], d2 += this.E_matrix[o2][h2][1];
                }
              }
              this.E_sums[o2] = [a2, d2];
            }
          } }, { key: "_updateE_matrix", value: function(e3) {
            for (var t2 = this.body.nodeIndices, i2 = this.body.nodes, n2 = this.E_matrix[e3], o2 = this.K_matrix[e3], s2 = this.L_matrix[e3], r2 = i2[e3].x, a2 = i2[e3].y, d2 = 0, h2 = 0, l2 = 0; l2 < t2.length; l2++) {
              var u2 = t2[l2];
              if (u2 !== e3) {
                var c2 = n2[l2], f = c2[0], p = c2[1], v = i2[u2].x, g = i2[u2].y, y = 1 / Math.sqrt(Math.pow(r2 - v, 2) + Math.pow(a2 - g, 2)), m = o2[u2] * (r2 - v - s2[u2] * (r2 - v) * y), b = o2[u2] * (a2 - g - s2[u2] * (a2 - g) * y);
                n2[l2] = [m, b], d2 += m, h2 += b;
                var _ = this.E_sums[u2];
                _[0] += m - f, _[1] += b - p;
              }
            }
            this.E_sums[e3] = [d2, h2];
          } }]), e2;
        }();
        t.default = c;
      }, function(e, t, i) {
        function n(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var o = i(0), s = n(o), r = i(1), a = n(r), d = function() {
          function e2() {
            (0, s.default)(this, e2);
          }
          return (0, a.default)(e2, [{ key: "getDistances", value: function(e3, t2, i2) {
            for (var n2 = {}, o2 = e3.edges, s2 = 0; s2 < t2.length; s2++) {
              var r2 = t2[s2], a2 = {};
              n2[r2] = a2;
              for (var d2 = 0; d2 < t2.length; d2++)
                a2[t2[d2]] = s2 == d2 ? 0 : 1e9;
            }
            for (var h = 0; h < i2.length; h++) {
              var l = o2[i2[h]];
              true === l.connected && void 0 !== n2[l.fromId] && void 0 !== n2[l.toId] && (n2[l.fromId][l.toId] = 1, n2[l.toId][l.fromId] = 1);
            }
            for (var u = t2.length, c = 0; c < u; c++)
              for (var f = t2[c], p = n2[f], v = 0; v < u - 1; v++)
                for (var g = t2[v], y = n2[g], m = v + 1; m < u; m++) {
                  var b = t2[m], _ = n2[b], w = Math.min(y[b], y[f] + p[b]);
                  y[b] = w, _[g] = w;
                }
            return n2;
          } }]), e2;
        }();
        t.default = d;
      }]);
    });
  }
});

// ../../node_modules/@lifeomic/react-vis-network/lib/Network.js
var require_Network = __commonJS({
  "../../node_modules/@lifeomic/react-vis-network/lib/Network.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _react = _interopRequireWildcard(require_react());
    var _propTypes = _interopRequireDefault(require_prop_types());
    var _visNetwork = require_vis_network_min();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};
              if (desc.get || desc.set) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    function _typeof(obj) {
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys.forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      }
      return target;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var defaultStyles = {
      position: "relative",
      width: "100%",
      height: "100%",
      overflow: "hidden"
    };
    var eventPattern = /^on([A-Z])(.*)$/;
    var VisNetwork = function(_PureComponent) {
      _inherits(VisNetwork2, _PureComponent);
      function VisNetwork2() {
        var _getPrototypeOf2;
        var _this;
        _classCallCheck(this, VisNetwork2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(VisNetwork2)).call.apply(_getPrototypeOf2, [this].concat(args)));
        _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "visContainerRef", (0, _react.createRef)());
        _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "edges", new _visNetwork.DataSet([]));
        _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "nodes", new _visNetwork.DataSet([]));
        _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "state", {
          edges: _this.edges,
          nodes: _this.nodes
        });
        return _this;
      }
      _createClass(VisNetwork2, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          var _this2 = this;
          var options = this.props.options;
          this.network = new _visNetwork.Network(this.visContainerRef.current, {
            edges: this.edges,
            nodes: this.nodes
          }, options);
          Object.keys(this.props).filter(function(prop) {
            return prop.match(eventPattern);
          }).forEach(function(prop) {
            var event = prop.replace(eventPattern, function(match, p1, rest) {
              return p1.toLowerCase() + rest;
            });
            _this2.network.on(event, _this2.props[prop]);
          });
          this.setState({
            network: this.network
          });
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          this.network.destroy();
        }
      }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate(prevProps) {
          var _this$props = this.props, options = _this$props.options, scale = _this$props.scale, position = _this$props.position;
          var network = this.network;
          if (options !== prevProps.options) {
            if (options.edges) {
              ["forceDirection", "roundness", "type"].forEach(function(prop) {
                delete options.edges[prop];
              });
            }
            network.setOptions(options);
          }
          if (scale !== prevProps.scale || position !== prevProps.position) {
            network.moveTo({
              scale: scale || network.getScale(),
              position: position || network.getViewPosition()
            });
          }
        }
      }, {
        key: "render",
        value: function render() {
          var _this3 = this;
          var _this$props2 = this.props, style = _this$props2.style, children = _this$props2.children;
          var appliedStyles = _objectSpread({}, defaultStyles, style);
          var extendedChildren = _react.default.Children.map(children, function(child) {
            return _react.default.cloneElement(child, {
              vis: _this3.state
            });
          });
          return _react.default.createElement(_react.default.Fragment, null, _react.default.createElement("div", {
            ref: this.visContainerRef,
            className: this.props.className,
            style: appliedStyles
          }, extendedChildren));
        }
      }]);
      return VisNetwork2;
    }(_react.PureComponent);
    exports.default = VisNetwork;
    _defineProperty(VisNetwork, "defaultProps", {
      options: {},
      style: {}
    });
    _defineProperty(VisNetwork, "propTypes", {
      children: _propTypes.default.node,
      options: _propTypes.default.object,
      scale: _propTypes.default.number,
      position: _propTypes.default.shape({
        x: _propTypes.default.number,
        y: _propTypes.default.number
      }),
      style: _propTypes.default.object,
      className: _propTypes.default.string
    });
  }
});

// ../../node_modules/react-dom/cjs/react-dom-server-legacy.browser.development.js
var require_react_dom_server_legacy_browser_development = __commonJS({
  "../../node_modules/react-dom/cjs/react-dom-server-legacy.browser.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var React = require_react();
        var ReactVersion = "18.2.0";
        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function warn(format) {
          {
            {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              printWarning("warn", format, args);
            }
          }
        }
        function error(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        function scheduleWork(callback) {
          callback();
        }
        function beginWriting(destination) {
        }
        function writeChunk(destination, chunk) {
          writeChunkAndReturn(destination, chunk);
        }
        function writeChunkAndReturn(destination, chunk) {
          return destination.push(chunk);
        }
        function completeWriting(destination) {
        }
        function close(destination) {
          destination.push(null);
        }
        function stringToChunk(content) {
          return content;
        }
        function stringToPrecomputedChunk(content) {
          return content;
        }
        function closeWithError(destination, error2) {
          destination.destroy(error2);
        }
        function typeName(value) {
          {
            var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
            var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            return type;
          }
        }
        function willCoercionThrow(value) {
          {
            try {
              testStringCoercion(value);
              return false;
            } catch (e) {
              return true;
            }
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkAttributeStringCoercion(value, attributeName) {
          {
            if (willCoercionThrow(value)) {
              error("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", attributeName, typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function checkCSSPropertyStringCoercion(value, propName) {
          {
            if (willCoercionThrow(value)) {
              error("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function checkHtmlStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var RESERVED = 0;
        var STRING = 1;
        var BOOLEANISH_STRING = 2;
        var BOOLEAN = 3;
        var OVERLOADED_BOOLEAN = 4;
        var NUMERIC = 5;
        var POSITIVE_NUMERIC = 6;
        var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
        var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
        var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
        var illegalAttributeNameCache = {};
        var validatedAttributeNameCache = {};
        function isAttributeNameSafe(attributeName) {
          if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {
            return true;
          }
          if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {
            return false;
          }
          if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
            validatedAttributeNameCache[attributeName] = true;
            return true;
          }
          illegalAttributeNameCache[attributeName] = true;
          {
            error("Invalid attribute name: `%s`", attributeName);
          }
          return false;
        }
        function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
          if (propertyInfo !== null && propertyInfo.type === RESERVED) {
            return false;
          }
          switch (typeof value) {
            case "function":
            case "symbol":
              return true;
            case "boolean": {
              if (isCustomComponentTag) {
                return false;
              }
              if (propertyInfo !== null) {
                return !propertyInfo.acceptsBooleans;
              } else {
                var prefix2 = name.toLowerCase().slice(0, 5);
                return prefix2 !== "data-" && prefix2 !== "aria-";
              }
            }
            default:
              return false;
          }
        }
        function getPropertyInfo(name) {
          return properties.hasOwnProperty(name) ? properties[name] : null;
        }
        function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
          this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
          this.attributeName = attributeName;
          this.attributeNamespace = attributeNamespace;
          this.mustUseProperty = mustUseProperty;
          this.propertyName = name;
          this.type = type;
          this.sanitizeURL = sanitizeURL2;
          this.removeEmptyString = removeEmptyString;
        }
        var properties = {};
        var reservedProps = [
          "children",
          "dangerouslySetInnerHTML",
          // TODO: This prevents the assignment of defaultValue to regular
          // elements (not just inputs). Now that ReactDOMInput assigns to the
          // defaultValue property -- do we need this?
          "defaultValue",
          "defaultChecked",
          "innerHTML",
          "suppressContentEditableWarning",
          "suppressHydrationWarning",
          "style"
        ];
        reservedProps.forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            RESERVED,
            false,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
          var name = _ref[0], attributeName = _ref[1];
          properties[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            BOOLEANISH_STRING,
            false,
            // mustUseProperty
            name.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            BOOLEANISH_STRING,
            false,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "allowFullScreen",
          "async",
          // Note: there is a special case that prevents it from being written to the DOM
          // on the client side because the browsers are inconsistent. Instead we call focus().
          "autoFocus",
          "autoPlay",
          "controls",
          "default",
          "defer",
          "disabled",
          "disablePictureInPicture",
          "disableRemotePlayback",
          "formNoValidate",
          "hidden",
          "loop",
          "noModule",
          "noValidate",
          "open",
          "playsInline",
          "readOnly",
          "required",
          "reversed",
          "scoped",
          "seamless",
          // Microdata
          "itemScope"
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            BOOLEAN,
            false,
            // mustUseProperty
            name.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "checked",
          // Note: `option.selected` is not updated if `select.multiple` is
          // disabled with `removeAttribute`. We have special logic for handling this.
          "multiple",
          "muted",
          "selected"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            BOOLEAN,
            true,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "capture",
          "download"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            OVERLOADED_BOOLEAN,
            false,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "cols",
          "rows",
          "size",
          "span"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            POSITIVE_NUMERIC,
            false,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        ["rowSpan", "start"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            NUMERIC,
            false,
            // mustUseProperty
            name.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        var CAMELIZE = /[\-\:]([a-z])/g;
        var capitalize = function(token) {
          return token[1].toUpperCase();
        };
        [
          "accent-height",
          "alignment-baseline",
          "arabic-form",
          "baseline-shift",
          "cap-height",
          "clip-path",
          "clip-rule",
          "color-interpolation",
          "color-interpolation-filters",
          "color-profile",
          "color-rendering",
          "dominant-baseline",
          "enable-background",
          "fill-opacity",
          "fill-rule",
          "flood-color",
          "flood-opacity",
          "font-family",
          "font-size",
          "font-size-adjust",
          "font-stretch",
          "font-style",
          "font-variant",
          "font-weight",
          "glyph-name",
          "glyph-orientation-horizontal",
          "glyph-orientation-vertical",
          "horiz-adv-x",
          "horiz-origin-x",
          "image-rendering",
          "letter-spacing",
          "lighting-color",
          "marker-end",
          "marker-mid",
          "marker-start",
          "overline-position",
          "overline-thickness",
          "paint-order",
          "panose-1",
          "pointer-events",
          "rendering-intent",
          "shape-rendering",
          "stop-color",
          "stop-opacity",
          "strikethrough-position",
          "strikethrough-thickness",
          "stroke-dasharray",
          "stroke-dashoffset",
          "stroke-linecap",
          "stroke-linejoin",
          "stroke-miterlimit",
          "stroke-opacity",
          "stroke-width",
          "text-anchor",
          "text-decoration",
          "text-rendering",
          "underline-position",
          "underline-thickness",
          "unicode-bidi",
          "unicode-range",
          "units-per-em",
          "v-alphabetic",
          "v-hanging",
          "v-ideographic",
          "v-mathematical",
          "vector-effect",
          "vert-adv-y",
          "vert-origin-x",
          "vert-origin-y",
          "word-spacing",
          "writing-mode",
          "xmlns:xlink",
          "x-height"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "xlink:actuate",
          "xlink:arcrole",
          "xlink:role",
          "xlink:show",
          "xlink:title",
          "xlink:type"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            "http://www.w3.org/1999/xlink",
            false,
            // sanitizeURL
            false
          );
        });
        [
          "xml:base",
          "xml:lang",
          "xml:space"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            "http://www.w3.org/XML/1998/namespace",
            false,
            // sanitizeURL
            false
          );
        });
        ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
          properties[attributeName] = new PropertyInfoRecord(
            attributeName,
            STRING,
            false,
            // mustUseProperty
            attributeName.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        var xlinkHref = "xlinkHref";
        properties[xlinkHref] = new PropertyInfoRecord(
          "xlinkHref",
          STRING,
          false,
          // mustUseProperty
          "xlink:href",
          "http://www.w3.org/1999/xlink",
          true,
          // sanitizeURL
          false
        );
        ["src", "href", "action", "formAction"].forEach(function(attributeName) {
          properties[attributeName] = new PropertyInfoRecord(
            attributeName,
            STRING,
            false,
            // mustUseProperty
            attributeName.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            true,
            // sanitizeURL
            true
          );
        });
        var isUnitlessNumber = {
          animationIterationCount: true,
          aspectRatio: true,
          borderImageOutset: true,
          borderImageSlice: true,
          borderImageWidth: true,
          boxFlex: true,
          boxFlexGroup: true,
          boxOrdinalGroup: true,
          columnCount: true,
          columns: true,
          flex: true,
          flexGrow: true,
          flexPositive: true,
          flexShrink: true,
          flexNegative: true,
          flexOrder: true,
          gridArea: true,
          gridRow: true,
          gridRowEnd: true,
          gridRowSpan: true,
          gridRowStart: true,
          gridColumn: true,
          gridColumnEnd: true,
          gridColumnSpan: true,
          gridColumnStart: true,
          fontWeight: true,
          lineClamp: true,
          lineHeight: true,
          opacity: true,
          order: true,
          orphans: true,
          tabSize: true,
          widows: true,
          zIndex: true,
          zoom: true,
          // SVG-related properties
          fillOpacity: true,
          floodOpacity: true,
          stopOpacity: true,
          strokeDasharray: true,
          strokeDashoffset: true,
          strokeMiterlimit: true,
          strokeOpacity: true,
          strokeWidth: true
        };
        function prefixKey(prefix2, key) {
          return prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
        }
        var prefixes = ["Webkit", "ms", "Moz", "O"];
        Object.keys(isUnitlessNumber).forEach(function(prop) {
          prefixes.forEach(function(prefix2) {
            isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
          });
        });
        var hasReadOnlyValue = {
          button: true,
          checkbox: true,
          image: true,
          hidden: true,
          radio: true,
          reset: true,
          submit: true
        };
        function checkControlledValueProps(tagName, props) {
          {
            if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
              error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
            }
            if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
              error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
            }
          }
        }
        function isCustomComponent(tagName, props) {
          if (tagName.indexOf("-") === -1) {
            return typeof props.is === "string";
          }
          switch (tagName) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              return false;
            default:
              return true;
          }
        }
        var ariaProperties = {
          "aria-current": 0,
          // state
          "aria-description": 0,
          "aria-details": 0,
          "aria-disabled": 0,
          // state
          "aria-hidden": 0,
          // state
          "aria-invalid": 0,
          // state
          "aria-keyshortcuts": 0,
          "aria-label": 0,
          "aria-roledescription": 0,
          // Widget Attributes
          "aria-autocomplete": 0,
          "aria-checked": 0,
          "aria-expanded": 0,
          "aria-haspopup": 0,
          "aria-level": 0,
          "aria-modal": 0,
          "aria-multiline": 0,
          "aria-multiselectable": 0,
          "aria-orientation": 0,
          "aria-placeholder": 0,
          "aria-pressed": 0,
          "aria-readonly": 0,
          "aria-required": 0,
          "aria-selected": 0,
          "aria-sort": 0,
          "aria-valuemax": 0,
          "aria-valuemin": 0,
          "aria-valuenow": 0,
          "aria-valuetext": 0,
          // Live Region Attributes
          "aria-atomic": 0,
          "aria-busy": 0,
          "aria-live": 0,
          "aria-relevant": 0,
          // Drag-and-Drop Attributes
          "aria-dropeffect": 0,
          "aria-grabbed": 0,
          // Relationship Attributes
          "aria-activedescendant": 0,
          "aria-colcount": 0,
          "aria-colindex": 0,
          "aria-colspan": 0,
          "aria-controls": 0,
          "aria-describedby": 0,
          "aria-errormessage": 0,
          "aria-flowto": 0,
          "aria-labelledby": 0,
          "aria-owns": 0,
          "aria-posinset": 0,
          "aria-rowcount": 0,
          "aria-rowindex": 0,
          "aria-rowspan": 0,
          "aria-setsize": 0
        };
        var warnedProperties = {};
        var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
        var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
        function validateProperty(tagName, name) {
          {
            if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {
              return true;
            }
            if (rARIACamel.test(name)) {
              var ariaName = "aria-" + name.slice(4).toLowerCase();
              var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
              if (correctName == null) {
                error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name);
                warnedProperties[name] = true;
                return true;
              }
              if (name !== correctName) {
                error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, correctName);
                warnedProperties[name] = true;
                return true;
              }
            }
            if (rARIA.test(name)) {
              var lowerCasedName = name.toLowerCase();
              var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
              if (standardName == null) {
                warnedProperties[name] = true;
                return false;
              }
              if (name !== standardName) {
                error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, standardName);
                warnedProperties[name] = true;
                return true;
              }
            }
          }
          return true;
        }
        function warnInvalidARIAProps(type, props) {
          {
            var invalidProps = [];
            for (var key in props) {
              var isValid = validateProperty(type, key);
              if (!isValid) {
                invalidProps.push(key);
              }
            }
            var unknownPropString = invalidProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (invalidProps.length === 1) {
              error("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
            } else if (invalidProps.length > 1) {
              error("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
            }
          }
        }
        function validateProperties(type, props) {
          if (isCustomComponent(type, props)) {
            return;
          }
          warnInvalidARIAProps(type, props);
        }
        var didWarnValueNull = false;
        function validateProperties$1(type, props) {
          {
            if (type !== "input" && type !== "textarea" && type !== "select") {
              return;
            }
            if (props != null && props.value === null && !didWarnValueNull) {
              didWarnValueNull = true;
              if (type === "select" && props.multiple) {
                error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type);
              } else {
                error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type);
              }
            }
          }
        }
        var possibleStandardNames = {
          // HTML
          accept: "accept",
          acceptcharset: "acceptCharset",
          "accept-charset": "acceptCharset",
          accesskey: "accessKey",
          action: "action",
          allowfullscreen: "allowFullScreen",
          alt: "alt",
          as: "as",
          async: "async",
          autocapitalize: "autoCapitalize",
          autocomplete: "autoComplete",
          autocorrect: "autoCorrect",
          autofocus: "autoFocus",
          autoplay: "autoPlay",
          autosave: "autoSave",
          capture: "capture",
          cellpadding: "cellPadding",
          cellspacing: "cellSpacing",
          challenge: "challenge",
          charset: "charSet",
          checked: "checked",
          children: "children",
          cite: "cite",
          class: "className",
          classid: "classID",
          classname: "className",
          cols: "cols",
          colspan: "colSpan",
          content: "content",
          contenteditable: "contentEditable",
          contextmenu: "contextMenu",
          controls: "controls",
          controlslist: "controlsList",
          coords: "coords",
          crossorigin: "crossOrigin",
          dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
          data: "data",
          datetime: "dateTime",
          default: "default",
          defaultchecked: "defaultChecked",
          defaultvalue: "defaultValue",
          defer: "defer",
          dir: "dir",
          disabled: "disabled",
          disablepictureinpicture: "disablePictureInPicture",
          disableremoteplayback: "disableRemotePlayback",
          download: "download",
          draggable: "draggable",
          enctype: "encType",
          enterkeyhint: "enterKeyHint",
          for: "htmlFor",
          form: "form",
          formmethod: "formMethod",
          formaction: "formAction",
          formenctype: "formEncType",
          formnovalidate: "formNoValidate",
          formtarget: "formTarget",
          frameborder: "frameBorder",
          headers: "headers",
          height: "height",
          hidden: "hidden",
          high: "high",
          href: "href",
          hreflang: "hrefLang",
          htmlfor: "htmlFor",
          httpequiv: "httpEquiv",
          "http-equiv": "httpEquiv",
          icon: "icon",
          id: "id",
          imagesizes: "imageSizes",
          imagesrcset: "imageSrcSet",
          innerhtml: "innerHTML",
          inputmode: "inputMode",
          integrity: "integrity",
          is: "is",
          itemid: "itemID",
          itemprop: "itemProp",
          itemref: "itemRef",
          itemscope: "itemScope",
          itemtype: "itemType",
          keyparams: "keyParams",
          keytype: "keyType",
          kind: "kind",
          label: "label",
          lang: "lang",
          list: "list",
          loop: "loop",
          low: "low",
          manifest: "manifest",
          marginwidth: "marginWidth",
          marginheight: "marginHeight",
          max: "max",
          maxlength: "maxLength",
          media: "media",
          mediagroup: "mediaGroup",
          method: "method",
          min: "min",
          minlength: "minLength",
          multiple: "multiple",
          muted: "muted",
          name: "name",
          nomodule: "noModule",
          nonce: "nonce",
          novalidate: "noValidate",
          open: "open",
          optimum: "optimum",
          pattern: "pattern",
          placeholder: "placeholder",
          playsinline: "playsInline",
          poster: "poster",
          preload: "preload",
          profile: "profile",
          radiogroup: "radioGroup",
          readonly: "readOnly",
          referrerpolicy: "referrerPolicy",
          rel: "rel",
          required: "required",
          reversed: "reversed",
          role: "role",
          rows: "rows",
          rowspan: "rowSpan",
          sandbox: "sandbox",
          scope: "scope",
          scoped: "scoped",
          scrolling: "scrolling",
          seamless: "seamless",
          selected: "selected",
          shape: "shape",
          size: "size",
          sizes: "sizes",
          span: "span",
          spellcheck: "spellCheck",
          src: "src",
          srcdoc: "srcDoc",
          srclang: "srcLang",
          srcset: "srcSet",
          start: "start",
          step: "step",
          style: "style",
          summary: "summary",
          tabindex: "tabIndex",
          target: "target",
          title: "title",
          type: "type",
          usemap: "useMap",
          value: "value",
          width: "width",
          wmode: "wmode",
          wrap: "wrap",
          // SVG
          about: "about",
          accentheight: "accentHeight",
          "accent-height": "accentHeight",
          accumulate: "accumulate",
          additive: "additive",
          alignmentbaseline: "alignmentBaseline",
          "alignment-baseline": "alignmentBaseline",
          allowreorder: "allowReorder",
          alphabetic: "alphabetic",
          amplitude: "amplitude",
          arabicform: "arabicForm",
          "arabic-form": "arabicForm",
          ascent: "ascent",
          attributename: "attributeName",
          attributetype: "attributeType",
          autoreverse: "autoReverse",
          azimuth: "azimuth",
          basefrequency: "baseFrequency",
          baselineshift: "baselineShift",
          "baseline-shift": "baselineShift",
          baseprofile: "baseProfile",
          bbox: "bbox",
          begin: "begin",
          bias: "bias",
          by: "by",
          calcmode: "calcMode",
          capheight: "capHeight",
          "cap-height": "capHeight",
          clip: "clip",
          clippath: "clipPath",
          "clip-path": "clipPath",
          clippathunits: "clipPathUnits",
          cliprule: "clipRule",
          "clip-rule": "clipRule",
          color: "color",
          colorinterpolation: "colorInterpolation",
          "color-interpolation": "colorInterpolation",
          colorinterpolationfilters: "colorInterpolationFilters",
          "color-interpolation-filters": "colorInterpolationFilters",
          colorprofile: "colorProfile",
          "color-profile": "colorProfile",
          colorrendering: "colorRendering",
          "color-rendering": "colorRendering",
          contentscripttype: "contentScriptType",
          contentstyletype: "contentStyleType",
          cursor: "cursor",
          cx: "cx",
          cy: "cy",
          d: "d",
          datatype: "datatype",
          decelerate: "decelerate",
          descent: "descent",
          diffuseconstant: "diffuseConstant",
          direction: "direction",
          display: "display",
          divisor: "divisor",
          dominantbaseline: "dominantBaseline",
          "dominant-baseline": "dominantBaseline",
          dur: "dur",
          dx: "dx",
          dy: "dy",
          edgemode: "edgeMode",
          elevation: "elevation",
          enablebackground: "enableBackground",
          "enable-background": "enableBackground",
          end: "end",
          exponent: "exponent",
          externalresourcesrequired: "externalResourcesRequired",
          fill: "fill",
          fillopacity: "fillOpacity",
          "fill-opacity": "fillOpacity",
          fillrule: "fillRule",
          "fill-rule": "fillRule",
          filter: "filter",
          filterres: "filterRes",
          filterunits: "filterUnits",
          floodopacity: "floodOpacity",
          "flood-opacity": "floodOpacity",
          floodcolor: "floodColor",
          "flood-color": "floodColor",
          focusable: "focusable",
          fontfamily: "fontFamily",
          "font-family": "fontFamily",
          fontsize: "fontSize",
          "font-size": "fontSize",
          fontsizeadjust: "fontSizeAdjust",
          "font-size-adjust": "fontSizeAdjust",
          fontstretch: "fontStretch",
          "font-stretch": "fontStretch",
          fontstyle: "fontStyle",
          "font-style": "fontStyle",
          fontvariant: "fontVariant",
          "font-variant": "fontVariant",
          fontweight: "fontWeight",
          "font-weight": "fontWeight",
          format: "format",
          from: "from",
          fx: "fx",
          fy: "fy",
          g1: "g1",
          g2: "g2",
          glyphname: "glyphName",
          "glyph-name": "glyphName",
          glyphorientationhorizontal: "glyphOrientationHorizontal",
          "glyph-orientation-horizontal": "glyphOrientationHorizontal",
          glyphorientationvertical: "glyphOrientationVertical",
          "glyph-orientation-vertical": "glyphOrientationVertical",
          glyphref: "glyphRef",
          gradienttransform: "gradientTransform",
          gradientunits: "gradientUnits",
          hanging: "hanging",
          horizadvx: "horizAdvX",
          "horiz-adv-x": "horizAdvX",
          horizoriginx: "horizOriginX",
          "horiz-origin-x": "horizOriginX",
          ideographic: "ideographic",
          imagerendering: "imageRendering",
          "image-rendering": "imageRendering",
          in2: "in2",
          in: "in",
          inlist: "inlist",
          intercept: "intercept",
          k1: "k1",
          k2: "k2",
          k3: "k3",
          k4: "k4",
          k: "k",
          kernelmatrix: "kernelMatrix",
          kernelunitlength: "kernelUnitLength",
          kerning: "kerning",
          keypoints: "keyPoints",
          keysplines: "keySplines",
          keytimes: "keyTimes",
          lengthadjust: "lengthAdjust",
          letterspacing: "letterSpacing",
          "letter-spacing": "letterSpacing",
          lightingcolor: "lightingColor",
          "lighting-color": "lightingColor",
          limitingconeangle: "limitingConeAngle",
          local: "local",
          markerend: "markerEnd",
          "marker-end": "markerEnd",
          markerheight: "markerHeight",
          markermid: "markerMid",
          "marker-mid": "markerMid",
          markerstart: "markerStart",
          "marker-start": "markerStart",
          markerunits: "markerUnits",
          markerwidth: "markerWidth",
          mask: "mask",
          maskcontentunits: "maskContentUnits",
          maskunits: "maskUnits",
          mathematical: "mathematical",
          mode: "mode",
          numoctaves: "numOctaves",
          offset: "offset",
          opacity: "opacity",
          operator: "operator",
          order: "order",
          orient: "orient",
          orientation: "orientation",
          origin: "origin",
          overflow: "overflow",
          overlineposition: "overlinePosition",
          "overline-position": "overlinePosition",
          overlinethickness: "overlineThickness",
          "overline-thickness": "overlineThickness",
          paintorder: "paintOrder",
          "paint-order": "paintOrder",
          panose1: "panose1",
          "panose-1": "panose1",
          pathlength: "pathLength",
          patterncontentunits: "patternContentUnits",
          patterntransform: "patternTransform",
          patternunits: "patternUnits",
          pointerevents: "pointerEvents",
          "pointer-events": "pointerEvents",
          points: "points",
          pointsatx: "pointsAtX",
          pointsaty: "pointsAtY",
          pointsatz: "pointsAtZ",
          prefix: "prefix",
          preservealpha: "preserveAlpha",
          preserveaspectratio: "preserveAspectRatio",
          primitiveunits: "primitiveUnits",
          property: "property",
          r: "r",
          radius: "radius",
          refx: "refX",
          refy: "refY",
          renderingintent: "renderingIntent",
          "rendering-intent": "renderingIntent",
          repeatcount: "repeatCount",
          repeatdur: "repeatDur",
          requiredextensions: "requiredExtensions",
          requiredfeatures: "requiredFeatures",
          resource: "resource",
          restart: "restart",
          result: "result",
          results: "results",
          rotate: "rotate",
          rx: "rx",
          ry: "ry",
          scale: "scale",
          security: "security",
          seed: "seed",
          shaperendering: "shapeRendering",
          "shape-rendering": "shapeRendering",
          slope: "slope",
          spacing: "spacing",
          specularconstant: "specularConstant",
          specularexponent: "specularExponent",
          speed: "speed",
          spreadmethod: "spreadMethod",
          startoffset: "startOffset",
          stddeviation: "stdDeviation",
          stemh: "stemh",
          stemv: "stemv",
          stitchtiles: "stitchTiles",
          stopcolor: "stopColor",
          "stop-color": "stopColor",
          stopopacity: "stopOpacity",
          "stop-opacity": "stopOpacity",
          strikethroughposition: "strikethroughPosition",
          "strikethrough-position": "strikethroughPosition",
          strikethroughthickness: "strikethroughThickness",
          "strikethrough-thickness": "strikethroughThickness",
          string: "string",
          stroke: "stroke",
          strokedasharray: "strokeDasharray",
          "stroke-dasharray": "strokeDasharray",
          strokedashoffset: "strokeDashoffset",
          "stroke-dashoffset": "strokeDashoffset",
          strokelinecap: "strokeLinecap",
          "stroke-linecap": "strokeLinecap",
          strokelinejoin: "strokeLinejoin",
          "stroke-linejoin": "strokeLinejoin",
          strokemiterlimit: "strokeMiterlimit",
          "stroke-miterlimit": "strokeMiterlimit",
          strokewidth: "strokeWidth",
          "stroke-width": "strokeWidth",
          strokeopacity: "strokeOpacity",
          "stroke-opacity": "strokeOpacity",
          suppresscontenteditablewarning: "suppressContentEditableWarning",
          suppresshydrationwarning: "suppressHydrationWarning",
          surfacescale: "surfaceScale",
          systemlanguage: "systemLanguage",
          tablevalues: "tableValues",
          targetx: "targetX",
          targety: "targetY",
          textanchor: "textAnchor",
          "text-anchor": "textAnchor",
          textdecoration: "textDecoration",
          "text-decoration": "textDecoration",
          textlength: "textLength",
          textrendering: "textRendering",
          "text-rendering": "textRendering",
          to: "to",
          transform: "transform",
          typeof: "typeof",
          u1: "u1",
          u2: "u2",
          underlineposition: "underlinePosition",
          "underline-position": "underlinePosition",
          underlinethickness: "underlineThickness",
          "underline-thickness": "underlineThickness",
          unicode: "unicode",
          unicodebidi: "unicodeBidi",
          "unicode-bidi": "unicodeBidi",
          unicoderange: "unicodeRange",
          "unicode-range": "unicodeRange",
          unitsperem: "unitsPerEm",
          "units-per-em": "unitsPerEm",
          unselectable: "unselectable",
          valphabetic: "vAlphabetic",
          "v-alphabetic": "vAlphabetic",
          values: "values",
          vectoreffect: "vectorEffect",
          "vector-effect": "vectorEffect",
          version: "version",
          vertadvy: "vertAdvY",
          "vert-adv-y": "vertAdvY",
          vertoriginx: "vertOriginX",
          "vert-origin-x": "vertOriginX",
          vertoriginy: "vertOriginY",
          "vert-origin-y": "vertOriginY",
          vhanging: "vHanging",
          "v-hanging": "vHanging",
          videographic: "vIdeographic",
          "v-ideographic": "vIdeographic",
          viewbox: "viewBox",
          viewtarget: "viewTarget",
          visibility: "visibility",
          vmathematical: "vMathematical",
          "v-mathematical": "vMathematical",
          vocab: "vocab",
          widths: "widths",
          wordspacing: "wordSpacing",
          "word-spacing": "wordSpacing",
          writingmode: "writingMode",
          "writing-mode": "writingMode",
          x1: "x1",
          x2: "x2",
          x: "x",
          xchannelselector: "xChannelSelector",
          xheight: "xHeight",
          "x-height": "xHeight",
          xlinkactuate: "xlinkActuate",
          "xlink:actuate": "xlinkActuate",
          xlinkarcrole: "xlinkArcrole",
          "xlink:arcrole": "xlinkArcrole",
          xlinkhref: "xlinkHref",
          "xlink:href": "xlinkHref",
          xlinkrole: "xlinkRole",
          "xlink:role": "xlinkRole",
          xlinkshow: "xlinkShow",
          "xlink:show": "xlinkShow",
          xlinktitle: "xlinkTitle",
          "xlink:title": "xlinkTitle",
          xlinktype: "xlinkType",
          "xlink:type": "xlinkType",
          xmlbase: "xmlBase",
          "xml:base": "xmlBase",
          xmllang: "xmlLang",
          "xml:lang": "xmlLang",
          xmlns: "xmlns",
          "xml:space": "xmlSpace",
          xmlnsxlink: "xmlnsXlink",
          "xmlns:xlink": "xmlnsXlink",
          xmlspace: "xmlSpace",
          y1: "y1",
          y2: "y2",
          y: "y",
          ychannelselector: "yChannelSelector",
          z: "z",
          zoomandpan: "zoomAndPan"
        };
        var validateProperty$1 = function() {
        };
        {
          var warnedProperties$1 = {};
          var EVENT_NAME_REGEX = /^on./;
          var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
          var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
          var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
          validateProperty$1 = function(tagName, name, value, eventRegistry) {
            if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {
              return true;
            }
            var lowerCasedName = name.toLowerCase();
            if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
              error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (eventRegistry != null) {
              var registrationNameDependencies = eventRegistry.registrationNameDependencies, possibleRegistrationNames = eventRegistry.possibleRegistrationNames;
              if (registrationNameDependencies.hasOwnProperty(name)) {
                return true;
              }
              var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
              if (registrationName != null) {
                error("Invalid event handler property `%s`. Did you mean `%s`?", name, registrationName);
                warnedProperties$1[name] = true;
                return true;
              }
              if (EVENT_NAME_REGEX.test(name)) {
                error("Unknown event handler property `%s`. It will be ignored.", name);
                warnedProperties$1[name] = true;
                return true;
              }
            } else if (EVENT_NAME_REGEX.test(name)) {
              if (INVALID_EVENT_NAME_REGEX.test(name)) {
                error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name);
              }
              warnedProperties$1[name] = true;
              return true;
            }
            if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
              return true;
            }
            if (lowerCasedName === "innerhtml") {
              error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (lowerCasedName === "aria") {
              error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (lowerCasedName === "is" && value !== null && value !== void 0 && typeof value !== "string") {
              error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value);
              warnedProperties$1[name] = true;
              return true;
            }
            if (typeof value === "number" && isNaN(value)) {
              error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name);
              warnedProperties$1[name] = true;
              return true;
            }
            var propertyInfo = getPropertyInfo(name);
            var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
            if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
              var standardName = possibleStandardNames[lowerCasedName];
              if (standardName !== name) {
                error("Invalid DOM property `%s`. Did you mean `%s`?", name, standardName);
                warnedProperties$1[name] = true;
                return true;
              }
            } else if (!isReserved && name !== lowerCasedName) {
              error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName);
              warnedProperties$1[name] = true;
              return true;
            }
            if (typeof value === "boolean" && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
              if (value) {
                error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name, name, value, name);
              } else {
                error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
              }
              warnedProperties$1[name] = true;
              return true;
            }
            if (isReserved) {
              return true;
            }
            if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
              warnedProperties$1[name] = true;
              return false;
            }
            if ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
              error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
              warnedProperties$1[name] = true;
              return true;
            }
            return true;
          };
        }
        var warnUnknownProperties = function(type, props, eventRegistry) {
          {
            var unknownProps = [];
            for (var key in props) {
              var isValid = validateProperty$1(type, key, props[key], eventRegistry);
              if (!isValid) {
                unknownProps.push(key);
              }
            }
            var unknownPropString = unknownProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (unknownProps.length === 1) {
              error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
            } else if (unknownProps.length > 1) {
              error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
            }
          }
        };
        function validateProperties$2(type, props, eventRegistry) {
          if (isCustomComponent(type, props)) {
            return;
          }
          warnUnknownProperties(type, props, eventRegistry);
        }
        var warnValidStyle = function() {
        };
        {
          var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
          var msPattern = /^-ms-/;
          var hyphenPattern = /-(.)/g;
          var badStyleValueWithSemicolonPattern = /;\s*$/;
          var warnedStyleNames = {};
          var warnedStyleValues = {};
          var warnedForNaNValue = false;
          var warnedForInfinityValue = false;
          var camelize = function(string) {
            return string.replace(hyphenPattern, function(_, character) {
              return character.toUpperCase();
            });
          };
          var warnHyphenatedStyleName = function(name) {
            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
              return;
            }
            warnedStyleNames[name] = true;
            error(
              "Unsupported style property %s. Did you mean %s?",
              name,
              // As Andi Smith suggests
              // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
              // is converted to lowercase `ms`.
              camelize(name.replace(msPattern, "ms-"))
            );
          };
          var warnBadVendoredStyleName = function(name) {
            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
              return;
            }
            warnedStyleNames[name] = true;
            error("Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1));
          };
          var warnStyleValueWithSemicolon = function(name, value) {
            if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
              return;
            }
            warnedStyleValues[value] = true;
            error(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name, value.replace(badStyleValueWithSemicolonPattern, ""));
          };
          var warnStyleValueIsNaN = function(name, value) {
            if (warnedForNaNValue) {
              return;
            }
            warnedForNaNValue = true;
            error("`NaN` is an invalid value for the `%s` css style property.", name);
          };
          var warnStyleValueIsInfinity = function(name, value) {
            if (warnedForInfinityValue) {
              return;
            }
            warnedForInfinityValue = true;
            error("`Infinity` is an invalid value for the `%s` css style property.", name);
          };
          warnValidStyle = function(name, value) {
            if (name.indexOf("-") > -1) {
              warnHyphenatedStyleName(name);
            } else if (badVendoredStyleNamePattern.test(name)) {
              warnBadVendoredStyleName(name);
            } else if (badStyleValueWithSemicolonPattern.test(value)) {
              warnStyleValueWithSemicolon(name, value);
            }
            if (typeof value === "number") {
              if (isNaN(value)) {
                warnStyleValueIsNaN(name, value);
              } else if (!isFinite(value)) {
                warnStyleValueIsInfinity(name, value);
              }
            }
          };
        }
        var warnValidStyle$1 = warnValidStyle;
        var matchHtmlRegExp = /["'&<>]/;
        function escapeHtml(string) {
          {
            checkHtmlStringCoercion(string);
          }
          var str = "" + string;
          var match = matchHtmlRegExp.exec(str);
          if (!match) {
            return str;
          }
          var escape;
          var html = "";
          var index;
          var lastIndex = 0;
          for (index = match.index; index < str.length; index++) {
            switch (str.charCodeAt(index)) {
              case 34:
                escape = "&quot;";
                break;
              case 38:
                escape = "&amp;";
                break;
              case 39:
                escape = "&#x27;";
                break;
              case 60:
                escape = "&lt;";
                break;
              case 62:
                escape = "&gt;";
                break;
              default:
                continue;
            }
            if (lastIndex !== index) {
              html += str.substring(lastIndex, index);
            }
            lastIndex = index + 1;
            html += escape;
          }
          return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
        }
        function escapeTextForBrowser(text) {
          if (typeof text === "boolean" || typeof text === "number") {
            return "" + text;
          }
          return escapeHtml(text);
        }
        var uppercasePattern = /([A-Z])/g;
        var msPattern$1 = /^ms-/;
        function hyphenateStyleName(name) {
          return name.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-");
        }
        var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
        var didWarn = false;
        function sanitizeURL(url) {
          {
            if (!didWarn && isJavaScriptProtocol.test(url)) {
              didWarn = true;
              error("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
            }
          }
        }
        var isArrayImpl = Array.isArray;
        function isArray(a) {
          return isArrayImpl(a);
        }
        var startInlineScript = stringToPrecomputedChunk("<script>");
        var endInlineScript = stringToPrecomputedChunk("<\/script>");
        var startScriptSrc = stringToPrecomputedChunk('<script src="');
        var startModuleSrc = stringToPrecomputedChunk('<script type="module" src="');
        var endAsyncScript = stringToPrecomputedChunk('" async=""><\/script>');
        function escapeBootstrapScriptContent(scriptText) {
          {
            checkHtmlStringCoercion(scriptText);
          }
          return ("" + scriptText).replace(scriptRegex, scriptReplacer);
        }
        var scriptRegex = /(<\/|<)(s)(cript)/gi;
        var scriptReplacer = function(match, prefix2, s, suffix) {
          return "" + prefix2 + (s === "s" ? "\\u0073" : "\\u0053") + suffix;
        };
        function createResponseState(identifierPrefix, nonce, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
          var idPrefix = identifierPrefix === void 0 ? "" : identifierPrefix;
          var inlineScriptWithNonce = nonce === void 0 ? startInlineScript : stringToPrecomputedChunk('<script nonce="' + escapeTextForBrowser(nonce) + '">');
          var bootstrapChunks = [];
          if (bootstrapScriptContent !== void 0) {
            bootstrapChunks.push(inlineScriptWithNonce, stringToChunk(escapeBootstrapScriptContent(bootstrapScriptContent)), endInlineScript);
          }
          if (bootstrapScripts !== void 0) {
            for (var i = 0; i < bootstrapScripts.length; i++) {
              bootstrapChunks.push(startScriptSrc, stringToChunk(escapeTextForBrowser(bootstrapScripts[i])), endAsyncScript);
            }
          }
          if (bootstrapModules !== void 0) {
            for (var _i = 0; _i < bootstrapModules.length; _i++) {
              bootstrapChunks.push(startModuleSrc, stringToChunk(escapeTextForBrowser(bootstrapModules[_i])), endAsyncScript);
            }
          }
          return {
            bootstrapChunks,
            startInlineScript: inlineScriptWithNonce,
            placeholderPrefix: stringToPrecomputedChunk(idPrefix + "P:"),
            segmentPrefix: stringToPrecomputedChunk(idPrefix + "S:"),
            boundaryPrefix: idPrefix + "B:",
            idPrefix,
            nextSuspenseID: 0,
            sentCompleteSegmentFunction: false,
            sentCompleteBoundaryFunction: false,
            sentClientRenderFunction: false
          };
        }
        var ROOT_HTML_MODE = 0;
        var HTML_MODE = 1;
        var SVG_MODE = 2;
        var MATHML_MODE = 3;
        var HTML_TABLE_MODE = 4;
        var HTML_TABLE_BODY_MODE = 5;
        var HTML_TABLE_ROW_MODE = 6;
        var HTML_COLGROUP_MODE = 7;
        function createFormatContext(insertionMode, selectedValue) {
          return {
            insertionMode,
            selectedValue
          };
        }
        function getChildFormatContext(parentContext, type, props) {
          switch (type) {
            case "select":
              return createFormatContext(HTML_MODE, props.value != null ? props.value : props.defaultValue);
            case "svg":
              return createFormatContext(SVG_MODE, null);
            case "math":
              return createFormatContext(MATHML_MODE, null);
            case "foreignObject":
              return createFormatContext(HTML_MODE, null);
            case "table":
              return createFormatContext(HTML_TABLE_MODE, null);
            case "thead":
            case "tbody":
            case "tfoot":
              return createFormatContext(HTML_TABLE_BODY_MODE, null);
            case "colgroup":
              return createFormatContext(HTML_COLGROUP_MODE, null);
            case "tr":
              return createFormatContext(HTML_TABLE_ROW_MODE, null);
          }
          if (parentContext.insertionMode >= HTML_TABLE_MODE) {
            return createFormatContext(HTML_MODE, null);
          }
          if (parentContext.insertionMode === ROOT_HTML_MODE) {
            return createFormatContext(HTML_MODE, null);
          }
          return parentContext;
        }
        var UNINITIALIZED_SUSPENSE_BOUNDARY_ID = null;
        function assignSuspenseBoundaryID(responseState) {
          var generatedID = responseState.nextSuspenseID++;
          return stringToPrecomputedChunk(responseState.boundaryPrefix + generatedID.toString(16));
        }
        function makeId(responseState, treeId, localId) {
          var idPrefix = responseState.idPrefix;
          var id = ":" + idPrefix + "R" + treeId;
          if (localId > 0) {
            id += "H" + localId.toString(32);
          }
          return id + ":";
        }
        function encodeHTMLTextNode(text) {
          return escapeTextForBrowser(text);
        }
        var textSeparator = stringToPrecomputedChunk("<!-- -->");
        function pushTextInstance(target, text, responseState, textEmbedded) {
          if (text === "") {
            return textEmbedded;
          }
          if (textEmbedded) {
            target.push(textSeparator);
          }
          target.push(stringToChunk(encodeHTMLTextNode(text)));
          return true;
        }
        function pushSegmentFinale(target, responseState, lastPushedText, textEmbedded) {
          if (lastPushedText && textEmbedded) {
            target.push(textSeparator);
          }
        }
        var styleNameCache = /* @__PURE__ */ new Map();
        function processStyleName(styleName) {
          var chunk = styleNameCache.get(styleName);
          if (chunk !== void 0) {
            return chunk;
          }
          var result = stringToPrecomputedChunk(escapeTextForBrowser(hyphenateStyleName(styleName)));
          styleNameCache.set(styleName, result);
          return result;
        }
        var styleAttributeStart = stringToPrecomputedChunk(' style="');
        var styleAssign = stringToPrecomputedChunk(":");
        var styleSeparator = stringToPrecomputedChunk(";");
        function pushStyle(target, responseState, style) {
          if (typeof style !== "object") {
            throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
          }
          var isFirst = true;
          for (var styleName in style) {
            if (!hasOwnProperty.call(style, styleName)) {
              continue;
            }
            var styleValue = style[styleName];
            if (styleValue == null || typeof styleValue === "boolean" || styleValue === "") {
              continue;
            }
            var nameChunk = void 0;
            var valueChunk = void 0;
            var isCustomProperty = styleName.indexOf("--") === 0;
            if (isCustomProperty) {
              nameChunk = stringToChunk(escapeTextForBrowser(styleName));
              {
                checkCSSPropertyStringCoercion(styleValue, styleName);
              }
              valueChunk = stringToChunk(escapeTextForBrowser(("" + styleValue).trim()));
            } else {
              {
                warnValidStyle$1(styleName, styleValue);
              }
              nameChunk = processStyleName(styleName);
              if (typeof styleValue === "number") {
                if (styleValue !== 0 && !hasOwnProperty.call(isUnitlessNumber, styleName)) {
                  valueChunk = stringToChunk(styleValue + "px");
                } else {
                  valueChunk = stringToChunk("" + styleValue);
                }
              } else {
                {
                  checkCSSPropertyStringCoercion(styleValue, styleName);
                }
                valueChunk = stringToChunk(escapeTextForBrowser(("" + styleValue).trim()));
              }
            }
            if (isFirst) {
              isFirst = false;
              target.push(styleAttributeStart, nameChunk, styleAssign, valueChunk);
            } else {
              target.push(styleSeparator, nameChunk, styleAssign, valueChunk);
            }
          }
          if (!isFirst) {
            target.push(attributeEnd);
          }
        }
        var attributeSeparator = stringToPrecomputedChunk(" ");
        var attributeAssign = stringToPrecomputedChunk('="');
        var attributeEnd = stringToPrecomputedChunk('"');
        var attributeEmptyString = stringToPrecomputedChunk('=""');
        function pushAttribute(target, responseState, name, value) {
          switch (name) {
            case "style": {
              pushStyle(target, responseState, value);
              return;
            }
            case "defaultValue":
            case "defaultChecked":
            case "innerHTML":
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
              return;
          }
          if (
            // shouldIgnoreAttribute
            // We have already filtered out null/undefined and reserved words.
            name.length > 2 && (name[0] === "o" || name[0] === "O") && (name[1] === "n" || name[1] === "N")
          ) {
            return;
          }
          var propertyInfo = getPropertyInfo(name);
          if (propertyInfo !== null) {
            switch (typeof value) {
              case "function":
              case "symbol":
                return;
              case "boolean": {
                if (!propertyInfo.acceptsBooleans) {
                  return;
                }
              }
            }
            var attributeName = propertyInfo.attributeName;
            var attributeNameChunk = stringToChunk(attributeName);
            switch (propertyInfo.type) {
              case BOOLEAN:
                if (value) {
                  target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
                }
                return;
              case OVERLOADED_BOOLEAN:
                if (value === true) {
                  target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
                } else if (value === false)
                  ;
                else {
                  target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
                }
                return;
              case NUMERIC:
                if (!isNaN(value)) {
                  target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
                }
                break;
              case POSITIVE_NUMERIC:
                if (!isNaN(value) && value >= 1) {
                  target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
                }
                break;
              default:
                if (propertyInfo.sanitizeURL) {
                  {
                    checkAttributeStringCoercion(value, attributeName);
                  }
                  value = "" + value;
                  sanitizeURL(value);
                }
                target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
            }
          } else if (isAttributeNameSafe(name)) {
            switch (typeof value) {
              case "function":
              case "symbol":
                return;
              case "boolean": {
                var prefix2 = name.toLowerCase().slice(0, 5);
                if (prefix2 !== "data-" && prefix2 !== "aria-") {
                  return;
                }
              }
            }
            target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
          }
        }
        var endOfStartTag = stringToPrecomputedChunk(">");
        var endOfStartTagSelfClosing = stringToPrecomputedChunk("/>");
        function pushInnerHTML(target, innerHTML, children) {
          if (innerHTML != null) {
            if (children != null) {
              throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
            }
            if (typeof innerHTML !== "object" || !("__html" in innerHTML)) {
              throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
            }
            var html = innerHTML.__html;
            if (html !== null && html !== void 0) {
              {
                checkHtmlStringCoercion(html);
              }
              target.push(stringToChunk("" + html));
            }
          }
        }
        var didWarnDefaultInputValue = false;
        var didWarnDefaultChecked = false;
        var didWarnDefaultSelectValue = false;
        var didWarnDefaultTextareaValue = false;
        var didWarnInvalidOptionChildren = false;
        var didWarnInvalidOptionInnerHTML = false;
        var didWarnSelectedSetOnOption = false;
        function checkSelectProp(props, propName) {
          {
            var value = props[propName];
            if (value != null) {
              var array = isArray(value);
              if (props.multiple && !array) {
                error("The `%s` prop supplied to <select> must be an array if `multiple` is true.", propName);
              } else if (!props.multiple && array) {
                error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", propName);
              }
            }
          }
        }
        function pushStartSelect(target, props, responseState) {
          {
            checkControlledValueProps("select", props);
            checkSelectProp(props, "value");
            checkSelectProp(props, "defaultValue");
            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultSelectValue) {
              error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
              didWarnDefaultSelectValue = true;
            }
          }
          target.push(startChunkForTag("select"));
          var children = null;
          var innerHTML = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                case "defaultValue":
                case "value":
                  break;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          pushInnerHTML(target, innerHTML, children);
          return children;
        }
        function flattenOptionChildren(children) {
          var content = "";
          React.Children.forEach(children, function(child) {
            if (child == null) {
              return;
            }
            content += child;
            {
              if (!didWarnInvalidOptionChildren && typeof child !== "string" && typeof child !== "number") {
                didWarnInvalidOptionChildren = true;
                error("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.");
              }
            }
          });
          return content;
        }
        var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=""');
        function pushStartOption(target, props, responseState, formatContext) {
          var selectedValue = formatContext.selectedValue;
          target.push(startChunkForTag("option"));
          var children = null;
          var value = null;
          var selected = null;
          var innerHTML = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "selected":
                  selected = propValue;
                  {
                    if (!didWarnSelectedSetOnOption) {
                      error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.");
                      didWarnSelectedSetOnOption = true;
                    }
                  }
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                case "value":
                  value = propValue;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          if (selectedValue != null) {
            var stringValue;
            if (value !== null) {
              {
                checkAttributeStringCoercion(value, "value");
              }
              stringValue = "" + value;
            } else {
              {
                if (innerHTML !== null) {
                  if (!didWarnInvalidOptionInnerHTML) {
                    didWarnInvalidOptionInnerHTML = true;
                    error("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.");
                  }
                }
              }
              stringValue = flattenOptionChildren(children);
            }
            if (isArray(selectedValue)) {
              for (var i = 0; i < selectedValue.length; i++) {
                {
                  checkAttributeStringCoercion(selectedValue[i], "value");
                }
                var v = "" + selectedValue[i];
                if (v === stringValue) {
                  target.push(selectedMarkerAttribute);
                  break;
                }
              }
            } else {
              {
                checkAttributeStringCoercion(selectedValue, "select.value");
              }
              if ("" + selectedValue === stringValue) {
                target.push(selectedMarkerAttribute);
              }
            }
          } else if (selected) {
            target.push(selectedMarkerAttribute);
          }
          target.push(endOfStartTag);
          pushInnerHTML(target, innerHTML, children);
          return children;
        }
        function pushInput(target, props, responseState) {
          {
            checkControlledValueProps("input", props);
            if (props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnDefaultChecked) {
              error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
              didWarnDefaultChecked = true;
            }
            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultInputValue) {
              error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
              didWarnDefaultInputValue = true;
            }
          }
          target.push(startChunkForTag("input"));
          var value = null;
          var defaultValue = null;
          var checked = null;
          var defaultChecked = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                case "defaultChecked":
                  defaultChecked = propValue;
                  break;
                case "defaultValue":
                  defaultValue = propValue;
                  break;
                case "checked":
                  checked = propValue;
                  break;
                case "value":
                  value = propValue;
                  break;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          if (checked !== null) {
            pushAttribute(target, responseState, "checked", checked);
          } else if (defaultChecked !== null) {
            pushAttribute(target, responseState, "checked", defaultChecked);
          }
          if (value !== null) {
            pushAttribute(target, responseState, "value", value);
          } else if (defaultValue !== null) {
            pushAttribute(target, responseState, "value", defaultValue);
          }
          target.push(endOfStartTagSelfClosing);
          return null;
        }
        function pushStartTextArea(target, props, responseState) {
          {
            checkControlledValueProps("textarea", props);
            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultTextareaValue) {
              error("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components");
              didWarnDefaultTextareaValue = true;
            }
          }
          target.push(startChunkForTag("textarea"));
          var value = null;
          var defaultValue = null;
          var children = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "value":
                  value = propValue;
                  break;
                case "defaultValue":
                  defaultValue = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          if (value === null && defaultValue !== null) {
            value = defaultValue;
          }
          target.push(endOfStartTag);
          if (children != null) {
            {
              error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
            }
            if (value != null) {
              throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            }
            if (isArray(children)) {
              if (children.length > 1) {
                throw new Error("<textarea> can only have at most one child.");
              }
              {
                checkHtmlStringCoercion(children[0]);
              }
              value = "" + children[0];
            }
            {
              checkHtmlStringCoercion(children);
            }
            value = "" + children;
          }
          if (typeof value === "string" && value[0] === "\n") {
            target.push(leadingNewline);
          }
          if (value !== null) {
            {
              checkAttributeStringCoercion(value, "value");
            }
            target.push(stringToChunk(encodeHTMLTextNode("" + value)));
          }
          return null;
        }
        function pushSelfClosing(target, props, tag, responseState) {
          target.push(startChunkForTag(tag));
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw new Error(tag + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTagSelfClosing);
          return null;
        }
        function pushStartMenuItem(target, props, responseState) {
          target.push(startChunkForTag("menuitem"));
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          return null;
        }
        function pushStartTitle(target, props, responseState) {
          target.push(startChunkForTag("title"));
          var children = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          {
            var child = Array.isArray(children) && children.length < 2 ? children[0] || null : children;
            if (Array.isArray(children) && children.length > 1) {
              error("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
            } else if (child != null && child.$$typeof != null) {
              error("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
            } else if (child != null && typeof child !== "string" && typeof child !== "number") {
              error("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
            }
          }
          return children;
        }
        function pushStartGenericElement(target, props, tag, responseState) {
          target.push(startChunkForTag(tag));
          var children = null;
          var innerHTML = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          pushInnerHTML(target, innerHTML, children);
          if (typeof children === "string") {
            target.push(stringToChunk(encodeHTMLTextNode(children)));
            return null;
          }
          return children;
        }
        function pushStartCustomElement(target, props, tag, responseState) {
          target.push(startChunkForTag(tag));
          var children = null;
          var innerHTML = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                case "style":
                  pushStyle(target, responseState, propValue);
                  break;
                case "suppressContentEditableWarning":
                case "suppressHydrationWarning":
                  break;
                default:
                  if (isAttributeNameSafe(propKey) && typeof propValue !== "function" && typeof propValue !== "symbol") {
                    target.push(attributeSeparator, stringToChunk(propKey), attributeAssign, stringToChunk(escapeTextForBrowser(propValue)), attributeEnd);
                  }
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          pushInnerHTML(target, innerHTML, children);
          return children;
        }
        var leadingNewline = stringToPrecomputedChunk("\n");
        function pushStartPreformattedElement(target, props, tag, responseState) {
          target.push(startChunkForTag(tag));
          var children = null;
          var innerHTML = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          if (innerHTML != null) {
            if (children != null) {
              throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
            }
            if (typeof innerHTML !== "object" || !("__html" in innerHTML)) {
              throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
            }
            var html = innerHTML.__html;
            if (html !== null && html !== void 0) {
              if (typeof html === "string" && html.length > 0 && html[0] === "\n") {
                target.push(leadingNewline, stringToChunk(html));
              } else {
                {
                  checkHtmlStringCoercion(html);
                }
                target.push(stringToChunk("" + html));
              }
            }
          }
          if (typeof children === "string" && children[0] === "\n") {
            target.push(leadingNewline);
          }
          return children;
        }
        var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
        var validatedTagCache = /* @__PURE__ */ new Map();
        function startChunkForTag(tag) {
          var tagStartChunk = validatedTagCache.get(tag);
          if (tagStartChunk === void 0) {
            if (!VALID_TAG_REGEX.test(tag)) {
              throw new Error("Invalid tag: " + tag);
            }
            tagStartChunk = stringToPrecomputedChunk("<" + tag);
            validatedTagCache.set(tag, tagStartChunk);
          }
          return tagStartChunk;
        }
        var DOCTYPE = stringToPrecomputedChunk("<!DOCTYPE html>");
        function pushStartInstance(target, type, props, responseState, formatContext) {
          {
            validateProperties(type, props);
            validateProperties$1(type, props);
            validateProperties$2(type, props, null);
            if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
              error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
            }
            if (formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE) {
              if (type.indexOf("-") === -1 && typeof props.is !== "string" && type.toLowerCase() !== type) {
                error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type);
              }
            }
          }
          switch (type) {
            case "select":
              return pushStartSelect(target, props, responseState);
            case "option":
              return pushStartOption(target, props, responseState, formatContext);
            case "textarea":
              return pushStartTextArea(target, props, responseState);
            case "input":
              return pushInput(target, props, responseState);
            case "menuitem":
              return pushStartMenuItem(target, props, responseState);
            case "title":
              return pushStartTitle(target, props, responseState);
            case "listing":
            case "pre": {
              return pushStartPreformattedElement(target, props, type, responseState);
            }
            case "area":
            case "base":
            case "br":
            case "col":
            case "embed":
            case "hr":
            case "img":
            case "keygen":
            case "link":
            case "meta":
            case "param":
            case "source":
            case "track":
            case "wbr": {
              return pushSelfClosing(target, props, type, responseState);
            }
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph": {
              return pushStartGenericElement(target, props, type, responseState);
            }
            case "html": {
              if (formatContext.insertionMode === ROOT_HTML_MODE) {
                target.push(DOCTYPE);
              }
              return pushStartGenericElement(target, props, type, responseState);
            }
            default: {
              if (type.indexOf("-") === -1 && typeof props.is !== "string") {
                return pushStartGenericElement(target, props, type, responseState);
              } else {
                return pushStartCustomElement(target, props, type, responseState);
              }
            }
          }
        }
        var endTag1 = stringToPrecomputedChunk("</");
        var endTag2 = stringToPrecomputedChunk(">");
        function pushEndInstance(target, type, props) {
          switch (type) {
            case "area":
            case "base":
            case "br":
            case "col":
            case "embed":
            case "hr":
            case "img":
            case "input":
            case "keygen":
            case "link":
            case "meta":
            case "param":
            case "source":
            case "track":
            case "wbr": {
              break;
            }
            default: {
              target.push(endTag1, stringToChunk(type), endTag2);
            }
          }
        }
        function writeCompletedRoot(destination, responseState) {
          var bootstrapChunks = responseState.bootstrapChunks;
          var i = 0;
          for (; i < bootstrapChunks.length - 1; i++) {
            writeChunk(destination, bootstrapChunks[i]);
          }
          if (i < bootstrapChunks.length) {
            return writeChunkAndReturn(destination, bootstrapChunks[i]);
          }
          return true;
        }
        var placeholder1 = stringToPrecomputedChunk('<template id="');
        var placeholder2 = stringToPrecomputedChunk('"></template>');
        function writePlaceholder(destination, responseState, id) {
          writeChunk(destination, placeholder1);
          writeChunk(destination, responseState.placeholderPrefix);
          var formattedID = stringToChunk(id.toString(16));
          writeChunk(destination, formattedID);
          return writeChunkAndReturn(destination, placeholder2);
        }
        var startCompletedSuspenseBoundary = stringToPrecomputedChunk("<!--$-->");
        var startPendingSuspenseBoundary1 = stringToPrecomputedChunk('<!--$?--><template id="');
        var startPendingSuspenseBoundary2 = stringToPrecomputedChunk('"></template>');
        var startClientRenderedSuspenseBoundary = stringToPrecomputedChunk("<!--$!-->");
        var endSuspenseBoundary = stringToPrecomputedChunk("<!--/$-->");
        var clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk("<template");
        var clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk('"');
        var clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(' data-dgst="');
        var clientRenderedSuspenseBoundaryError1B = stringToPrecomputedChunk(' data-msg="');
        var clientRenderedSuspenseBoundaryError1C = stringToPrecomputedChunk(' data-stck="');
        var clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk("></template>");
        function writeStartCompletedSuspenseBoundary(destination, responseState) {
          return writeChunkAndReturn(destination, startCompletedSuspenseBoundary);
        }
        function writeStartPendingSuspenseBoundary(destination, responseState, id) {
          writeChunk(destination, startPendingSuspenseBoundary1);
          if (id === null) {
            throw new Error("An ID must have been assigned before we can complete the boundary.");
          }
          writeChunk(destination, id);
          return writeChunkAndReturn(destination, startPendingSuspenseBoundary2);
        }
        function writeStartClientRenderedSuspenseBoundary(destination, responseState, errorDigest, errorMesssage, errorComponentStack) {
          var result;
          result = writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary);
          writeChunk(destination, clientRenderedSuspenseBoundaryError1);
          if (errorDigest) {
            writeChunk(destination, clientRenderedSuspenseBoundaryError1A);
            writeChunk(destination, stringToChunk(escapeTextForBrowser(errorDigest)));
            writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
          }
          {
            if (errorMesssage) {
              writeChunk(destination, clientRenderedSuspenseBoundaryError1B);
              writeChunk(destination, stringToChunk(escapeTextForBrowser(errorMesssage)));
              writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
            }
            if (errorComponentStack) {
              writeChunk(destination, clientRenderedSuspenseBoundaryError1C);
              writeChunk(destination, stringToChunk(escapeTextForBrowser(errorComponentStack)));
              writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
            }
          }
          result = writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2);
          return result;
        }
        function writeEndCompletedSuspenseBoundary(destination, responseState) {
          return writeChunkAndReturn(destination, endSuspenseBoundary);
        }
        function writeEndPendingSuspenseBoundary(destination, responseState) {
          return writeChunkAndReturn(destination, endSuspenseBoundary);
        }
        function writeEndClientRenderedSuspenseBoundary(destination, responseState) {
          return writeChunkAndReturn(destination, endSuspenseBoundary);
        }
        var startSegmentHTML = stringToPrecomputedChunk('<div hidden id="');
        var startSegmentHTML2 = stringToPrecomputedChunk('">');
        var endSegmentHTML = stringToPrecomputedChunk("</div>");
        var startSegmentSVG = stringToPrecomputedChunk('<svg aria-hidden="true" style="display:none" id="');
        var startSegmentSVG2 = stringToPrecomputedChunk('">');
        var endSegmentSVG = stringToPrecomputedChunk("</svg>");
        var startSegmentMathML = stringToPrecomputedChunk('<math aria-hidden="true" style="display:none" id="');
        var startSegmentMathML2 = stringToPrecomputedChunk('">');
        var endSegmentMathML = stringToPrecomputedChunk("</math>");
        var startSegmentTable = stringToPrecomputedChunk('<table hidden id="');
        var startSegmentTable2 = stringToPrecomputedChunk('">');
        var endSegmentTable = stringToPrecomputedChunk("</table>");
        var startSegmentTableBody = stringToPrecomputedChunk('<table hidden><tbody id="');
        var startSegmentTableBody2 = stringToPrecomputedChunk('">');
        var endSegmentTableBody = stringToPrecomputedChunk("</tbody></table>");
        var startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id="');
        var startSegmentTableRow2 = stringToPrecomputedChunk('">');
        var endSegmentTableRow = stringToPrecomputedChunk("</tr></table>");
        var startSegmentColGroup = stringToPrecomputedChunk('<table hidden><colgroup id="');
        var startSegmentColGroup2 = stringToPrecomputedChunk('">');
        var endSegmentColGroup = stringToPrecomputedChunk("</colgroup></table>");
        function writeStartSegment(destination, responseState, formatContext, id) {
          switch (formatContext.insertionMode) {
            case ROOT_HTML_MODE:
            case HTML_MODE: {
              writeChunk(destination, startSegmentHTML);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentHTML2);
            }
            case SVG_MODE: {
              writeChunk(destination, startSegmentSVG);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentSVG2);
            }
            case MATHML_MODE: {
              writeChunk(destination, startSegmentMathML);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentMathML2);
            }
            case HTML_TABLE_MODE: {
              writeChunk(destination, startSegmentTable);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentTable2);
            }
            case HTML_TABLE_BODY_MODE: {
              writeChunk(destination, startSegmentTableBody);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentTableBody2);
            }
            case HTML_TABLE_ROW_MODE: {
              writeChunk(destination, startSegmentTableRow);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentTableRow2);
            }
            case HTML_COLGROUP_MODE: {
              writeChunk(destination, startSegmentColGroup);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentColGroup2);
            }
            default: {
              throw new Error("Unknown insertion mode. This is a bug in React.");
            }
          }
        }
        function writeEndSegment(destination, formatContext) {
          switch (formatContext.insertionMode) {
            case ROOT_HTML_MODE:
            case HTML_MODE: {
              return writeChunkAndReturn(destination, endSegmentHTML);
            }
            case SVG_MODE: {
              return writeChunkAndReturn(destination, endSegmentSVG);
            }
            case MATHML_MODE: {
              return writeChunkAndReturn(destination, endSegmentMathML);
            }
            case HTML_TABLE_MODE: {
              return writeChunkAndReturn(destination, endSegmentTable);
            }
            case HTML_TABLE_BODY_MODE: {
              return writeChunkAndReturn(destination, endSegmentTableBody);
            }
            case HTML_TABLE_ROW_MODE: {
              return writeChunkAndReturn(destination, endSegmentTableRow);
            }
            case HTML_COLGROUP_MODE: {
              return writeChunkAndReturn(destination, endSegmentColGroup);
            }
            default: {
              throw new Error("Unknown insertion mode. This is a bug in React.");
            }
          }
        }
        var completeSegmentFunction = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}";
        var completeBoundaryFunction = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}';
        var clientRenderFunction = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}';
        var completeSegmentScript1Full = stringToPrecomputedChunk(completeSegmentFunction + ';$RS("');
        var completeSegmentScript1Partial = stringToPrecomputedChunk('$RS("');
        var completeSegmentScript2 = stringToPrecomputedChunk('","');
        var completeSegmentScript3 = stringToPrecomputedChunk('")<\/script>');
        function writeCompletedSegmentInstruction(destination, responseState, contentSegmentID) {
          writeChunk(destination, responseState.startInlineScript);
          if (!responseState.sentCompleteSegmentFunction) {
            responseState.sentCompleteSegmentFunction = true;
            writeChunk(destination, completeSegmentScript1Full);
          } else {
            writeChunk(destination, completeSegmentScript1Partial);
          }
          writeChunk(destination, responseState.segmentPrefix);
          var formattedID = stringToChunk(contentSegmentID.toString(16));
          writeChunk(destination, formattedID);
          writeChunk(destination, completeSegmentScript2);
          writeChunk(destination, responseState.placeholderPrefix);
          writeChunk(destination, formattedID);
          return writeChunkAndReturn(destination, completeSegmentScript3);
        }
        var completeBoundaryScript1Full = stringToPrecomputedChunk(completeBoundaryFunction + ';$RC("');
        var completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC("');
        var completeBoundaryScript2 = stringToPrecomputedChunk('","');
        var completeBoundaryScript3 = stringToPrecomputedChunk('")<\/script>');
        function writeCompletedBoundaryInstruction(destination, responseState, boundaryID, contentSegmentID) {
          writeChunk(destination, responseState.startInlineScript);
          if (!responseState.sentCompleteBoundaryFunction) {
            responseState.sentCompleteBoundaryFunction = true;
            writeChunk(destination, completeBoundaryScript1Full);
          } else {
            writeChunk(destination, completeBoundaryScript1Partial);
          }
          if (boundaryID === null) {
            throw new Error("An ID must have been assigned before we can complete the boundary.");
          }
          var formattedContentID = stringToChunk(contentSegmentID.toString(16));
          writeChunk(destination, boundaryID);
          writeChunk(destination, completeBoundaryScript2);
          writeChunk(destination, responseState.segmentPrefix);
          writeChunk(destination, formattedContentID);
          return writeChunkAndReturn(destination, completeBoundaryScript3);
        }
        var clientRenderScript1Full = stringToPrecomputedChunk(clientRenderFunction + ';$RX("');
        var clientRenderScript1Partial = stringToPrecomputedChunk('$RX("');
        var clientRenderScript1A = stringToPrecomputedChunk('"');
        var clientRenderScript2 = stringToPrecomputedChunk(")<\/script>");
        var clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(",");
        function writeClientRenderBoundaryInstruction(destination, responseState, boundaryID, errorDigest, errorMessage, errorComponentStack) {
          writeChunk(destination, responseState.startInlineScript);
          if (!responseState.sentClientRenderFunction) {
            responseState.sentClientRenderFunction = true;
            writeChunk(destination, clientRenderScript1Full);
          } else {
            writeChunk(destination, clientRenderScript1Partial);
          }
          if (boundaryID === null) {
            throw new Error("An ID must have been assigned before we can complete the boundary.");
          }
          writeChunk(destination, boundaryID);
          writeChunk(destination, clientRenderScript1A);
          if (errorDigest || errorMessage || errorComponentStack) {
            writeChunk(destination, clientRenderErrorScriptArgInterstitial);
            writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorDigest || "")));
          }
          if (errorMessage || errorComponentStack) {
            writeChunk(destination, clientRenderErrorScriptArgInterstitial);
            writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorMessage || "")));
          }
          if (errorComponentStack) {
            writeChunk(destination, clientRenderErrorScriptArgInterstitial);
            writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorComponentStack)));
          }
          return writeChunkAndReturn(destination, clientRenderScript2);
        }
        var regexForJSStringsInScripts = /[<\u2028\u2029]/g;
        function escapeJSStringsForInstructionScripts(input) {
          var escaped = JSON.stringify(input);
          return escaped.replace(regexForJSStringsInScripts, function(match) {
            switch (match) {
              case "<":
                return "\\u003c";
              case "\u2028":
                return "\\u2028";
              case "\u2029":
                return "\\u2029";
              default: {
                throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
              }
            }
          });
        }
        function createResponseState$1(generateStaticMarkup, identifierPrefix) {
          var responseState = createResponseState(identifierPrefix, void 0);
          return {
            // Keep this in sync with ReactDOMServerFormatConfig
            bootstrapChunks: responseState.bootstrapChunks,
            startInlineScript: responseState.startInlineScript,
            placeholderPrefix: responseState.placeholderPrefix,
            segmentPrefix: responseState.segmentPrefix,
            boundaryPrefix: responseState.boundaryPrefix,
            idPrefix: responseState.idPrefix,
            nextSuspenseID: responseState.nextSuspenseID,
            sentCompleteSegmentFunction: responseState.sentCompleteSegmentFunction,
            sentCompleteBoundaryFunction: responseState.sentCompleteBoundaryFunction,
            sentClientRenderFunction: responseState.sentClientRenderFunction,
            // This is an extra field for the legacy renderer
            generateStaticMarkup
          };
        }
        function createRootFormatContext() {
          return {
            insertionMode: HTML_MODE,
            // We skip the root mode because we don't want to emit the DOCTYPE in legacy mode.
            selectedValue: null
          };
        }
        function pushTextInstance$1(target, text, responseState, textEmbedded) {
          if (responseState.generateStaticMarkup) {
            target.push(stringToChunk(escapeTextForBrowser(text)));
            return false;
          } else {
            return pushTextInstance(target, text, responseState, textEmbedded);
          }
        }
        function pushSegmentFinale$1(target, responseState, lastPushedText, textEmbedded) {
          if (responseState.generateStaticMarkup) {
            return;
          } else {
            return pushSegmentFinale(target, responseState, lastPushedText, textEmbedded);
          }
        }
        function writeStartCompletedSuspenseBoundary$1(destination, responseState) {
          if (responseState.generateStaticMarkup) {
            return true;
          }
          return writeStartCompletedSuspenseBoundary(destination);
        }
        function writeStartClientRenderedSuspenseBoundary$1(destination, responseState, errorDigest, errorMessage, errorComponentStack) {
          if (responseState.generateStaticMarkup) {
            return true;
          }
          return writeStartClientRenderedSuspenseBoundary(destination, responseState, errorDigest, errorMessage, errorComponentStack);
        }
        function writeEndCompletedSuspenseBoundary$1(destination, responseState) {
          if (responseState.generateStaticMarkup) {
            return true;
          }
          return writeEndCompletedSuspenseBoundary(destination);
        }
        function writeEndClientRenderedSuspenseBoundary$1(destination, responseState) {
          if (responseState.generateStaticMarkup) {
            return true;
          }
          return writeEndClientRenderedSuspenseBoundary(destination);
        }
        var assign = Object.assign;
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_SCOPE_TYPE = Symbol.for("react.scope");
        var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode");
        var REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
        var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for("react.default_value");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName;
          if (displayName) {
            return displayName;
          }
          var functionName = innerType.displayName || innerType.name || "";
          return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentNameFromType(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                var outerName = type.displayName || null;
                if (outerName !== null) {
                  return outerName;
                }
                return getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return getComponentNameFromType(init(payload));
                } catch (x) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: assign({}, props, {
                  value: prevLog
                }),
                info: assign({}, props, {
                  value: prevInfo
                }),
                warn: assign({}, props, {
                  value: prevWarn
                }),
                error: assign({}, props, {
                  value: prevError
                }),
                group: assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x) {
                var match = x.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x) {
                  control = x;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x) {
                control = x;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s = sampleLines.length - 1;
              var c = controlLines.length - 1;
              while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                c--;
              }
              for (; s >= 1 && c >= 0; s--, c--) {
                if (sampleLines[s] !== controlLines[c]) {
                  if (s !== 1 || c !== 1) {
                    do {
                      s--;
                      c--;
                      if (c < 0 || sampleLines[s] !== controlLines[c]) {
                        var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                        if (fn.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn.displayName);
                        }
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s >= 1 && c >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeClassComponentFrame(ctor, source, ownerFn) {
          {
            return describeNativeComponentFrame(ctor, true);
          }
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component) {
          var prototype = Component.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x) {
                }
              }
            }
          }
          return "";
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
          {
            var has = Function.call.bind(hasOwnProperty);
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        var warnedAboutMissingGetChildContext;
        {
          warnedAboutMissingGetChildContext = {};
        }
        var emptyContextObject = {};
        {
          Object.freeze(emptyContextObject);
        }
        function getMaskedContext(type, unmaskedContext) {
          {
            var contextTypes = type.contextTypes;
            if (!contextTypes) {
              return emptyContextObject;
            }
            var context = {};
            for (var key in contextTypes) {
              context[key] = unmaskedContext[key];
            }
            {
              var name = getComponentNameFromType(type) || "Unknown";
              checkPropTypes(contextTypes, context, "context", name);
            }
            return context;
          }
        }
        function processChildContext(instance, type, parentContext, childContextTypes) {
          {
            if (typeof instance.getChildContext !== "function") {
              {
                var componentName = getComponentNameFromType(type) || "Unknown";
                if (!warnedAboutMissingGetChildContext[componentName]) {
                  warnedAboutMissingGetChildContext[componentName] = true;
                  error("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
                }
              }
              return parentContext;
            }
            var childContext = instance.getChildContext();
            for (var contextKey in childContext) {
              if (!(contextKey in childContextTypes)) {
                throw new Error((getComponentNameFromType(type) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
              }
            }
            {
              var name = getComponentNameFromType(type) || "Unknown";
              checkPropTypes(childContextTypes, childContext, "child context", name);
            }
            return assign({}, parentContext, childContext);
          }
        }
        var rendererSigil;
        {
          rendererSigil = {};
        }
        var rootContextSnapshot = null;
        var currentActiveSnapshot = null;
        function popNode(prev) {
          {
            prev.context._currentValue2 = prev.parentValue;
          }
        }
        function pushNode(next) {
          {
            next.context._currentValue2 = next.value;
          }
        }
        function popToNearestCommonAncestor(prev, next) {
          if (prev === next)
            ;
          else {
            popNode(prev);
            var parentPrev = prev.parent;
            var parentNext = next.parent;
            if (parentPrev === null) {
              if (parentNext !== null) {
                throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
              }
            } else {
              if (parentNext === null) {
                throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
              }
              popToNearestCommonAncestor(parentPrev, parentNext);
            }
            pushNode(next);
          }
        }
        function popAllPrevious(prev) {
          popNode(prev);
          var parentPrev = prev.parent;
          if (parentPrev !== null) {
            popAllPrevious(parentPrev);
          }
        }
        function pushAllNext(next) {
          var parentNext = next.parent;
          if (parentNext !== null) {
            pushAllNext(parentNext);
          }
          pushNode(next);
        }
        function popPreviousToCommonLevel(prev, next) {
          popNode(prev);
          var parentPrev = prev.parent;
          if (parentPrev === null) {
            throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
          }
          if (parentPrev.depth === next.depth) {
            popToNearestCommonAncestor(parentPrev, next);
          } else {
            popPreviousToCommonLevel(parentPrev, next);
          }
        }
        function popNextToCommonLevel(prev, next) {
          var parentNext = next.parent;
          if (parentNext === null) {
            throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
          }
          if (prev.depth === parentNext.depth) {
            popToNearestCommonAncestor(prev, parentNext);
          } else {
            popNextToCommonLevel(prev, parentNext);
          }
          pushNode(next);
        }
        function switchContext(newSnapshot) {
          var prev = currentActiveSnapshot;
          var next = newSnapshot;
          if (prev !== next) {
            if (prev === null) {
              pushAllNext(next);
            } else if (next === null) {
              popAllPrevious(prev);
            } else if (prev.depth === next.depth) {
              popToNearestCommonAncestor(prev, next);
            } else if (prev.depth > next.depth) {
              popPreviousToCommonLevel(prev, next);
            } else {
              popNextToCommonLevel(prev, next);
            }
            currentActiveSnapshot = next;
          }
        }
        function pushProvider(context, nextValue) {
          var prevValue;
          {
            prevValue = context._currentValue2;
            context._currentValue2 = nextValue;
            {
              if (context._currentRenderer2 !== void 0 && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil) {
                error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
              }
              context._currentRenderer2 = rendererSigil;
            }
          }
          var prevNode = currentActiveSnapshot;
          var newNode = {
            parent: prevNode,
            depth: prevNode === null ? 0 : prevNode.depth + 1,
            context,
            parentValue: prevValue,
            value: nextValue
          };
          currentActiveSnapshot = newNode;
          return newNode;
        }
        function popProvider(context) {
          var prevSnapshot = currentActiveSnapshot;
          if (prevSnapshot === null) {
            throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
          }
          {
            if (prevSnapshot.context !== context) {
              error("The parent context is not the expected context. This is probably a bug in React.");
            }
          }
          {
            var _value = prevSnapshot.parentValue;
            if (_value === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {
              prevSnapshot.context._currentValue2 = prevSnapshot.context._defaultValue;
            } else {
              prevSnapshot.context._currentValue2 = _value;
            }
            {
              if (context._currentRenderer2 !== void 0 && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil) {
                error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
              }
              context._currentRenderer2 = rendererSigil;
            }
          }
          return currentActiveSnapshot = prevSnapshot.parent;
        }
        function getActiveContext() {
          return currentActiveSnapshot;
        }
        function readContext(context) {
          var value = context._currentValue2;
          return value;
        }
        function get(key) {
          return key._reactInternals;
        }
        function set(key, value) {
          key._reactInternals = value;
        }
        var didWarnAboutNoopUpdateForComponent = {};
        var didWarnAboutDeprecatedWillMount = {};
        var didWarnAboutUninitializedState;
        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
        var didWarnAboutLegacyLifecyclesAndDerivedState;
        var didWarnAboutUndefinedDerivedState;
        var warnOnUndefinedDerivedState;
        var warnOnInvalidCallback;
        var didWarnAboutDirectlyAssigningPropsToState;
        var didWarnAboutContextTypeAndContextTypes;
        var didWarnAboutInvalidateContextType;
        {
          didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
          didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
          didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
          didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
          didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
          didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set();
          didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
          var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
          warnOnInvalidCallback = function(callback, callerName) {
            if (callback === null || typeof callback === "function") {
              return;
            }
            var key = callerName + "_" + callback;
            if (!didWarnOnInvalidCallback.has(key)) {
              didWarnOnInvalidCallback.add(key);
              error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
            }
          };
          warnOnUndefinedDerivedState = function(type, partialState) {
            if (partialState === void 0) {
              var componentName = getComponentNameFromType(type) || "Component";
              if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
                didWarnAboutUndefinedDerivedState.add(componentName);
                error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
              }
            }
          };
        }
        function warnNoop(publicInstance, callerName) {
          {
            var _constructor = publicInstance.constructor;
            var componentName = _constructor && getComponentNameFromType(_constructor) || "ReactClass";
            var warningKey = componentName + "." + callerName;
            if (didWarnAboutNoopUpdateForComponent[warningKey]) {
              return;
            }
            error("%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\n\nPlease check the code for the %s component.", callerName, callerName, componentName);
            didWarnAboutNoopUpdateForComponent[warningKey] = true;
          }
        }
        var classComponentUpdater = {
          isMounted: function(inst) {
            return false;
          },
          enqueueSetState: function(inst, payload, callback) {
            var internals = get(inst);
            if (internals.queue === null) {
              warnNoop(inst, "setState");
            } else {
              internals.queue.push(payload);
              {
                if (callback !== void 0 && callback !== null) {
                  warnOnInvalidCallback(callback, "setState");
                }
              }
            }
          },
          enqueueReplaceState: function(inst, payload, callback) {
            var internals = get(inst);
            internals.replace = true;
            internals.queue = [payload];
            {
              if (callback !== void 0 && callback !== null) {
                warnOnInvalidCallback(callback, "setState");
              }
            }
          },
          enqueueForceUpdate: function(inst, callback) {
            var internals = get(inst);
            if (internals.queue === null) {
              warnNoop(inst, "forceUpdate");
            } else {
              {
                if (callback !== void 0 && callback !== null) {
                  warnOnInvalidCallback(callback, "setState");
                }
              }
            }
          }
        };
        function applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, prevState, nextProps) {
          var partialState = getDerivedStateFromProps(nextProps, prevState);
          {
            warnOnUndefinedDerivedState(ctor, partialState);
          }
          var newState = partialState === null || partialState === void 0 ? prevState : assign({}, prevState, partialState);
          return newState;
        }
        function constructClassInstance(ctor, props, maskedLegacyContext) {
          var context = emptyContextObject;
          var contextType = ctor.contextType;
          {
            if ("contextType" in ctor) {
              var isValid = (
                // Allow null for conditional declaration
                contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0
              );
              if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
                didWarnAboutInvalidateContextType.add(ctor);
                var addendum = "";
                if (contextType === void 0) {
                  addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
                } else if (typeof contextType !== "object") {
                  addendum = " However, it is set to a " + typeof contextType + ".";
                } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                  addendum = " Did you accidentally pass the Context.Provider instead?";
                } else if (contextType._context !== void 0) {
                  addendum = " Did you accidentally pass the Context.Consumer instead?";
                } else {
                  addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
                }
                error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
              }
            }
          }
          if (typeof contextType === "object" && contextType !== null) {
            context = readContext(contextType);
          } else {
            context = maskedLegacyContext;
          }
          var instance = new ctor(props, context);
          {
            if (typeof ctor.getDerivedStateFromProps === "function" && (instance.state === null || instance.state === void 0)) {
              var componentName = getComponentNameFromType(ctor) || "Component";
              if (!didWarnAboutUninitializedState.has(componentName)) {
                didWarnAboutUninitializedState.add(componentName);
                error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
              }
            }
            if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
              var foundWillMountName = null;
              var foundWillReceivePropsName = null;
              var foundWillUpdateName = null;
              if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
                foundWillMountName = "componentWillMount";
              } else if (typeof instance.UNSAFE_componentWillMount === "function") {
                foundWillMountName = "UNSAFE_componentWillMount";
              }
              if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                foundWillReceivePropsName = "componentWillReceiveProps";
              } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
                foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
              }
              if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                foundWillUpdateName = "componentWillUpdate";
              } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                foundWillUpdateName = "UNSAFE_componentWillUpdate";
              }
              if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
                var _componentName = getComponentNameFromType(ctor) || "Component";
                var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                  didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                  error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
                }
              }
            }
          }
          return instance;
        }
        function checkClassInstance(instance, ctor, newProps) {
          {
            var name = getComponentNameFromType(ctor) || "Component";
            var renderPresent = instance.render;
            if (!renderPresent) {
              if (ctor.prototype && typeof ctor.prototype.render === "function") {
                error("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name);
              } else {
                error("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name);
              }
            }
            if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
              error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name);
            }
            if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name);
            }
            if (instance.propTypes) {
              error("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name);
            }
            if (instance.contextType) {
              error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name);
            }
            {
              if (instance.contextTypes) {
                error("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name);
              }
              if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
                didWarnAboutContextTypeAndContextTypes.add(ctor);
                error("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name);
              }
            }
            if (typeof instance.componentShouldUpdate === "function") {
              error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name);
            }
            if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
              error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component");
            }
            if (typeof instance.componentDidUnmount === "function") {
              error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name);
            }
            if (typeof instance.componentDidReceiveProps === "function") {
              error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name);
            }
            if (typeof instance.componentWillRecieveProps === "function") {
              error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name);
            }
            if (typeof instance.UNSAFE_componentWillRecieveProps === "function") {
              error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name);
            }
            var hasMutatedProps = instance.props !== newProps;
            if (instance.props !== void 0 && hasMutatedProps) {
              error("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name, name);
            }
            if (instance.defaultProps) {
              error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name, name);
            }
            if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
              didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
              error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor));
            }
            if (typeof instance.getDerivedStateFromProps === "function") {
              error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
            }
            if (typeof instance.getDerivedStateFromError === "function") {
              error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
            }
            if (typeof ctor.getSnapshotBeforeUpdate === "function") {
              error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name);
            }
            var _state = instance.state;
            if (_state && (typeof _state !== "object" || isArray(_state))) {
              error("%s.state: must be set to an object or null", name);
            }
            if (typeof instance.getChildContext === "function" && typeof ctor.childContextTypes !== "object") {
              error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name);
            }
          }
        }
        function callComponentWillMount(type, instance) {
          var oldState = instance.state;
          if (typeof instance.componentWillMount === "function") {
            {
              if (instance.componentWillMount.__suppressDeprecationWarning !== true) {
                var componentName = getComponentNameFromType(type) || "Unknown";
                if (!didWarnAboutDeprecatedWillMount[componentName]) {
                  warn(
                    // keep this warning in sync with ReactStrictModeWarning.js
                    "componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\n\nPlease update the following components: %s",
                    componentName
                  );
                  didWarnAboutDeprecatedWillMount[componentName] = true;
                }
              }
            }
            instance.componentWillMount();
          }
          if (typeof instance.UNSAFE_componentWillMount === "function") {
            instance.UNSAFE_componentWillMount();
          }
          if (oldState !== instance.state) {
            {
              error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromType(type) || "Component");
            }
            classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
          }
        }
        function processUpdateQueue(internalInstance, inst, props, maskedLegacyContext) {
          if (internalInstance.queue !== null && internalInstance.queue.length > 0) {
            var oldQueue = internalInstance.queue;
            var oldReplace = internalInstance.replace;
            internalInstance.queue = null;
            internalInstance.replace = false;
            if (oldReplace && oldQueue.length === 1) {
              inst.state = oldQueue[0];
            } else {
              var nextState = oldReplace ? oldQueue[0] : inst.state;
              var dontMutate = true;
              for (var i = oldReplace ? 1 : 0; i < oldQueue.length; i++) {
                var partial = oldQueue[i];
                var partialState = typeof partial === "function" ? partial.call(inst, nextState, props, maskedLegacyContext) : partial;
                if (partialState != null) {
                  if (dontMutate) {
                    dontMutate = false;
                    nextState = assign({}, nextState, partialState);
                  } else {
                    assign(nextState, partialState);
                  }
                }
              }
              inst.state = nextState;
            }
          } else {
            internalInstance.queue = null;
          }
        }
        function mountClassInstance(instance, ctor, newProps, maskedLegacyContext) {
          {
            checkClassInstance(instance, ctor, newProps);
          }
          var initialState = instance.state !== void 0 ? instance.state : null;
          instance.updater = classComponentUpdater;
          instance.props = newProps;
          instance.state = initialState;
          var internalInstance = {
            queue: [],
            replace: false
          };
          set(instance, internalInstance);
          var contextType = ctor.contextType;
          if (typeof contextType === "object" && contextType !== null) {
            instance.context = readContext(contextType);
          } else {
            instance.context = maskedLegacyContext;
          }
          {
            if (instance.state === newProps) {
              var componentName = getComponentNameFromType(ctor) || "Component";
              if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
                didWarnAboutDirectlyAssigningPropsToState.add(componentName);
                error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
              }
            }
          }
          var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
          if (typeof getDerivedStateFromProps === "function") {
            instance.state = applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, initialState, newProps);
          }
          if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
            callComponentWillMount(ctor, instance);
            processUpdateQueue(internalInstance, instance, newProps, maskedLegacyContext);
          }
        }
        var emptyTreeContext = {
          id: 1,
          overflow: ""
        };
        function getTreeId(context) {
          var overflow = context.overflow;
          var idWithLeadingBit = context.id;
          var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
          return id.toString(32) + overflow;
        }
        function pushTreeContext(baseContext, totalChildren, index) {
          var baseIdWithLeadingBit = baseContext.id;
          var baseOverflow = baseContext.overflow;
          var baseLength = getBitLength(baseIdWithLeadingBit) - 1;
          var baseId = baseIdWithLeadingBit & ~(1 << baseLength);
          var slot = index + 1;
          var length = getBitLength(totalChildren) + baseLength;
          if (length > 30) {
            var numberOfOverflowBits = baseLength - baseLength % 5;
            var newOverflowBits = (1 << numberOfOverflowBits) - 1;
            var newOverflow = (baseId & newOverflowBits).toString(32);
            var restOfBaseId = baseId >> numberOfOverflowBits;
            var restOfBaseLength = baseLength - numberOfOverflowBits;
            var restOfLength = getBitLength(totalChildren) + restOfBaseLength;
            var restOfNewBits = slot << restOfBaseLength;
            var id = restOfNewBits | restOfBaseId;
            var overflow = newOverflow + baseOverflow;
            return {
              id: 1 << restOfLength | id,
              overflow
            };
          } else {
            var newBits = slot << baseLength;
            var _id = newBits | baseId;
            var _overflow = baseOverflow;
            return {
              id: 1 << length | _id,
              overflow: _overflow
            };
          }
        }
        function getBitLength(number) {
          return 32 - clz32(number);
        }
        function getLeadingBit(id) {
          return 1 << getBitLength(id) - 1;
        }
        var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
        var log = Math.log;
        var LN2 = Math.LN2;
        function clz32Fallback(x) {
          var asUint = x >>> 0;
          if (asUint === 0) {
            return 32;
          }
          return 31 - (log(asUint) / LN2 | 0) | 0;
        }
        function is(x, y) {
          return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        var currentlyRenderingComponent = null;
        var currentlyRenderingTask = null;
        var firstWorkInProgressHook = null;
        var workInProgressHook = null;
        var isReRender = false;
        var didScheduleRenderPhaseUpdate = false;
        var localIdCounter = 0;
        var renderPhaseUpdates = null;
        var numberOfReRenders = 0;
        var RE_RENDER_LIMIT = 25;
        var isInHookUserCodeInDev = false;
        var currentHookNameInDev;
        function resolveCurrentlyRenderingComponent() {
          if (currentlyRenderingComponent === null) {
            throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
          }
          {
            if (isInHookUserCodeInDev) {
              error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
            }
          }
          return currentlyRenderingComponent;
        }
        function areHookInputsEqual(nextDeps, prevDeps) {
          if (prevDeps === null) {
            {
              error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
            }
            return false;
          }
          {
            if (nextDeps.length !== prevDeps.length) {
              error("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + nextDeps.join(", ") + "]", "[" + prevDeps.join(", ") + "]");
            }
          }
          for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
            if (objectIs(nextDeps[i], prevDeps[i])) {
              continue;
            }
            return false;
          }
          return true;
        }
        function createHook() {
          if (numberOfReRenders > 0) {
            throw new Error("Rendered more hooks than during the previous render");
          }
          return {
            memoizedState: null,
            queue: null,
            next: null
          };
        }
        function createWorkInProgressHook() {
          if (workInProgressHook === null) {
            if (firstWorkInProgressHook === null) {
              isReRender = false;
              firstWorkInProgressHook = workInProgressHook = createHook();
            } else {
              isReRender = true;
              workInProgressHook = firstWorkInProgressHook;
            }
          } else {
            if (workInProgressHook.next === null) {
              isReRender = false;
              workInProgressHook = workInProgressHook.next = createHook();
            } else {
              isReRender = true;
              workInProgressHook = workInProgressHook.next;
            }
          }
          return workInProgressHook;
        }
        function prepareToUseHooks(task, componentIdentity) {
          currentlyRenderingComponent = componentIdentity;
          currentlyRenderingTask = task;
          {
            isInHookUserCodeInDev = false;
          }
          localIdCounter = 0;
        }
        function finishHooks(Component, props, children, refOrContext) {
          while (didScheduleRenderPhaseUpdate) {
            didScheduleRenderPhaseUpdate = false;
            localIdCounter = 0;
            numberOfReRenders += 1;
            workInProgressHook = null;
            children = Component(props, refOrContext);
          }
          resetHooksState();
          return children;
        }
        function checkDidRenderIdHook() {
          var didRenderIdHook = localIdCounter !== 0;
          return didRenderIdHook;
        }
        function resetHooksState() {
          {
            isInHookUserCodeInDev = false;
          }
          currentlyRenderingComponent = null;
          currentlyRenderingTask = null;
          didScheduleRenderPhaseUpdate = false;
          firstWorkInProgressHook = null;
          numberOfReRenders = 0;
          renderPhaseUpdates = null;
          workInProgressHook = null;
        }
        function readContext$1(context) {
          {
            if (isInHookUserCodeInDev) {
              error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
            }
          }
          return readContext(context);
        }
        function useContext(context) {
          {
            currentHookNameInDev = "useContext";
          }
          resolveCurrentlyRenderingComponent();
          return readContext(context);
        }
        function basicStateReducer(state, action) {
          return typeof action === "function" ? action(state) : action;
        }
        function useState(initialState) {
          {
            currentHookNameInDev = "useState";
          }
          return useReducer(
            basicStateReducer,
            // useReducer has a special case to support lazy useState initializers
            initialState
          );
        }
        function useReducer(reducer, initialArg, init) {
          {
            if (reducer !== basicStateReducer) {
              currentHookNameInDev = "useReducer";
            }
          }
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          if (isReRender) {
            var queue = workInProgressHook.queue;
            var dispatch = queue.dispatch;
            if (renderPhaseUpdates !== null) {
              var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
              if (firstRenderPhaseUpdate !== void 0) {
                renderPhaseUpdates.delete(queue);
                var newState = workInProgressHook.memoizedState;
                var update = firstRenderPhaseUpdate;
                do {
                  var action = update.action;
                  {
                    isInHookUserCodeInDev = true;
                  }
                  newState = reducer(newState, action);
                  {
                    isInHookUserCodeInDev = false;
                  }
                  update = update.next;
                } while (update !== null);
                workInProgressHook.memoizedState = newState;
                return [newState, dispatch];
              }
            }
            return [workInProgressHook.memoizedState, dispatch];
          } else {
            {
              isInHookUserCodeInDev = true;
            }
            var initialState;
            if (reducer === basicStateReducer) {
              initialState = typeof initialArg === "function" ? initialArg() : initialArg;
            } else {
              initialState = init !== void 0 ? init(initialArg) : initialArg;
            }
            {
              isInHookUserCodeInDev = false;
            }
            workInProgressHook.memoizedState = initialState;
            var _queue = workInProgressHook.queue = {
              last: null,
              dispatch: null
            };
            var _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue);
            return [workInProgressHook.memoizedState, _dispatch];
          }
        }
        function useMemo(nextCreate, deps) {
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          if (workInProgressHook !== null) {
            var prevState = workInProgressHook.memoizedState;
            if (prevState !== null) {
              if (nextDeps !== null) {
                var prevDeps = prevState[1];
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  return prevState[0];
                }
              }
            }
          }
          {
            isInHookUserCodeInDev = true;
          }
          var nextValue = nextCreate();
          {
            isInHookUserCodeInDev = false;
          }
          workInProgressHook.memoizedState = [nextValue, nextDeps];
          return nextValue;
        }
        function useRef(initialValue) {
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          var previousRef = workInProgressHook.memoizedState;
          if (previousRef === null) {
            var ref = {
              current: initialValue
            };
            {
              Object.seal(ref);
            }
            workInProgressHook.memoizedState = ref;
            return ref;
          } else {
            return previousRef;
          }
        }
        function useLayoutEffect(create, inputs) {
          {
            currentHookNameInDev = "useLayoutEffect";
            error("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
          }
        }
        function dispatchAction(componentIdentity, queue, action) {
          if (numberOfReRenders >= RE_RENDER_LIMIT) {
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          }
          if (componentIdentity === currentlyRenderingComponent) {
            didScheduleRenderPhaseUpdate = true;
            var update = {
              action,
              next: null
            };
            if (renderPhaseUpdates === null) {
              renderPhaseUpdates = /* @__PURE__ */ new Map();
            }
            var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
            if (firstRenderPhaseUpdate === void 0) {
              renderPhaseUpdates.set(queue, update);
            } else {
              var lastRenderPhaseUpdate = firstRenderPhaseUpdate;
              while (lastRenderPhaseUpdate.next !== null) {
                lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
              }
              lastRenderPhaseUpdate.next = update;
            }
          }
        }
        function useCallback(callback, deps) {
          return useMemo(function() {
            return callback;
          }, deps);
        }
        function useMutableSource(source, getSnapshot, subscribe) {
          resolveCurrentlyRenderingComponent();
          return getSnapshot(source._source);
        }
        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          if (getServerSnapshot === void 0) {
            throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
          }
          return getServerSnapshot();
        }
        function useDeferredValue(value) {
          resolveCurrentlyRenderingComponent();
          return value;
        }
        function unsupportedStartTransition() {
          throw new Error("startTransition cannot be called during server rendering.");
        }
        function useTransition() {
          resolveCurrentlyRenderingComponent();
          return [false, unsupportedStartTransition];
        }
        function useId() {
          var task = currentlyRenderingTask;
          var treeId = getTreeId(task.treeContext);
          var responseState = currentResponseState;
          if (responseState === null) {
            throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
          }
          var localId = localIdCounter++;
          return makeId(responseState, treeId, localId);
        }
        function noop() {
        }
        var Dispatcher = {
          readContext: readContext$1,
          useContext,
          useMemo,
          useReducer,
          useRef,
          useState,
          useInsertionEffect: noop,
          useLayoutEffect,
          useCallback,
          // useImperativeHandle is not run in the server environment
          useImperativeHandle: noop,
          // Effects are not run in the server environment.
          useEffect: noop,
          // Debugging effect
          useDebugValue: noop,
          useDeferredValue,
          useTransition,
          useId,
          // Subscriptions are not setup in a server environment.
          useMutableSource,
          useSyncExternalStore
        };
        var currentResponseState = null;
        function setCurrentResponseState(responseState) {
          currentResponseState = responseState;
        }
        function getStackByComponentStackNode(componentStack) {
          try {
            var info = "";
            var node = componentStack;
            do {
              switch (node.tag) {
                case 0:
                  info += describeBuiltInComponentFrame(node.type, null, null);
                  break;
                case 1:
                  info += describeFunctionComponentFrame(node.type, null, null);
                  break;
                case 2:
                  info += describeClassComponentFrame(node.type, null, null);
                  break;
              }
              node = node.parent;
            } while (node);
            return info;
          } catch (x) {
            return "\nError generating stack: " + x.message + "\n" + x.stack;
          }
        }
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        var PENDING = 0;
        var COMPLETED = 1;
        var FLUSHED = 2;
        var ABORTED = 3;
        var ERRORED = 4;
        var OPEN = 0;
        var CLOSING = 1;
        var CLOSED = 2;
        var DEFAULT_PROGRESSIVE_CHUNK_SIZE = 12800;
        function defaultErrorHandler(error2) {
          console["error"](error2);
          return null;
        }
        function noop$1() {
        }
        function createRequest(children, responseState, rootFormatContext, progressiveChunkSize, onError2, onAllReady, onShellReady, onShellError, onFatalError) {
          var pingedTasks = [];
          var abortSet = /* @__PURE__ */ new Set();
          var request = {
            destination: null,
            responseState,
            progressiveChunkSize: progressiveChunkSize === void 0 ? DEFAULT_PROGRESSIVE_CHUNK_SIZE : progressiveChunkSize,
            status: OPEN,
            fatalError: null,
            nextSegmentId: 0,
            allPendingTasks: 0,
            pendingRootTasks: 0,
            completedRootSegment: null,
            abortableTasks: abortSet,
            pingedTasks,
            clientRenderedBoundaries: [],
            completedBoundaries: [],
            partialBoundaries: [],
            onError: onError2 === void 0 ? defaultErrorHandler : onError2,
            onAllReady: onAllReady === void 0 ? noop$1 : onAllReady,
            onShellReady: onShellReady === void 0 ? noop$1 : onShellReady,
            onShellError: onShellError === void 0 ? noop$1 : onShellError,
            onFatalError: onFatalError === void 0 ? noop$1 : onFatalError
          };
          var rootSegment = createPendingSegment(
            request,
            0,
            null,
            rootFormatContext,
            // Root segments are never embedded in Text on either edge
            false,
            false
          );
          rootSegment.parentFlushed = true;
          var rootTask = createTask(request, children, null, rootSegment, abortSet, emptyContextObject, rootContextSnapshot, emptyTreeContext);
          pingedTasks.push(rootTask);
          return request;
        }
        function pingTask(request, task) {
          var pingedTasks = request.pingedTasks;
          pingedTasks.push(task);
          if (pingedTasks.length === 1) {
            scheduleWork(function() {
              return performWork(request);
            });
          }
        }
        function createSuspenseBoundary(request, fallbackAbortableTasks) {
          return {
            id: UNINITIALIZED_SUSPENSE_BOUNDARY_ID,
            rootSegmentID: -1,
            parentFlushed: false,
            pendingTasks: 0,
            forceClientRender: false,
            completedSegments: [],
            byteSize: 0,
            fallbackAbortableTasks,
            errorDigest: null
          };
        }
        function createTask(request, node, blockedBoundary, blockedSegment, abortSet, legacyContext, context, treeContext) {
          request.allPendingTasks++;
          if (blockedBoundary === null) {
            request.pendingRootTasks++;
          } else {
            blockedBoundary.pendingTasks++;
          }
          var task = {
            node,
            ping: function() {
              return pingTask(request, task);
            },
            blockedBoundary,
            blockedSegment,
            abortSet,
            legacyContext,
            context,
            treeContext
          };
          {
            task.componentStack = null;
          }
          abortSet.add(task);
          return task;
        }
        function createPendingSegment(request, index, boundary, formatContext, lastPushedText, textEmbedded) {
          return {
            status: PENDING,
            id: -1,
            // lazily assigned later
            index,
            parentFlushed: false,
            chunks: [],
            children: [],
            formatContext,
            boundary,
            lastPushedText,
            textEmbedded
          };
        }
        var currentTaskInDEV = null;
        function getCurrentStackInDEV() {
          {
            if (currentTaskInDEV === null || currentTaskInDEV.componentStack === null) {
              return "";
            }
            return getStackByComponentStackNode(currentTaskInDEV.componentStack);
          }
        }
        function pushBuiltInComponentStackInDEV(task, type) {
          {
            task.componentStack = {
              tag: 0,
              parent: task.componentStack,
              type
            };
          }
        }
        function pushFunctionComponentStackInDEV(task, type) {
          {
            task.componentStack = {
              tag: 1,
              parent: task.componentStack,
              type
            };
          }
        }
        function pushClassComponentStackInDEV(task, type) {
          {
            task.componentStack = {
              tag: 2,
              parent: task.componentStack,
              type
            };
          }
        }
        function popComponentStackInDEV(task) {
          {
            if (task.componentStack === null) {
              error("Unexpectedly popped too many stack frames. This is a bug in React.");
            } else {
              task.componentStack = task.componentStack.parent;
            }
          }
        }
        var lastBoundaryErrorComponentStackDev = null;
        function captureBoundaryErrorDetailsDev(boundary, error2) {
          {
            var errorMessage;
            if (typeof error2 === "string") {
              errorMessage = error2;
            } else if (error2 && typeof error2.message === "string") {
              errorMessage = error2.message;
            } else {
              errorMessage = String(error2);
            }
            var errorComponentStack = lastBoundaryErrorComponentStackDev || getCurrentStackInDEV();
            lastBoundaryErrorComponentStackDev = null;
            boundary.errorMessage = errorMessage;
            boundary.errorComponentStack = errorComponentStack;
          }
        }
        function logRecoverableError(request, error2) {
          var errorDigest = request.onError(error2);
          if (errorDigest != null && typeof errorDigest !== "string") {
            throw new Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof errorDigest + '" instead');
          }
          return errorDigest;
        }
        function fatalError(request, error2) {
          var onShellError = request.onShellError;
          onShellError(error2);
          var onFatalError = request.onFatalError;
          onFatalError(error2);
          if (request.destination !== null) {
            request.status = CLOSED;
            closeWithError(request.destination, error2);
          } else {
            request.status = CLOSING;
            request.fatalError = error2;
          }
        }
        function renderSuspenseBoundary(request, task, props) {
          pushBuiltInComponentStackInDEV(task, "Suspense");
          var parentBoundary = task.blockedBoundary;
          var parentSegment = task.blockedSegment;
          var fallback = props.fallback;
          var content = props.children;
          var fallbackAbortSet = /* @__PURE__ */ new Set();
          var newBoundary = createSuspenseBoundary(request, fallbackAbortSet);
          var insertionIndex = parentSegment.chunks.length;
          var boundarySegment = createPendingSegment(
            request,
            insertionIndex,
            newBoundary,
            parentSegment.formatContext,
            // boundaries never require text embedding at their edges because comment nodes bound them
            false,
            false
          );
          parentSegment.children.push(boundarySegment);
          parentSegment.lastPushedText = false;
          var contentRootSegment = createPendingSegment(
            request,
            0,
            null,
            parentSegment.formatContext,
            // boundaries never require text embedding at their edges because comment nodes bound them
            false,
            false
          );
          contentRootSegment.parentFlushed = true;
          task.blockedBoundary = newBoundary;
          task.blockedSegment = contentRootSegment;
          try {
            renderNode(request, task, content);
            pushSegmentFinale$1(contentRootSegment.chunks, request.responseState, contentRootSegment.lastPushedText, contentRootSegment.textEmbedded);
            contentRootSegment.status = COMPLETED;
            queueCompletedSegment(newBoundary, contentRootSegment);
            if (newBoundary.pendingTasks === 0) {
              popComponentStackInDEV(task);
              return;
            }
          } catch (error2) {
            contentRootSegment.status = ERRORED;
            newBoundary.forceClientRender = true;
            newBoundary.errorDigest = logRecoverableError(request, error2);
            {
              captureBoundaryErrorDetailsDev(newBoundary, error2);
            }
          } finally {
            task.blockedBoundary = parentBoundary;
            task.blockedSegment = parentSegment;
          }
          var suspendedFallbackTask = createTask(request, fallback, parentBoundary, boundarySegment, fallbackAbortSet, task.legacyContext, task.context, task.treeContext);
          {
            suspendedFallbackTask.componentStack = task.componentStack;
          }
          request.pingedTasks.push(suspendedFallbackTask);
          popComponentStackInDEV(task);
        }
        function renderHostElement(request, task, type, props) {
          pushBuiltInComponentStackInDEV(task, type);
          var segment = task.blockedSegment;
          var children = pushStartInstance(segment.chunks, type, props, request.responseState, segment.formatContext);
          segment.lastPushedText = false;
          var prevContext = segment.formatContext;
          segment.formatContext = getChildFormatContext(prevContext, type, props);
          renderNode(request, task, children);
          segment.formatContext = prevContext;
          pushEndInstance(segment.chunks, type);
          segment.lastPushedText = false;
          popComponentStackInDEV(task);
        }
        function shouldConstruct$1(Component) {
          return Component.prototype && Component.prototype.isReactComponent;
        }
        function renderWithHooks(request, task, Component, props, secondArg) {
          var componentIdentity = {};
          prepareToUseHooks(task, componentIdentity);
          var result = Component(props, secondArg);
          return finishHooks(Component, props, result, secondArg);
        }
        function finishClassComponent(request, task, instance, Component, props) {
          var nextChildren = instance.render();
          {
            if (instance.props !== props) {
              if (!didWarnAboutReassigningProps) {
                error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromType(Component) || "a component");
              }
              didWarnAboutReassigningProps = true;
            }
          }
          {
            var childContextTypes = Component.childContextTypes;
            if (childContextTypes !== null && childContextTypes !== void 0) {
              var previousContext = task.legacyContext;
              var mergedContext = processChildContext(instance, Component, previousContext, childContextTypes);
              task.legacyContext = mergedContext;
              renderNodeDestructive(request, task, nextChildren);
              task.legacyContext = previousContext;
              return;
            }
          }
          renderNodeDestructive(request, task, nextChildren);
        }
        function renderClassComponent(request, task, Component, props) {
          pushClassComponentStackInDEV(task, Component);
          var maskedContext = getMaskedContext(Component, task.legacyContext);
          var instance = constructClassInstance(Component, props, maskedContext);
          mountClassInstance(instance, Component, props, maskedContext);
          finishClassComponent(request, task, instance, Component, props);
          popComponentStackInDEV(task);
        }
        var didWarnAboutBadClass = {};
        var didWarnAboutModulePatternComponent = {};
        var didWarnAboutContextTypeOnFunctionComponent = {};
        var didWarnAboutGetDerivedStateOnFunctionComponent = {};
        var didWarnAboutReassigningProps = false;
        var didWarnAboutGenerators = false;
        var didWarnAboutMaps = false;
        var hasWarnedAboutUsingContextAsConsumer = false;
        function renderIndeterminateComponent(request, task, Component, props) {
          var legacyContext;
          {
            legacyContext = getMaskedContext(Component, task.legacyContext);
          }
          pushFunctionComponentStackInDEV(task, Component);
          {
            if (Component.prototype && typeof Component.prototype.render === "function") {
              var componentName = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutBadClass[componentName]) {
                error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
                didWarnAboutBadClass[componentName] = true;
              }
            }
          }
          var value = renderWithHooks(request, task, Component, props, legacyContext);
          var hasId = checkDidRenderIdHook();
          {
            if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0) {
              var _componentName = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutModulePatternComponent[_componentName]) {
                error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
                didWarnAboutModulePatternComponent[_componentName] = true;
              }
            }
          }
          if (
            // Run these checks in production only if the flag is off.
            // Eventually we'll delete this branch altogether.
            typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0
          ) {
            {
              var _componentName2 = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutModulePatternComponent[_componentName2]) {
                error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
                didWarnAboutModulePatternComponent[_componentName2] = true;
              }
            }
            mountClassInstance(value, Component, props, legacyContext);
            finishClassComponent(request, task, value, Component, props);
          } else {
            {
              validateFunctionComponentInDev(Component);
            }
            if (hasId) {
              var prevTreeContext = task.treeContext;
              var totalChildren = 1;
              var index = 0;
              task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);
              try {
                renderNodeDestructive(request, task, value);
              } finally {
                task.treeContext = prevTreeContext;
              }
            } else {
              renderNodeDestructive(request, task, value);
            }
          }
          popComponentStackInDEV(task);
        }
        function validateFunctionComponentInDev(Component) {
          {
            if (Component) {
              if (Component.childContextTypes) {
                error("%s(...): childContextTypes cannot be defined on a function component.", Component.displayName || Component.name || "Component");
              }
            }
            if (typeof Component.getDerivedStateFromProps === "function") {
              var _componentName3 = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
                error("%s: Function components do not support getDerivedStateFromProps.", _componentName3);
                didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
              }
            }
            if (typeof Component.contextType === "object" && Component.contextType !== null) {
              var _componentName4 = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
                error("%s: Function components do not support contextType.", _componentName4);
                didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
              }
            }
          }
        }
        function resolveDefaultProps(Component, baseProps) {
          if (Component && Component.defaultProps) {
            var props = assign({}, baseProps);
            var defaultProps = Component.defaultProps;
            for (var propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
            return props;
          }
          return baseProps;
        }
        function renderForwardRef(request, task, type, props, ref) {
          pushFunctionComponentStackInDEV(task, type.render);
          var children = renderWithHooks(request, task, type.render, props, ref);
          var hasId = checkDidRenderIdHook();
          if (hasId) {
            var prevTreeContext = task.treeContext;
            var totalChildren = 1;
            var index = 0;
            task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);
            try {
              renderNodeDestructive(request, task, children);
            } finally {
              task.treeContext = prevTreeContext;
            }
          } else {
            renderNodeDestructive(request, task, children);
          }
          popComponentStackInDEV(task);
        }
        function renderMemo(request, task, type, props, ref) {
          var innerType = type.type;
          var resolvedProps = resolveDefaultProps(innerType, props);
          renderElement(request, task, innerType, resolvedProps, ref);
        }
        function renderContextConsumer(request, task, context, props) {
          {
            if (context._context === void 0) {
              if (context !== context.Consumer) {
                if (!hasWarnedAboutUsingContextAsConsumer) {
                  hasWarnedAboutUsingContextAsConsumer = true;
                  error("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                }
              }
            } else {
              context = context._context;
            }
          }
          var render = props.children;
          {
            if (typeof render !== "function") {
              error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
            }
          }
          var newValue = readContext(context);
          var newChildren = render(newValue);
          renderNodeDestructive(request, task, newChildren);
        }
        function renderContextProvider(request, task, type, props) {
          var context = type._context;
          var value = props.value;
          var children = props.children;
          var prevSnapshot;
          {
            prevSnapshot = task.context;
          }
          task.context = pushProvider(context, value);
          renderNodeDestructive(request, task, children);
          task.context = popProvider(context);
          {
            if (prevSnapshot !== task.context) {
              error("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
            }
          }
        }
        function renderLazyComponent(request, task, lazyComponent, props, ref) {
          pushBuiltInComponentStackInDEV(task, "Lazy");
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;
          var Component = init(payload);
          var resolvedProps = resolveDefaultProps(Component, props);
          renderElement(request, task, Component, resolvedProps, ref);
          popComponentStackInDEV(task);
        }
        function renderElement(request, task, type, props, ref) {
          if (typeof type === "function") {
            if (shouldConstruct$1(type)) {
              renderClassComponent(request, task, type, props);
              return;
            } else {
              renderIndeterminateComponent(request, task, type, props);
              return;
            }
          }
          if (typeof type === "string") {
            renderHostElement(request, task, type, props);
            return;
          }
          switch (type) {
            case REACT_LEGACY_HIDDEN_TYPE:
            case REACT_DEBUG_TRACING_MODE_TYPE:
            case REACT_STRICT_MODE_TYPE:
            case REACT_PROFILER_TYPE:
            case REACT_FRAGMENT_TYPE: {
              renderNodeDestructive(request, task, props.children);
              return;
            }
            case REACT_SUSPENSE_LIST_TYPE: {
              pushBuiltInComponentStackInDEV(task, "SuspenseList");
              renderNodeDestructive(request, task, props.children);
              popComponentStackInDEV(task);
              return;
            }
            case REACT_SCOPE_TYPE: {
              throw new Error("ReactDOMServer does not yet support scope components.");
            }
            case REACT_SUSPENSE_TYPE: {
              {
                renderSuspenseBoundary(request, task, props);
              }
              return;
            }
          }
          if (typeof type === "object" && type !== null) {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE: {
                renderForwardRef(request, task, type, props, ref);
                return;
              }
              case REACT_MEMO_TYPE: {
                renderMemo(request, task, type, props, ref);
                return;
              }
              case REACT_PROVIDER_TYPE: {
                renderContextProvider(request, task, type, props);
                return;
              }
              case REACT_CONTEXT_TYPE: {
                renderContextConsumer(request, task, type, props);
                return;
              }
              case REACT_LAZY_TYPE: {
                renderLazyComponent(request, task, type, props);
                return;
              }
            }
          }
          var info = "";
          {
            if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
          }
          throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (type == null ? type : typeof type) + "." + info));
        }
        function validateIterable(iterable, iteratorFn) {
          {
            if (typeof Symbol === "function" && // $FlowFixMe Flow doesn't know about toStringTag
            iterable[Symbol.toStringTag] === "Generator") {
              if (!didWarnAboutGenerators) {
                error("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
              }
              didWarnAboutGenerators = true;
            }
            if (iterable.entries === iteratorFn) {
              if (!didWarnAboutMaps) {
                error("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
              }
              didWarnAboutMaps = true;
            }
          }
        }
        function renderNodeDestructive(request, task, node) {
          {
            try {
              return renderNodeDestructiveImpl(request, task, node);
            } catch (x) {
              if (typeof x === "object" && x !== null && typeof x.then === "function")
                ;
              else {
                lastBoundaryErrorComponentStackDev = lastBoundaryErrorComponentStackDev !== null ? lastBoundaryErrorComponentStackDev : getCurrentStackInDEV();
              }
              throw x;
            }
          }
        }
        function renderNodeDestructiveImpl(request, task, node) {
          task.node = node;
          if (typeof node === "object" && node !== null) {
            switch (node.$$typeof) {
              case REACT_ELEMENT_TYPE: {
                var element = node;
                var type = element.type;
                var props = element.props;
                var ref = element.ref;
                renderElement(request, task, type, props, ref);
                return;
              }
              case REACT_PORTAL_TYPE:
                throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
              case REACT_LAZY_TYPE: {
                var lazyNode = node;
                var payload = lazyNode._payload;
                var init = lazyNode._init;
                var resolvedNode;
                {
                  try {
                    resolvedNode = init(payload);
                  } catch (x) {
                    if (typeof x === "object" && x !== null && typeof x.then === "function") {
                      pushBuiltInComponentStackInDEV(task, "Lazy");
                    }
                    throw x;
                  }
                }
                renderNodeDestructive(request, task, resolvedNode);
                return;
              }
            }
            if (isArray(node)) {
              renderChildrenArray(request, task, node);
              return;
            }
            var iteratorFn = getIteratorFn(node);
            if (iteratorFn) {
              {
                validateIterable(node, iteratorFn);
              }
              var iterator = iteratorFn.call(node);
              if (iterator) {
                var step = iterator.next();
                if (!step.done) {
                  var children = [];
                  do {
                    children.push(step.value);
                    step = iterator.next();
                  } while (!step.done);
                  renderChildrenArray(request, task, children);
                  return;
                }
                return;
              }
            }
            var childString = Object.prototype.toString.call(node);
            throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(node).join(", ") + "}" : childString) + "). If you meant to render a collection of children, use an array instead.");
          }
          if (typeof node === "string") {
            var segment = task.blockedSegment;
            segment.lastPushedText = pushTextInstance$1(task.blockedSegment.chunks, node, request.responseState, segment.lastPushedText);
            return;
          }
          if (typeof node === "number") {
            var _segment = task.blockedSegment;
            _segment.lastPushedText = pushTextInstance$1(task.blockedSegment.chunks, "" + node, request.responseState, _segment.lastPushedText);
            return;
          }
          {
            if (typeof node === "function") {
              error("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
            }
          }
        }
        function renderChildrenArray(request, task, children) {
          var totalChildren = children.length;
          for (var i = 0; i < totalChildren; i++) {
            var prevTreeContext = task.treeContext;
            task.treeContext = pushTreeContext(prevTreeContext, totalChildren, i);
            try {
              renderNode(request, task, children[i]);
            } finally {
              task.treeContext = prevTreeContext;
            }
          }
        }
        function spawnNewSuspendedTask(request, task, x) {
          var segment = task.blockedSegment;
          var insertionIndex = segment.chunks.length;
          var newSegment = createPendingSegment(
            request,
            insertionIndex,
            null,
            segment.formatContext,
            // Adopt the parent segment's leading text embed
            segment.lastPushedText,
            // Assume we are text embedded at the trailing edge
            true
          );
          segment.children.push(newSegment);
          segment.lastPushedText = false;
          var newTask = createTask(request, task.node, task.blockedBoundary, newSegment, task.abortSet, task.legacyContext, task.context, task.treeContext);
          {
            if (task.componentStack !== null) {
              newTask.componentStack = task.componentStack.parent;
            }
          }
          var ping = newTask.ping;
          x.then(ping, ping);
        }
        function renderNode(request, task, node) {
          var previousFormatContext = task.blockedSegment.formatContext;
          var previousLegacyContext = task.legacyContext;
          var previousContext = task.context;
          var previousComponentStack = null;
          {
            previousComponentStack = task.componentStack;
          }
          try {
            return renderNodeDestructive(request, task, node);
          } catch (x) {
            resetHooksState();
            if (typeof x === "object" && x !== null && typeof x.then === "function") {
              spawnNewSuspendedTask(request, task, x);
              task.blockedSegment.formatContext = previousFormatContext;
              task.legacyContext = previousLegacyContext;
              task.context = previousContext;
              switchContext(previousContext);
              {
                task.componentStack = previousComponentStack;
              }
              return;
            } else {
              task.blockedSegment.formatContext = previousFormatContext;
              task.legacyContext = previousLegacyContext;
              task.context = previousContext;
              switchContext(previousContext);
              {
                task.componentStack = previousComponentStack;
              }
              throw x;
            }
          }
        }
        function erroredTask(request, boundary, segment, error2) {
          var errorDigest = logRecoverableError(request, error2);
          if (boundary === null) {
            fatalError(request, error2);
          } else {
            boundary.pendingTasks--;
            if (!boundary.forceClientRender) {
              boundary.forceClientRender = true;
              boundary.errorDigest = errorDigest;
              {
                captureBoundaryErrorDetailsDev(boundary, error2);
              }
              if (boundary.parentFlushed) {
                request.clientRenderedBoundaries.push(boundary);
              }
            }
          }
          request.allPendingTasks--;
          if (request.allPendingTasks === 0) {
            var onAllReady = request.onAllReady;
            onAllReady();
          }
        }
        function abortTaskSoft(task) {
          var request = this;
          var boundary = task.blockedBoundary;
          var segment = task.blockedSegment;
          segment.status = ABORTED;
          finishedTask(request, boundary, segment);
        }
        function abortTask(task, request, reason) {
          var boundary = task.blockedBoundary;
          var segment = task.blockedSegment;
          segment.status = ABORTED;
          if (boundary === null) {
            request.allPendingTasks--;
            if (request.status !== CLOSED) {
              request.status = CLOSED;
              if (request.destination !== null) {
                close(request.destination);
              }
            }
          } else {
            boundary.pendingTasks--;
            if (!boundary.forceClientRender) {
              boundary.forceClientRender = true;
              var _error = reason === void 0 ? new Error("The render was aborted by the server without a reason.") : reason;
              boundary.errorDigest = request.onError(_error);
              {
                var errorPrefix = "The server did not finish this Suspense boundary: ";
                if (_error && typeof _error.message === "string") {
                  _error = errorPrefix + _error.message;
                } else {
                  _error = errorPrefix + String(_error);
                }
                var previousTaskInDev = currentTaskInDEV;
                currentTaskInDEV = task;
                try {
                  captureBoundaryErrorDetailsDev(boundary, _error);
                } finally {
                  currentTaskInDEV = previousTaskInDev;
                }
              }
              if (boundary.parentFlushed) {
                request.clientRenderedBoundaries.push(boundary);
              }
            }
            boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
              return abortTask(fallbackTask, request, reason);
            });
            boundary.fallbackAbortableTasks.clear();
            request.allPendingTasks--;
            if (request.allPendingTasks === 0) {
              var onAllReady = request.onAllReady;
              onAllReady();
            }
          }
        }
        function queueCompletedSegment(boundary, segment) {
          if (segment.chunks.length === 0 && segment.children.length === 1 && segment.children[0].boundary === null) {
            var childSegment = segment.children[0];
            childSegment.id = segment.id;
            childSegment.parentFlushed = true;
            if (childSegment.status === COMPLETED) {
              queueCompletedSegment(boundary, childSegment);
            }
          } else {
            var completedSegments = boundary.completedSegments;
            completedSegments.push(segment);
          }
        }
        function finishedTask(request, boundary, segment) {
          if (boundary === null) {
            if (segment.parentFlushed) {
              if (request.completedRootSegment !== null) {
                throw new Error("There can only be one root segment. This is a bug in React.");
              }
              request.completedRootSegment = segment;
            }
            request.pendingRootTasks--;
            if (request.pendingRootTasks === 0) {
              request.onShellError = noop$1;
              var onShellReady = request.onShellReady;
              onShellReady();
            }
          } else {
            boundary.pendingTasks--;
            if (boundary.forceClientRender)
              ;
            else if (boundary.pendingTasks === 0) {
              if (segment.parentFlushed) {
                if (segment.status === COMPLETED) {
                  queueCompletedSegment(boundary, segment);
                }
              }
              if (boundary.parentFlushed) {
                request.completedBoundaries.push(boundary);
              }
              boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request);
              boundary.fallbackAbortableTasks.clear();
            } else {
              if (segment.parentFlushed) {
                if (segment.status === COMPLETED) {
                  queueCompletedSegment(boundary, segment);
                  var completedSegments = boundary.completedSegments;
                  if (completedSegments.length === 1) {
                    if (boundary.parentFlushed) {
                      request.partialBoundaries.push(boundary);
                    }
                  }
                }
              }
            }
          }
          request.allPendingTasks--;
          if (request.allPendingTasks === 0) {
            var onAllReady = request.onAllReady;
            onAllReady();
          }
        }
        function retryTask(request, task) {
          var segment = task.blockedSegment;
          if (segment.status !== PENDING) {
            return;
          }
          switchContext(task.context);
          var prevTaskInDEV = null;
          {
            prevTaskInDEV = currentTaskInDEV;
            currentTaskInDEV = task;
          }
          try {
            renderNodeDestructive(request, task, task.node);
            pushSegmentFinale$1(segment.chunks, request.responseState, segment.lastPushedText, segment.textEmbedded);
            task.abortSet.delete(task);
            segment.status = COMPLETED;
            finishedTask(request, task.blockedBoundary, segment);
          } catch (x) {
            resetHooksState();
            if (typeof x === "object" && x !== null && typeof x.then === "function") {
              var ping = task.ping;
              x.then(ping, ping);
            } else {
              task.abortSet.delete(task);
              segment.status = ERRORED;
              erroredTask(request, task.blockedBoundary, segment, x);
            }
          } finally {
            {
              currentTaskInDEV = prevTaskInDEV;
            }
          }
        }
        function performWork(request) {
          if (request.status === CLOSED) {
            return;
          }
          var prevContext = getActiveContext();
          var prevDispatcher = ReactCurrentDispatcher$1.current;
          ReactCurrentDispatcher$1.current = Dispatcher;
          var prevGetCurrentStackImpl;
          {
            prevGetCurrentStackImpl = ReactDebugCurrentFrame$1.getCurrentStack;
            ReactDebugCurrentFrame$1.getCurrentStack = getCurrentStackInDEV;
          }
          var prevResponseState = currentResponseState;
          setCurrentResponseState(request.responseState);
          try {
            var pingedTasks = request.pingedTasks;
            var i;
            for (i = 0; i < pingedTasks.length; i++) {
              var task = pingedTasks[i];
              retryTask(request, task);
            }
            pingedTasks.splice(0, i);
            if (request.destination !== null) {
              flushCompletedQueues(request, request.destination);
            }
          } catch (error2) {
            logRecoverableError(request, error2);
            fatalError(request, error2);
          } finally {
            setCurrentResponseState(prevResponseState);
            ReactCurrentDispatcher$1.current = prevDispatcher;
            {
              ReactDebugCurrentFrame$1.getCurrentStack = prevGetCurrentStackImpl;
            }
            if (prevDispatcher === Dispatcher) {
              switchContext(prevContext);
            }
          }
        }
        function flushSubtree(request, destination, segment) {
          segment.parentFlushed = true;
          switch (segment.status) {
            case PENDING: {
              var segmentID = segment.id = request.nextSegmentId++;
              segment.lastPushedText = false;
              segment.textEmbedded = false;
              return writePlaceholder(destination, request.responseState, segmentID);
            }
            case COMPLETED: {
              segment.status = FLUSHED;
              var r = true;
              var chunks = segment.chunks;
              var chunkIdx = 0;
              var children = segment.children;
              for (var childIdx = 0; childIdx < children.length; childIdx++) {
                var nextChild = children[childIdx];
                for (; chunkIdx < nextChild.index; chunkIdx++) {
                  writeChunk(destination, chunks[chunkIdx]);
                }
                r = flushSegment(request, destination, nextChild);
              }
              for (; chunkIdx < chunks.length - 1; chunkIdx++) {
                writeChunk(destination, chunks[chunkIdx]);
              }
              if (chunkIdx < chunks.length) {
                r = writeChunkAndReturn(destination, chunks[chunkIdx]);
              }
              return r;
            }
            default: {
              throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
            }
          }
        }
        function flushSegment(request, destination, segment) {
          var boundary = segment.boundary;
          if (boundary === null) {
            return flushSubtree(request, destination, segment);
          }
          boundary.parentFlushed = true;
          if (boundary.forceClientRender) {
            writeStartClientRenderedSuspenseBoundary$1(destination, request.responseState, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
            flushSubtree(request, destination, segment);
            return writeEndClientRenderedSuspenseBoundary$1(destination, request.responseState);
          } else if (boundary.pendingTasks > 0) {
            boundary.rootSegmentID = request.nextSegmentId++;
            if (boundary.completedSegments.length > 0) {
              request.partialBoundaries.push(boundary);
            }
            var id = boundary.id = assignSuspenseBoundaryID(request.responseState);
            writeStartPendingSuspenseBoundary(destination, request.responseState, id);
            flushSubtree(request, destination, segment);
            return writeEndPendingSuspenseBoundary(destination, request.responseState);
          } else if (boundary.byteSize > request.progressiveChunkSize) {
            boundary.rootSegmentID = request.nextSegmentId++;
            request.completedBoundaries.push(boundary);
            writeStartPendingSuspenseBoundary(destination, request.responseState, boundary.id);
            flushSubtree(request, destination, segment);
            return writeEndPendingSuspenseBoundary(destination, request.responseState);
          } else {
            writeStartCompletedSuspenseBoundary$1(destination, request.responseState);
            var completedSegments = boundary.completedSegments;
            if (completedSegments.length !== 1) {
              throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
            }
            var contentSegment = completedSegments[0];
            flushSegment(request, destination, contentSegment);
            return writeEndCompletedSuspenseBoundary$1(destination, request.responseState);
          }
        }
        function flushClientRenderedBoundary(request, destination, boundary) {
          return writeClientRenderBoundaryInstruction(destination, request.responseState, boundary.id, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
        }
        function flushSegmentContainer(request, destination, segment) {
          writeStartSegment(destination, request.responseState, segment.formatContext, segment.id);
          flushSegment(request, destination, segment);
          return writeEndSegment(destination, segment.formatContext);
        }
        function flushCompletedBoundary(request, destination, boundary) {
          var completedSegments = boundary.completedSegments;
          var i = 0;
          for (; i < completedSegments.length; i++) {
            var segment = completedSegments[i];
            flushPartiallyCompletedSegment(request, destination, boundary, segment);
          }
          completedSegments.length = 0;
          return writeCompletedBoundaryInstruction(destination, request.responseState, boundary.id, boundary.rootSegmentID);
        }
        function flushPartialBoundary(request, destination, boundary) {
          var completedSegments = boundary.completedSegments;
          var i = 0;
          for (; i < completedSegments.length; i++) {
            var segment = completedSegments[i];
            if (!flushPartiallyCompletedSegment(request, destination, boundary, segment)) {
              i++;
              completedSegments.splice(0, i);
              return false;
            }
          }
          completedSegments.splice(0, i);
          return true;
        }
        function flushPartiallyCompletedSegment(request, destination, boundary, segment) {
          if (segment.status === FLUSHED) {
            return true;
          }
          var segmentID = segment.id;
          if (segmentID === -1) {
            var rootSegmentID = segment.id = boundary.rootSegmentID;
            if (rootSegmentID === -1) {
              throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
            }
            return flushSegmentContainer(request, destination, segment);
          } else {
            flushSegmentContainer(request, destination, segment);
            return writeCompletedSegmentInstruction(destination, request.responseState, segmentID);
          }
        }
        function flushCompletedQueues(request, destination) {
          try {
            var completedRootSegment = request.completedRootSegment;
            if (completedRootSegment !== null && request.pendingRootTasks === 0) {
              flushSegment(request, destination, completedRootSegment);
              request.completedRootSegment = null;
              writeCompletedRoot(destination, request.responseState);
            }
            var clientRenderedBoundaries = request.clientRenderedBoundaries;
            var i;
            for (i = 0; i < clientRenderedBoundaries.length; i++) {
              var boundary = clientRenderedBoundaries[i];
              if (!flushClientRenderedBoundary(request, destination, boundary)) {
                request.destination = null;
                i++;
                clientRenderedBoundaries.splice(0, i);
                return;
              }
            }
            clientRenderedBoundaries.splice(0, i);
            var completedBoundaries = request.completedBoundaries;
            for (i = 0; i < completedBoundaries.length; i++) {
              var _boundary = completedBoundaries[i];
              if (!flushCompletedBoundary(request, destination, _boundary)) {
                request.destination = null;
                i++;
                completedBoundaries.splice(0, i);
                return;
              }
            }
            completedBoundaries.splice(0, i);
            completeWriting(destination);
            beginWriting(destination);
            var partialBoundaries = request.partialBoundaries;
            for (i = 0; i < partialBoundaries.length; i++) {
              var _boundary2 = partialBoundaries[i];
              if (!flushPartialBoundary(request, destination, _boundary2)) {
                request.destination = null;
                i++;
                partialBoundaries.splice(0, i);
                return;
              }
            }
            partialBoundaries.splice(0, i);
            var largeBoundaries = request.completedBoundaries;
            for (i = 0; i < largeBoundaries.length; i++) {
              var _boundary3 = largeBoundaries[i];
              if (!flushCompletedBoundary(request, destination, _boundary3)) {
                request.destination = null;
                i++;
                largeBoundaries.splice(0, i);
                return;
              }
            }
            largeBoundaries.splice(0, i);
          } finally {
            if (request.allPendingTasks === 0 && request.pingedTasks.length === 0 && request.clientRenderedBoundaries.length === 0 && request.completedBoundaries.length === 0) {
              {
                if (request.abortableTasks.size !== 0) {
                  error("There was still abortable task at the root when we closed. This is a bug in React.");
                }
              }
              close(destination);
            }
          }
        }
        function startWork(request) {
          scheduleWork(function() {
            return performWork(request);
          });
        }
        function startFlowing(request, destination) {
          if (request.status === CLOSING) {
            request.status = CLOSED;
            closeWithError(destination, request.fatalError);
            return;
          }
          if (request.status === CLOSED) {
            return;
          }
          if (request.destination !== null) {
            return;
          }
          request.destination = destination;
          try {
            flushCompletedQueues(request, destination);
          } catch (error2) {
            logRecoverableError(request, error2);
            fatalError(request, error2);
          }
        }
        function abort(request, reason) {
          try {
            var abortableTasks = request.abortableTasks;
            abortableTasks.forEach(function(task) {
              return abortTask(task, request, reason);
            });
            abortableTasks.clear();
            if (request.destination !== null) {
              flushCompletedQueues(request, request.destination);
            }
          } catch (error2) {
            logRecoverableError(request, error2);
            fatalError(request, error2);
          }
        }
        function onError() {
        }
        function renderToStringImpl(children, options, generateStaticMarkup, abortReason) {
          var didFatal = false;
          var fatalError2 = null;
          var result = "";
          var destination = {
            push: function(chunk) {
              if (chunk !== null) {
                result += chunk;
              }
              return true;
            },
            destroy: function(error2) {
              didFatal = true;
              fatalError2 = error2;
            }
          };
          var readyToStream = false;
          function onShellReady() {
            readyToStream = true;
          }
          var request = createRequest(children, createResponseState$1(generateStaticMarkup, options ? options.identifierPrefix : void 0), createRootFormatContext(), Infinity, onError, void 0, onShellReady, void 0, void 0);
          startWork(request);
          abort(request, abortReason);
          startFlowing(request, destination);
          if (didFatal) {
            throw fatalError2;
          }
          if (!readyToStream) {
            throw new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          }
          return result;
        }
        function renderToString(children, options) {
          return renderToStringImpl(children, options, false, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
        }
        function renderToStaticMarkup(children, options) {
          return renderToStringImpl(children, options, true, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
        }
        function renderToNodeStream() {
          throw new Error("ReactDOMServer.renderToNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToString() instead.");
        }
        function renderToStaticNodeStream() {
          throw new Error("ReactDOMServer.renderToStaticNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToStaticMarkup() instead.");
        }
        exports.renderToNodeStream = renderToNodeStream;
        exports.renderToStaticMarkup = renderToStaticMarkup;
        exports.renderToStaticNodeStream = renderToStaticNodeStream;
        exports.renderToString = renderToString;
        exports.version = ReactVersion;
      })();
    }
  }
});

// ../../node_modules/react-dom/cjs/react-dom-server.browser.development.js
var require_react_dom_server_browser_development = __commonJS({
  "../../node_modules/react-dom/cjs/react-dom-server.browser.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var React = require_react();
        var ReactVersion = "18.2.0";
        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function warn(format) {
          {
            {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              printWarning("warn", format, args);
            }
          }
        }
        function error(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        function scheduleWork(callback) {
          callback();
        }
        var VIEW_SIZE = 512;
        var currentView = null;
        var writtenBytes = 0;
        function beginWriting(destination) {
          currentView = new Uint8Array(VIEW_SIZE);
          writtenBytes = 0;
        }
        function writeChunk(destination, chunk) {
          if (chunk.length === 0) {
            return;
          }
          if (chunk.length > VIEW_SIZE) {
            if (writtenBytes > 0) {
              destination.enqueue(new Uint8Array(currentView.buffer, 0, writtenBytes));
              currentView = new Uint8Array(VIEW_SIZE);
              writtenBytes = 0;
            }
            destination.enqueue(chunk);
            return;
          }
          var bytesToWrite = chunk;
          var allowableBytes = currentView.length - writtenBytes;
          if (allowableBytes < bytesToWrite.length) {
            if (allowableBytes === 0) {
              destination.enqueue(currentView);
            } else {
              currentView.set(bytesToWrite.subarray(0, allowableBytes), writtenBytes);
              destination.enqueue(currentView);
              bytesToWrite = bytesToWrite.subarray(allowableBytes);
            }
            currentView = new Uint8Array(VIEW_SIZE);
            writtenBytes = 0;
          }
          currentView.set(bytesToWrite, writtenBytes);
          writtenBytes += bytesToWrite.length;
        }
        function writeChunkAndReturn(destination, chunk) {
          writeChunk(destination, chunk);
          return true;
        }
        function completeWriting(destination) {
          if (currentView && writtenBytes > 0) {
            destination.enqueue(new Uint8Array(currentView.buffer, 0, writtenBytes));
            currentView = null;
            writtenBytes = 0;
          }
        }
        function close(destination) {
          destination.close();
        }
        var textEncoder = new TextEncoder();
        function stringToChunk(content) {
          return textEncoder.encode(content);
        }
        function stringToPrecomputedChunk(content) {
          return textEncoder.encode(content);
        }
        function closeWithError(destination, error2) {
          if (typeof destination.error === "function") {
            destination.error(error2);
          } else {
            destination.close();
          }
        }
        function typeName(value) {
          {
            var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
            var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            return type;
          }
        }
        function willCoercionThrow(value) {
          {
            try {
              testStringCoercion(value);
              return false;
            } catch (e) {
              return true;
            }
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkAttributeStringCoercion(value, attributeName) {
          {
            if (willCoercionThrow(value)) {
              error("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", attributeName, typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function checkCSSPropertyStringCoercion(value, propName) {
          {
            if (willCoercionThrow(value)) {
              error("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function checkHtmlStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var RESERVED = 0;
        var STRING = 1;
        var BOOLEANISH_STRING = 2;
        var BOOLEAN = 3;
        var OVERLOADED_BOOLEAN = 4;
        var NUMERIC = 5;
        var POSITIVE_NUMERIC = 6;
        var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
        var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
        var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
        var illegalAttributeNameCache = {};
        var validatedAttributeNameCache = {};
        function isAttributeNameSafe(attributeName) {
          if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {
            return true;
          }
          if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {
            return false;
          }
          if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
            validatedAttributeNameCache[attributeName] = true;
            return true;
          }
          illegalAttributeNameCache[attributeName] = true;
          {
            error("Invalid attribute name: `%s`", attributeName);
          }
          return false;
        }
        function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
          if (propertyInfo !== null && propertyInfo.type === RESERVED) {
            return false;
          }
          switch (typeof value) {
            case "function":
            case "symbol":
              return true;
            case "boolean": {
              if (isCustomComponentTag) {
                return false;
              }
              if (propertyInfo !== null) {
                return !propertyInfo.acceptsBooleans;
              } else {
                var prefix2 = name.toLowerCase().slice(0, 5);
                return prefix2 !== "data-" && prefix2 !== "aria-";
              }
            }
            default:
              return false;
          }
        }
        function getPropertyInfo(name) {
          return properties.hasOwnProperty(name) ? properties[name] : null;
        }
        function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
          this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
          this.attributeName = attributeName;
          this.attributeNamespace = attributeNamespace;
          this.mustUseProperty = mustUseProperty;
          this.propertyName = name;
          this.type = type;
          this.sanitizeURL = sanitizeURL2;
          this.removeEmptyString = removeEmptyString;
        }
        var properties = {};
        var reservedProps = [
          "children",
          "dangerouslySetInnerHTML",
          // TODO: This prevents the assignment of defaultValue to regular
          // elements (not just inputs). Now that ReactDOMInput assigns to the
          // defaultValue property -- do we need this?
          "defaultValue",
          "defaultChecked",
          "innerHTML",
          "suppressContentEditableWarning",
          "suppressHydrationWarning",
          "style"
        ];
        reservedProps.forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            RESERVED,
            false,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
          var name = _ref[0], attributeName = _ref[1];
          properties[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            BOOLEANISH_STRING,
            false,
            // mustUseProperty
            name.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            BOOLEANISH_STRING,
            false,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "allowFullScreen",
          "async",
          // Note: there is a special case that prevents it from being written to the DOM
          // on the client side because the browsers are inconsistent. Instead we call focus().
          "autoFocus",
          "autoPlay",
          "controls",
          "default",
          "defer",
          "disabled",
          "disablePictureInPicture",
          "disableRemotePlayback",
          "formNoValidate",
          "hidden",
          "loop",
          "noModule",
          "noValidate",
          "open",
          "playsInline",
          "readOnly",
          "required",
          "reversed",
          "scoped",
          "seamless",
          // Microdata
          "itemScope"
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            BOOLEAN,
            false,
            // mustUseProperty
            name.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "checked",
          // Note: `option.selected` is not updated if `select.multiple` is
          // disabled with `removeAttribute`. We have special logic for handling this.
          "multiple",
          "muted",
          "selected"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            BOOLEAN,
            true,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "capture",
          "download"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            OVERLOADED_BOOLEAN,
            false,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "cols",
          "rows",
          "size",
          "span"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            POSITIVE_NUMERIC,
            false,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        ["rowSpan", "start"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            NUMERIC,
            false,
            // mustUseProperty
            name.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        var CAMELIZE = /[\-\:]([a-z])/g;
        var capitalize = function(token) {
          return token[1].toUpperCase();
        };
        [
          "accent-height",
          "alignment-baseline",
          "arabic-form",
          "baseline-shift",
          "cap-height",
          "clip-path",
          "clip-rule",
          "color-interpolation",
          "color-interpolation-filters",
          "color-profile",
          "color-rendering",
          "dominant-baseline",
          "enable-background",
          "fill-opacity",
          "fill-rule",
          "flood-color",
          "flood-opacity",
          "font-family",
          "font-size",
          "font-size-adjust",
          "font-stretch",
          "font-style",
          "font-variant",
          "font-weight",
          "glyph-name",
          "glyph-orientation-horizontal",
          "glyph-orientation-vertical",
          "horiz-adv-x",
          "horiz-origin-x",
          "image-rendering",
          "letter-spacing",
          "lighting-color",
          "marker-end",
          "marker-mid",
          "marker-start",
          "overline-position",
          "overline-thickness",
          "paint-order",
          "panose-1",
          "pointer-events",
          "rendering-intent",
          "shape-rendering",
          "stop-color",
          "stop-opacity",
          "strikethrough-position",
          "strikethrough-thickness",
          "stroke-dasharray",
          "stroke-dashoffset",
          "stroke-linecap",
          "stroke-linejoin",
          "stroke-miterlimit",
          "stroke-opacity",
          "stroke-width",
          "text-anchor",
          "text-decoration",
          "text-rendering",
          "underline-position",
          "underline-thickness",
          "unicode-bidi",
          "unicode-range",
          "units-per-em",
          "v-alphabetic",
          "v-hanging",
          "v-ideographic",
          "v-mathematical",
          "vector-effect",
          "vert-adv-y",
          "vert-origin-x",
          "vert-origin-y",
          "word-spacing",
          "writing-mode",
          "xmlns:xlink",
          "x-height"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "xlink:actuate",
          "xlink:arcrole",
          "xlink:role",
          "xlink:show",
          "xlink:title",
          "xlink:type"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            "http://www.w3.org/1999/xlink",
            false,
            // sanitizeURL
            false
          );
        });
        [
          "xml:base",
          "xml:lang",
          "xml:space"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            "http://www.w3.org/XML/1998/namespace",
            false,
            // sanitizeURL
            false
          );
        });
        ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
          properties[attributeName] = new PropertyInfoRecord(
            attributeName,
            STRING,
            false,
            // mustUseProperty
            attributeName.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        var xlinkHref = "xlinkHref";
        properties[xlinkHref] = new PropertyInfoRecord(
          "xlinkHref",
          STRING,
          false,
          // mustUseProperty
          "xlink:href",
          "http://www.w3.org/1999/xlink",
          true,
          // sanitizeURL
          false
        );
        ["src", "href", "action", "formAction"].forEach(function(attributeName) {
          properties[attributeName] = new PropertyInfoRecord(
            attributeName,
            STRING,
            false,
            // mustUseProperty
            attributeName.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            true,
            // sanitizeURL
            true
          );
        });
        var isUnitlessNumber = {
          animationIterationCount: true,
          aspectRatio: true,
          borderImageOutset: true,
          borderImageSlice: true,
          borderImageWidth: true,
          boxFlex: true,
          boxFlexGroup: true,
          boxOrdinalGroup: true,
          columnCount: true,
          columns: true,
          flex: true,
          flexGrow: true,
          flexPositive: true,
          flexShrink: true,
          flexNegative: true,
          flexOrder: true,
          gridArea: true,
          gridRow: true,
          gridRowEnd: true,
          gridRowSpan: true,
          gridRowStart: true,
          gridColumn: true,
          gridColumnEnd: true,
          gridColumnSpan: true,
          gridColumnStart: true,
          fontWeight: true,
          lineClamp: true,
          lineHeight: true,
          opacity: true,
          order: true,
          orphans: true,
          tabSize: true,
          widows: true,
          zIndex: true,
          zoom: true,
          // SVG-related properties
          fillOpacity: true,
          floodOpacity: true,
          stopOpacity: true,
          strokeDasharray: true,
          strokeDashoffset: true,
          strokeMiterlimit: true,
          strokeOpacity: true,
          strokeWidth: true
        };
        function prefixKey(prefix2, key) {
          return prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
        }
        var prefixes = ["Webkit", "ms", "Moz", "O"];
        Object.keys(isUnitlessNumber).forEach(function(prop) {
          prefixes.forEach(function(prefix2) {
            isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
          });
        });
        var hasReadOnlyValue = {
          button: true,
          checkbox: true,
          image: true,
          hidden: true,
          radio: true,
          reset: true,
          submit: true
        };
        function checkControlledValueProps(tagName, props) {
          {
            if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
              error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
            }
            if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
              error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
            }
          }
        }
        function isCustomComponent(tagName, props) {
          if (tagName.indexOf("-") === -1) {
            return typeof props.is === "string";
          }
          switch (tagName) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              return false;
            default:
              return true;
          }
        }
        var ariaProperties = {
          "aria-current": 0,
          // state
          "aria-description": 0,
          "aria-details": 0,
          "aria-disabled": 0,
          // state
          "aria-hidden": 0,
          // state
          "aria-invalid": 0,
          // state
          "aria-keyshortcuts": 0,
          "aria-label": 0,
          "aria-roledescription": 0,
          // Widget Attributes
          "aria-autocomplete": 0,
          "aria-checked": 0,
          "aria-expanded": 0,
          "aria-haspopup": 0,
          "aria-level": 0,
          "aria-modal": 0,
          "aria-multiline": 0,
          "aria-multiselectable": 0,
          "aria-orientation": 0,
          "aria-placeholder": 0,
          "aria-pressed": 0,
          "aria-readonly": 0,
          "aria-required": 0,
          "aria-selected": 0,
          "aria-sort": 0,
          "aria-valuemax": 0,
          "aria-valuemin": 0,
          "aria-valuenow": 0,
          "aria-valuetext": 0,
          // Live Region Attributes
          "aria-atomic": 0,
          "aria-busy": 0,
          "aria-live": 0,
          "aria-relevant": 0,
          // Drag-and-Drop Attributes
          "aria-dropeffect": 0,
          "aria-grabbed": 0,
          // Relationship Attributes
          "aria-activedescendant": 0,
          "aria-colcount": 0,
          "aria-colindex": 0,
          "aria-colspan": 0,
          "aria-controls": 0,
          "aria-describedby": 0,
          "aria-errormessage": 0,
          "aria-flowto": 0,
          "aria-labelledby": 0,
          "aria-owns": 0,
          "aria-posinset": 0,
          "aria-rowcount": 0,
          "aria-rowindex": 0,
          "aria-rowspan": 0,
          "aria-setsize": 0
        };
        var warnedProperties = {};
        var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
        var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
        function validateProperty(tagName, name) {
          {
            if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {
              return true;
            }
            if (rARIACamel.test(name)) {
              var ariaName = "aria-" + name.slice(4).toLowerCase();
              var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
              if (correctName == null) {
                error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name);
                warnedProperties[name] = true;
                return true;
              }
              if (name !== correctName) {
                error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, correctName);
                warnedProperties[name] = true;
                return true;
              }
            }
            if (rARIA.test(name)) {
              var lowerCasedName = name.toLowerCase();
              var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
              if (standardName == null) {
                warnedProperties[name] = true;
                return false;
              }
              if (name !== standardName) {
                error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, standardName);
                warnedProperties[name] = true;
                return true;
              }
            }
          }
          return true;
        }
        function warnInvalidARIAProps(type, props) {
          {
            var invalidProps = [];
            for (var key in props) {
              var isValid = validateProperty(type, key);
              if (!isValid) {
                invalidProps.push(key);
              }
            }
            var unknownPropString = invalidProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (invalidProps.length === 1) {
              error("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
            } else if (invalidProps.length > 1) {
              error("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
            }
          }
        }
        function validateProperties(type, props) {
          if (isCustomComponent(type, props)) {
            return;
          }
          warnInvalidARIAProps(type, props);
        }
        var didWarnValueNull = false;
        function validateProperties$1(type, props) {
          {
            if (type !== "input" && type !== "textarea" && type !== "select") {
              return;
            }
            if (props != null && props.value === null && !didWarnValueNull) {
              didWarnValueNull = true;
              if (type === "select" && props.multiple) {
                error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type);
              } else {
                error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type);
              }
            }
          }
        }
        var possibleStandardNames = {
          // HTML
          accept: "accept",
          acceptcharset: "acceptCharset",
          "accept-charset": "acceptCharset",
          accesskey: "accessKey",
          action: "action",
          allowfullscreen: "allowFullScreen",
          alt: "alt",
          as: "as",
          async: "async",
          autocapitalize: "autoCapitalize",
          autocomplete: "autoComplete",
          autocorrect: "autoCorrect",
          autofocus: "autoFocus",
          autoplay: "autoPlay",
          autosave: "autoSave",
          capture: "capture",
          cellpadding: "cellPadding",
          cellspacing: "cellSpacing",
          challenge: "challenge",
          charset: "charSet",
          checked: "checked",
          children: "children",
          cite: "cite",
          class: "className",
          classid: "classID",
          classname: "className",
          cols: "cols",
          colspan: "colSpan",
          content: "content",
          contenteditable: "contentEditable",
          contextmenu: "contextMenu",
          controls: "controls",
          controlslist: "controlsList",
          coords: "coords",
          crossorigin: "crossOrigin",
          dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
          data: "data",
          datetime: "dateTime",
          default: "default",
          defaultchecked: "defaultChecked",
          defaultvalue: "defaultValue",
          defer: "defer",
          dir: "dir",
          disabled: "disabled",
          disablepictureinpicture: "disablePictureInPicture",
          disableremoteplayback: "disableRemotePlayback",
          download: "download",
          draggable: "draggable",
          enctype: "encType",
          enterkeyhint: "enterKeyHint",
          for: "htmlFor",
          form: "form",
          formmethod: "formMethod",
          formaction: "formAction",
          formenctype: "formEncType",
          formnovalidate: "formNoValidate",
          formtarget: "formTarget",
          frameborder: "frameBorder",
          headers: "headers",
          height: "height",
          hidden: "hidden",
          high: "high",
          href: "href",
          hreflang: "hrefLang",
          htmlfor: "htmlFor",
          httpequiv: "httpEquiv",
          "http-equiv": "httpEquiv",
          icon: "icon",
          id: "id",
          imagesizes: "imageSizes",
          imagesrcset: "imageSrcSet",
          innerhtml: "innerHTML",
          inputmode: "inputMode",
          integrity: "integrity",
          is: "is",
          itemid: "itemID",
          itemprop: "itemProp",
          itemref: "itemRef",
          itemscope: "itemScope",
          itemtype: "itemType",
          keyparams: "keyParams",
          keytype: "keyType",
          kind: "kind",
          label: "label",
          lang: "lang",
          list: "list",
          loop: "loop",
          low: "low",
          manifest: "manifest",
          marginwidth: "marginWidth",
          marginheight: "marginHeight",
          max: "max",
          maxlength: "maxLength",
          media: "media",
          mediagroup: "mediaGroup",
          method: "method",
          min: "min",
          minlength: "minLength",
          multiple: "multiple",
          muted: "muted",
          name: "name",
          nomodule: "noModule",
          nonce: "nonce",
          novalidate: "noValidate",
          open: "open",
          optimum: "optimum",
          pattern: "pattern",
          placeholder: "placeholder",
          playsinline: "playsInline",
          poster: "poster",
          preload: "preload",
          profile: "profile",
          radiogroup: "radioGroup",
          readonly: "readOnly",
          referrerpolicy: "referrerPolicy",
          rel: "rel",
          required: "required",
          reversed: "reversed",
          role: "role",
          rows: "rows",
          rowspan: "rowSpan",
          sandbox: "sandbox",
          scope: "scope",
          scoped: "scoped",
          scrolling: "scrolling",
          seamless: "seamless",
          selected: "selected",
          shape: "shape",
          size: "size",
          sizes: "sizes",
          span: "span",
          spellcheck: "spellCheck",
          src: "src",
          srcdoc: "srcDoc",
          srclang: "srcLang",
          srcset: "srcSet",
          start: "start",
          step: "step",
          style: "style",
          summary: "summary",
          tabindex: "tabIndex",
          target: "target",
          title: "title",
          type: "type",
          usemap: "useMap",
          value: "value",
          width: "width",
          wmode: "wmode",
          wrap: "wrap",
          // SVG
          about: "about",
          accentheight: "accentHeight",
          "accent-height": "accentHeight",
          accumulate: "accumulate",
          additive: "additive",
          alignmentbaseline: "alignmentBaseline",
          "alignment-baseline": "alignmentBaseline",
          allowreorder: "allowReorder",
          alphabetic: "alphabetic",
          amplitude: "amplitude",
          arabicform: "arabicForm",
          "arabic-form": "arabicForm",
          ascent: "ascent",
          attributename: "attributeName",
          attributetype: "attributeType",
          autoreverse: "autoReverse",
          azimuth: "azimuth",
          basefrequency: "baseFrequency",
          baselineshift: "baselineShift",
          "baseline-shift": "baselineShift",
          baseprofile: "baseProfile",
          bbox: "bbox",
          begin: "begin",
          bias: "bias",
          by: "by",
          calcmode: "calcMode",
          capheight: "capHeight",
          "cap-height": "capHeight",
          clip: "clip",
          clippath: "clipPath",
          "clip-path": "clipPath",
          clippathunits: "clipPathUnits",
          cliprule: "clipRule",
          "clip-rule": "clipRule",
          color: "color",
          colorinterpolation: "colorInterpolation",
          "color-interpolation": "colorInterpolation",
          colorinterpolationfilters: "colorInterpolationFilters",
          "color-interpolation-filters": "colorInterpolationFilters",
          colorprofile: "colorProfile",
          "color-profile": "colorProfile",
          colorrendering: "colorRendering",
          "color-rendering": "colorRendering",
          contentscripttype: "contentScriptType",
          contentstyletype: "contentStyleType",
          cursor: "cursor",
          cx: "cx",
          cy: "cy",
          d: "d",
          datatype: "datatype",
          decelerate: "decelerate",
          descent: "descent",
          diffuseconstant: "diffuseConstant",
          direction: "direction",
          display: "display",
          divisor: "divisor",
          dominantbaseline: "dominantBaseline",
          "dominant-baseline": "dominantBaseline",
          dur: "dur",
          dx: "dx",
          dy: "dy",
          edgemode: "edgeMode",
          elevation: "elevation",
          enablebackground: "enableBackground",
          "enable-background": "enableBackground",
          end: "end",
          exponent: "exponent",
          externalresourcesrequired: "externalResourcesRequired",
          fill: "fill",
          fillopacity: "fillOpacity",
          "fill-opacity": "fillOpacity",
          fillrule: "fillRule",
          "fill-rule": "fillRule",
          filter: "filter",
          filterres: "filterRes",
          filterunits: "filterUnits",
          floodopacity: "floodOpacity",
          "flood-opacity": "floodOpacity",
          floodcolor: "floodColor",
          "flood-color": "floodColor",
          focusable: "focusable",
          fontfamily: "fontFamily",
          "font-family": "fontFamily",
          fontsize: "fontSize",
          "font-size": "fontSize",
          fontsizeadjust: "fontSizeAdjust",
          "font-size-adjust": "fontSizeAdjust",
          fontstretch: "fontStretch",
          "font-stretch": "fontStretch",
          fontstyle: "fontStyle",
          "font-style": "fontStyle",
          fontvariant: "fontVariant",
          "font-variant": "fontVariant",
          fontweight: "fontWeight",
          "font-weight": "fontWeight",
          format: "format",
          from: "from",
          fx: "fx",
          fy: "fy",
          g1: "g1",
          g2: "g2",
          glyphname: "glyphName",
          "glyph-name": "glyphName",
          glyphorientationhorizontal: "glyphOrientationHorizontal",
          "glyph-orientation-horizontal": "glyphOrientationHorizontal",
          glyphorientationvertical: "glyphOrientationVertical",
          "glyph-orientation-vertical": "glyphOrientationVertical",
          glyphref: "glyphRef",
          gradienttransform: "gradientTransform",
          gradientunits: "gradientUnits",
          hanging: "hanging",
          horizadvx: "horizAdvX",
          "horiz-adv-x": "horizAdvX",
          horizoriginx: "horizOriginX",
          "horiz-origin-x": "horizOriginX",
          ideographic: "ideographic",
          imagerendering: "imageRendering",
          "image-rendering": "imageRendering",
          in2: "in2",
          in: "in",
          inlist: "inlist",
          intercept: "intercept",
          k1: "k1",
          k2: "k2",
          k3: "k3",
          k4: "k4",
          k: "k",
          kernelmatrix: "kernelMatrix",
          kernelunitlength: "kernelUnitLength",
          kerning: "kerning",
          keypoints: "keyPoints",
          keysplines: "keySplines",
          keytimes: "keyTimes",
          lengthadjust: "lengthAdjust",
          letterspacing: "letterSpacing",
          "letter-spacing": "letterSpacing",
          lightingcolor: "lightingColor",
          "lighting-color": "lightingColor",
          limitingconeangle: "limitingConeAngle",
          local: "local",
          markerend: "markerEnd",
          "marker-end": "markerEnd",
          markerheight: "markerHeight",
          markermid: "markerMid",
          "marker-mid": "markerMid",
          markerstart: "markerStart",
          "marker-start": "markerStart",
          markerunits: "markerUnits",
          markerwidth: "markerWidth",
          mask: "mask",
          maskcontentunits: "maskContentUnits",
          maskunits: "maskUnits",
          mathematical: "mathematical",
          mode: "mode",
          numoctaves: "numOctaves",
          offset: "offset",
          opacity: "opacity",
          operator: "operator",
          order: "order",
          orient: "orient",
          orientation: "orientation",
          origin: "origin",
          overflow: "overflow",
          overlineposition: "overlinePosition",
          "overline-position": "overlinePosition",
          overlinethickness: "overlineThickness",
          "overline-thickness": "overlineThickness",
          paintorder: "paintOrder",
          "paint-order": "paintOrder",
          panose1: "panose1",
          "panose-1": "panose1",
          pathlength: "pathLength",
          patterncontentunits: "patternContentUnits",
          patterntransform: "patternTransform",
          patternunits: "patternUnits",
          pointerevents: "pointerEvents",
          "pointer-events": "pointerEvents",
          points: "points",
          pointsatx: "pointsAtX",
          pointsaty: "pointsAtY",
          pointsatz: "pointsAtZ",
          prefix: "prefix",
          preservealpha: "preserveAlpha",
          preserveaspectratio: "preserveAspectRatio",
          primitiveunits: "primitiveUnits",
          property: "property",
          r: "r",
          radius: "radius",
          refx: "refX",
          refy: "refY",
          renderingintent: "renderingIntent",
          "rendering-intent": "renderingIntent",
          repeatcount: "repeatCount",
          repeatdur: "repeatDur",
          requiredextensions: "requiredExtensions",
          requiredfeatures: "requiredFeatures",
          resource: "resource",
          restart: "restart",
          result: "result",
          results: "results",
          rotate: "rotate",
          rx: "rx",
          ry: "ry",
          scale: "scale",
          security: "security",
          seed: "seed",
          shaperendering: "shapeRendering",
          "shape-rendering": "shapeRendering",
          slope: "slope",
          spacing: "spacing",
          specularconstant: "specularConstant",
          specularexponent: "specularExponent",
          speed: "speed",
          spreadmethod: "spreadMethod",
          startoffset: "startOffset",
          stddeviation: "stdDeviation",
          stemh: "stemh",
          stemv: "stemv",
          stitchtiles: "stitchTiles",
          stopcolor: "stopColor",
          "stop-color": "stopColor",
          stopopacity: "stopOpacity",
          "stop-opacity": "stopOpacity",
          strikethroughposition: "strikethroughPosition",
          "strikethrough-position": "strikethroughPosition",
          strikethroughthickness: "strikethroughThickness",
          "strikethrough-thickness": "strikethroughThickness",
          string: "string",
          stroke: "stroke",
          strokedasharray: "strokeDasharray",
          "stroke-dasharray": "strokeDasharray",
          strokedashoffset: "strokeDashoffset",
          "stroke-dashoffset": "strokeDashoffset",
          strokelinecap: "strokeLinecap",
          "stroke-linecap": "strokeLinecap",
          strokelinejoin: "strokeLinejoin",
          "stroke-linejoin": "strokeLinejoin",
          strokemiterlimit: "strokeMiterlimit",
          "stroke-miterlimit": "strokeMiterlimit",
          strokewidth: "strokeWidth",
          "stroke-width": "strokeWidth",
          strokeopacity: "strokeOpacity",
          "stroke-opacity": "strokeOpacity",
          suppresscontenteditablewarning: "suppressContentEditableWarning",
          suppresshydrationwarning: "suppressHydrationWarning",
          surfacescale: "surfaceScale",
          systemlanguage: "systemLanguage",
          tablevalues: "tableValues",
          targetx: "targetX",
          targety: "targetY",
          textanchor: "textAnchor",
          "text-anchor": "textAnchor",
          textdecoration: "textDecoration",
          "text-decoration": "textDecoration",
          textlength: "textLength",
          textrendering: "textRendering",
          "text-rendering": "textRendering",
          to: "to",
          transform: "transform",
          typeof: "typeof",
          u1: "u1",
          u2: "u2",
          underlineposition: "underlinePosition",
          "underline-position": "underlinePosition",
          underlinethickness: "underlineThickness",
          "underline-thickness": "underlineThickness",
          unicode: "unicode",
          unicodebidi: "unicodeBidi",
          "unicode-bidi": "unicodeBidi",
          unicoderange: "unicodeRange",
          "unicode-range": "unicodeRange",
          unitsperem: "unitsPerEm",
          "units-per-em": "unitsPerEm",
          unselectable: "unselectable",
          valphabetic: "vAlphabetic",
          "v-alphabetic": "vAlphabetic",
          values: "values",
          vectoreffect: "vectorEffect",
          "vector-effect": "vectorEffect",
          version: "version",
          vertadvy: "vertAdvY",
          "vert-adv-y": "vertAdvY",
          vertoriginx: "vertOriginX",
          "vert-origin-x": "vertOriginX",
          vertoriginy: "vertOriginY",
          "vert-origin-y": "vertOriginY",
          vhanging: "vHanging",
          "v-hanging": "vHanging",
          videographic: "vIdeographic",
          "v-ideographic": "vIdeographic",
          viewbox: "viewBox",
          viewtarget: "viewTarget",
          visibility: "visibility",
          vmathematical: "vMathematical",
          "v-mathematical": "vMathematical",
          vocab: "vocab",
          widths: "widths",
          wordspacing: "wordSpacing",
          "word-spacing": "wordSpacing",
          writingmode: "writingMode",
          "writing-mode": "writingMode",
          x1: "x1",
          x2: "x2",
          x: "x",
          xchannelselector: "xChannelSelector",
          xheight: "xHeight",
          "x-height": "xHeight",
          xlinkactuate: "xlinkActuate",
          "xlink:actuate": "xlinkActuate",
          xlinkarcrole: "xlinkArcrole",
          "xlink:arcrole": "xlinkArcrole",
          xlinkhref: "xlinkHref",
          "xlink:href": "xlinkHref",
          xlinkrole: "xlinkRole",
          "xlink:role": "xlinkRole",
          xlinkshow: "xlinkShow",
          "xlink:show": "xlinkShow",
          xlinktitle: "xlinkTitle",
          "xlink:title": "xlinkTitle",
          xlinktype: "xlinkType",
          "xlink:type": "xlinkType",
          xmlbase: "xmlBase",
          "xml:base": "xmlBase",
          xmllang: "xmlLang",
          "xml:lang": "xmlLang",
          xmlns: "xmlns",
          "xml:space": "xmlSpace",
          xmlnsxlink: "xmlnsXlink",
          "xmlns:xlink": "xmlnsXlink",
          xmlspace: "xmlSpace",
          y1: "y1",
          y2: "y2",
          y: "y",
          ychannelselector: "yChannelSelector",
          z: "z",
          zoomandpan: "zoomAndPan"
        };
        var validateProperty$1 = function() {
        };
        {
          var warnedProperties$1 = {};
          var EVENT_NAME_REGEX = /^on./;
          var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
          var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
          var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
          validateProperty$1 = function(tagName, name, value, eventRegistry) {
            if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {
              return true;
            }
            var lowerCasedName = name.toLowerCase();
            if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
              error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (eventRegistry != null) {
              var registrationNameDependencies = eventRegistry.registrationNameDependencies, possibleRegistrationNames = eventRegistry.possibleRegistrationNames;
              if (registrationNameDependencies.hasOwnProperty(name)) {
                return true;
              }
              var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
              if (registrationName != null) {
                error("Invalid event handler property `%s`. Did you mean `%s`?", name, registrationName);
                warnedProperties$1[name] = true;
                return true;
              }
              if (EVENT_NAME_REGEX.test(name)) {
                error("Unknown event handler property `%s`. It will be ignored.", name);
                warnedProperties$1[name] = true;
                return true;
              }
            } else if (EVENT_NAME_REGEX.test(name)) {
              if (INVALID_EVENT_NAME_REGEX.test(name)) {
                error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name);
              }
              warnedProperties$1[name] = true;
              return true;
            }
            if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
              return true;
            }
            if (lowerCasedName === "innerhtml") {
              error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (lowerCasedName === "aria") {
              error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (lowerCasedName === "is" && value !== null && value !== void 0 && typeof value !== "string") {
              error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value);
              warnedProperties$1[name] = true;
              return true;
            }
            if (typeof value === "number" && isNaN(value)) {
              error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name);
              warnedProperties$1[name] = true;
              return true;
            }
            var propertyInfo = getPropertyInfo(name);
            var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
            if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
              var standardName = possibleStandardNames[lowerCasedName];
              if (standardName !== name) {
                error("Invalid DOM property `%s`. Did you mean `%s`?", name, standardName);
                warnedProperties$1[name] = true;
                return true;
              }
            } else if (!isReserved && name !== lowerCasedName) {
              error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName);
              warnedProperties$1[name] = true;
              return true;
            }
            if (typeof value === "boolean" && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
              if (value) {
                error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name, name, value, name);
              } else {
                error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
              }
              warnedProperties$1[name] = true;
              return true;
            }
            if (isReserved) {
              return true;
            }
            if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
              warnedProperties$1[name] = true;
              return false;
            }
            if ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
              error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
              warnedProperties$1[name] = true;
              return true;
            }
            return true;
          };
        }
        var warnUnknownProperties = function(type, props, eventRegistry) {
          {
            var unknownProps = [];
            for (var key in props) {
              var isValid = validateProperty$1(type, key, props[key], eventRegistry);
              if (!isValid) {
                unknownProps.push(key);
              }
            }
            var unknownPropString = unknownProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (unknownProps.length === 1) {
              error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
            } else if (unknownProps.length > 1) {
              error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
            }
          }
        };
        function validateProperties$2(type, props, eventRegistry) {
          if (isCustomComponent(type, props)) {
            return;
          }
          warnUnknownProperties(type, props, eventRegistry);
        }
        var warnValidStyle = function() {
        };
        {
          var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
          var msPattern = /^-ms-/;
          var hyphenPattern = /-(.)/g;
          var badStyleValueWithSemicolonPattern = /;\s*$/;
          var warnedStyleNames = {};
          var warnedStyleValues = {};
          var warnedForNaNValue = false;
          var warnedForInfinityValue = false;
          var camelize = function(string) {
            return string.replace(hyphenPattern, function(_, character) {
              return character.toUpperCase();
            });
          };
          var warnHyphenatedStyleName = function(name) {
            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
              return;
            }
            warnedStyleNames[name] = true;
            error(
              "Unsupported style property %s. Did you mean %s?",
              name,
              // As Andi Smith suggests
              // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
              // is converted to lowercase `ms`.
              camelize(name.replace(msPattern, "ms-"))
            );
          };
          var warnBadVendoredStyleName = function(name) {
            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
              return;
            }
            warnedStyleNames[name] = true;
            error("Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1));
          };
          var warnStyleValueWithSemicolon = function(name, value) {
            if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
              return;
            }
            warnedStyleValues[value] = true;
            error(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name, value.replace(badStyleValueWithSemicolonPattern, ""));
          };
          var warnStyleValueIsNaN = function(name, value) {
            if (warnedForNaNValue) {
              return;
            }
            warnedForNaNValue = true;
            error("`NaN` is an invalid value for the `%s` css style property.", name);
          };
          var warnStyleValueIsInfinity = function(name, value) {
            if (warnedForInfinityValue) {
              return;
            }
            warnedForInfinityValue = true;
            error("`Infinity` is an invalid value for the `%s` css style property.", name);
          };
          warnValidStyle = function(name, value) {
            if (name.indexOf("-") > -1) {
              warnHyphenatedStyleName(name);
            } else if (badVendoredStyleNamePattern.test(name)) {
              warnBadVendoredStyleName(name);
            } else if (badStyleValueWithSemicolonPattern.test(value)) {
              warnStyleValueWithSemicolon(name, value);
            }
            if (typeof value === "number") {
              if (isNaN(value)) {
                warnStyleValueIsNaN(name, value);
              } else if (!isFinite(value)) {
                warnStyleValueIsInfinity(name, value);
              }
            }
          };
        }
        var warnValidStyle$1 = warnValidStyle;
        var matchHtmlRegExp = /["'&<>]/;
        function escapeHtml(string) {
          {
            checkHtmlStringCoercion(string);
          }
          var str = "" + string;
          var match = matchHtmlRegExp.exec(str);
          if (!match) {
            return str;
          }
          var escape;
          var html = "";
          var index;
          var lastIndex = 0;
          for (index = match.index; index < str.length; index++) {
            switch (str.charCodeAt(index)) {
              case 34:
                escape = "&quot;";
                break;
              case 38:
                escape = "&amp;";
                break;
              case 39:
                escape = "&#x27;";
                break;
              case 60:
                escape = "&lt;";
                break;
              case 62:
                escape = "&gt;";
                break;
              default:
                continue;
            }
            if (lastIndex !== index) {
              html += str.substring(lastIndex, index);
            }
            lastIndex = index + 1;
            html += escape;
          }
          return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
        }
        function escapeTextForBrowser(text) {
          if (typeof text === "boolean" || typeof text === "number") {
            return "" + text;
          }
          return escapeHtml(text);
        }
        var uppercasePattern = /([A-Z])/g;
        var msPattern$1 = /^ms-/;
        function hyphenateStyleName(name) {
          return name.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-");
        }
        var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
        var didWarn = false;
        function sanitizeURL(url) {
          {
            if (!didWarn && isJavaScriptProtocol.test(url)) {
              didWarn = true;
              error("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
            }
          }
        }
        var isArrayImpl = Array.isArray;
        function isArray(a) {
          return isArrayImpl(a);
        }
        var startInlineScript = stringToPrecomputedChunk("<script>");
        var endInlineScript = stringToPrecomputedChunk("<\/script>");
        var startScriptSrc = stringToPrecomputedChunk('<script src="');
        var startModuleSrc = stringToPrecomputedChunk('<script type="module" src="');
        var endAsyncScript = stringToPrecomputedChunk('" async=""><\/script>');
        function escapeBootstrapScriptContent(scriptText) {
          {
            checkHtmlStringCoercion(scriptText);
          }
          return ("" + scriptText).replace(scriptRegex, scriptReplacer);
        }
        var scriptRegex = /(<\/|<)(s)(cript)/gi;
        var scriptReplacer = function(match, prefix2, s, suffix) {
          return "" + prefix2 + (s === "s" ? "\\u0073" : "\\u0053") + suffix;
        };
        function createResponseState(identifierPrefix, nonce, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
          var idPrefix = identifierPrefix === void 0 ? "" : identifierPrefix;
          var inlineScriptWithNonce = nonce === void 0 ? startInlineScript : stringToPrecomputedChunk('<script nonce="' + escapeTextForBrowser(nonce) + '">');
          var bootstrapChunks = [];
          if (bootstrapScriptContent !== void 0) {
            bootstrapChunks.push(inlineScriptWithNonce, stringToChunk(escapeBootstrapScriptContent(bootstrapScriptContent)), endInlineScript);
          }
          if (bootstrapScripts !== void 0) {
            for (var i = 0; i < bootstrapScripts.length; i++) {
              bootstrapChunks.push(startScriptSrc, stringToChunk(escapeTextForBrowser(bootstrapScripts[i])), endAsyncScript);
            }
          }
          if (bootstrapModules !== void 0) {
            for (var _i = 0; _i < bootstrapModules.length; _i++) {
              bootstrapChunks.push(startModuleSrc, stringToChunk(escapeTextForBrowser(bootstrapModules[_i])), endAsyncScript);
            }
          }
          return {
            bootstrapChunks,
            startInlineScript: inlineScriptWithNonce,
            placeholderPrefix: stringToPrecomputedChunk(idPrefix + "P:"),
            segmentPrefix: stringToPrecomputedChunk(idPrefix + "S:"),
            boundaryPrefix: idPrefix + "B:",
            idPrefix,
            nextSuspenseID: 0,
            sentCompleteSegmentFunction: false,
            sentCompleteBoundaryFunction: false,
            sentClientRenderFunction: false
          };
        }
        var ROOT_HTML_MODE = 0;
        var HTML_MODE = 1;
        var SVG_MODE = 2;
        var MATHML_MODE = 3;
        var HTML_TABLE_MODE = 4;
        var HTML_TABLE_BODY_MODE = 5;
        var HTML_TABLE_ROW_MODE = 6;
        var HTML_COLGROUP_MODE = 7;
        function createFormatContext(insertionMode, selectedValue) {
          return {
            insertionMode,
            selectedValue
          };
        }
        function createRootFormatContext(namespaceURI) {
          var insertionMode = namespaceURI === "http://www.w3.org/2000/svg" ? SVG_MODE : namespaceURI === "http://www.w3.org/1998/Math/MathML" ? MATHML_MODE : ROOT_HTML_MODE;
          return createFormatContext(insertionMode, null);
        }
        function getChildFormatContext(parentContext, type, props) {
          switch (type) {
            case "select":
              return createFormatContext(HTML_MODE, props.value != null ? props.value : props.defaultValue);
            case "svg":
              return createFormatContext(SVG_MODE, null);
            case "math":
              return createFormatContext(MATHML_MODE, null);
            case "foreignObject":
              return createFormatContext(HTML_MODE, null);
            case "table":
              return createFormatContext(HTML_TABLE_MODE, null);
            case "thead":
            case "tbody":
            case "tfoot":
              return createFormatContext(HTML_TABLE_BODY_MODE, null);
            case "colgroup":
              return createFormatContext(HTML_COLGROUP_MODE, null);
            case "tr":
              return createFormatContext(HTML_TABLE_ROW_MODE, null);
          }
          if (parentContext.insertionMode >= HTML_TABLE_MODE) {
            return createFormatContext(HTML_MODE, null);
          }
          if (parentContext.insertionMode === ROOT_HTML_MODE) {
            return createFormatContext(HTML_MODE, null);
          }
          return parentContext;
        }
        var UNINITIALIZED_SUSPENSE_BOUNDARY_ID = null;
        function assignSuspenseBoundaryID(responseState) {
          var generatedID = responseState.nextSuspenseID++;
          return stringToPrecomputedChunk(responseState.boundaryPrefix + generatedID.toString(16));
        }
        function makeId(responseState, treeId, localId) {
          var idPrefix = responseState.idPrefix;
          var id = ":" + idPrefix + "R" + treeId;
          if (localId > 0) {
            id += "H" + localId.toString(32);
          }
          return id + ":";
        }
        function encodeHTMLTextNode(text) {
          return escapeTextForBrowser(text);
        }
        var textSeparator = stringToPrecomputedChunk("<!-- -->");
        function pushTextInstance(target, text, responseState, textEmbedded) {
          if (text === "") {
            return textEmbedded;
          }
          if (textEmbedded) {
            target.push(textSeparator);
          }
          target.push(stringToChunk(encodeHTMLTextNode(text)));
          return true;
        }
        function pushSegmentFinale(target, responseState, lastPushedText, textEmbedded) {
          if (lastPushedText && textEmbedded) {
            target.push(textSeparator);
          }
        }
        var styleNameCache = /* @__PURE__ */ new Map();
        function processStyleName(styleName) {
          var chunk = styleNameCache.get(styleName);
          if (chunk !== void 0) {
            return chunk;
          }
          var result = stringToPrecomputedChunk(escapeTextForBrowser(hyphenateStyleName(styleName)));
          styleNameCache.set(styleName, result);
          return result;
        }
        var styleAttributeStart = stringToPrecomputedChunk(' style="');
        var styleAssign = stringToPrecomputedChunk(":");
        var styleSeparator = stringToPrecomputedChunk(";");
        function pushStyle(target, responseState, style) {
          if (typeof style !== "object") {
            throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
          }
          var isFirst = true;
          for (var styleName in style) {
            if (!hasOwnProperty.call(style, styleName)) {
              continue;
            }
            var styleValue = style[styleName];
            if (styleValue == null || typeof styleValue === "boolean" || styleValue === "") {
              continue;
            }
            var nameChunk = void 0;
            var valueChunk = void 0;
            var isCustomProperty = styleName.indexOf("--") === 0;
            if (isCustomProperty) {
              nameChunk = stringToChunk(escapeTextForBrowser(styleName));
              {
                checkCSSPropertyStringCoercion(styleValue, styleName);
              }
              valueChunk = stringToChunk(escapeTextForBrowser(("" + styleValue).trim()));
            } else {
              {
                warnValidStyle$1(styleName, styleValue);
              }
              nameChunk = processStyleName(styleName);
              if (typeof styleValue === "number") {
                if (styleValue !== 0 && !hasOwnProperty.call(isUnitlessNumber, styleName)) {
                  valueChunk = stringToChunk(styleValue + "px");
                } else {
                  valueChunk = stringToChunk("" + styleValue);
                }
              } else {
                {
                  checkCSSPropertyStringCoercion(styleValue, styleName);
                }
                valueChunk = stringToChunk(escapeTextForBrowser(("" + styleValue).trim()));
              }
            }
            if (isFirst) {
              isFirst = false;
              target.push(styleAttributeStart, nameChunk, styleAssign, valueChunk);
            } else {
              target.push(styleSeparator, nameChunk, styleAssign, valueChunk);
            }
          }
          if (!isFirst) {
            target.push(attributeEnd);
          }
        }
        var attributeSeparator = stringToPrecomputedChunk(" ");
        var attributeAssign = stringToPrecomputedChunk('="');
        var attributeEnd = stringToPrecomputedChunk('"');
        var attributeEmptyString = stringToPrecomputedChunk('=""');
        function pushAttribute(target, responseState, name, value) {
          switch (name) {
            case "style": {
              pushStyle(target, responseState, value);
              return;
            }
            case "defaultValue":
            case "defaultChecked":
            case "innerHTML":
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
              return;
          }
          if (
            // shouldIgnoreAttribute
            // We have already filtered out null/undefined and reserved words.
            name.length > 2 && (name[0] === "o" || name[0] === "O") && (name[1] === "n" || name[1] === "N")
          ) {
            return;
          }
          var propertyInfo = getPropertyInfo(name);
          if (propertyInfo !== null) {
            switch (typeof value) {
              case "function":
              case "symbol":
                return;
              case "boolean": {
                if (!propertyInfo.acceptsBooleans) {
                  return;
                }
              }
            }
            var attributeName = propertyInfo.attributeName;
            var attributeNameChunk = stringToChunk(attributeName);
            switch (propertyInfo.type) {
              case BOOLEAN:
                if (value) {
                  target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
                }
                return;
              case OVERLOADED_BOOLEAN:
                if (value === true) {
                  target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
                } else if (value === false)
                  ;
                else {
                  target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
                }
                return;
              case NUMERIC:
                if (!isNaN(value)) {
                  target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
                }
                break;
              case POSITIVE_NUMERIC:
                if (!isNaN(value) && value >= 1) {
                  target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
                }
                break;
              default:
                if (propertyInfo.sanitizeURL) {
                  {
                    checkAttributeStringCoercion(value, attributeName);
                  }
                  value = "" + value;
                  sanitizeURL(value);
                }
                target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
            }
          } else if (isAttributeNameSafe(name)) {
            switch (typeof value) {
              case "function":
              case "symbol":
                return;
              case "boolean": {
                var prefix2 = name.toLowerCase().slice(0, 5);
                if (prefix2 !== "data-" && prefix2 !== "aria-") {
                  return;
                }
              }
            }
            target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
          }
        }
        var endOfStartTag = stringToPrecomputedChunk(">");
        var endOfStartTagSelfClosing = stringToPrecomputedChunk("/>");
        function pushInnerHTML(target, innerHTML, children) {
          if (innerHTML != null) {
            if (children != null) {
              throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
            }
            if (typeof innerHTML !== "object" || !("__html" in innerHTML)) {
              throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
            }
            var html = innerHTML.__html;
            if (html !== null && html !== void 0) {
              {
                checkHtmlStringCoercion(html);
              }
              target.push(stringToChunk("" + html));
            }
          }
        }
        var didWarnDefaultInputValue = false;
        var didWarnDefaultChecked = false;
        var didWarnDefaultSelectValue = false;
        var didWarnDefaultTextareaValue = false;
        var didWarnInvalidOptionChildren = false;
        var didWarnInvalidOptionInnerHTML = false;
        var didWarnSelectedSetOnOption = false;
        function checkSelectProp(props, propName) {
          {
            var value = props[propName];
            if (value != null) {
              var array = isArray(value);
              if (props.multiple && !array) {
                error("The `%s` prop supplied to <select> must be an array if `multiple` is true.", propName);
              } else if (!props.multiple && array) {
                error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", propName);
              }
            }
          }
        }
        function pushStartSelect(target, props, responseState) {
          {
            checkControlledValueProps("select", props);
            checkSelectProp(props, "value");
            checkSelectProp(props, "defaultValue");
            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultSelectValue) {
              error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
              didWarnDefaultSelectValue = true;
            }
          }
          target.push(startChunkForTag("select"));
          var children = null;
          var innerHTML = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                case "defaultValue":
                case "value":
                  break;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          pushInnerHTML(target, innerHTML, children);
          return children;
        }
        function flattenOptionChildren(children) {
          var content = "";
          React.Children.forEach(children, function(child) {
            if (child == null) {
              return;
            }
            content += child;
            {
              if (!didWarnInvalidOptionChildren && typeof child !== "string" && typeof child !== "number") {
                didWarnInvalidOptionChildren = true;
                error("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.");
              }
            }
          });
          return content;
        }
        var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=""');
        function pushStartOption(target, props, responseState, formatContext) {
          var selectedValue = formatContext.selectedValue;
          target.push(startChunkForTag("option"));
          var children = null;
          var value = null;
          var selected = null;
          var innerHTML = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "selected":
                  selected = propValue;
                  {
                    if (!didWarnSelectedSetOnOption) {
                      error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.");
                      didWarnSelectedSetOnOption = true;
                    }
                  }
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                case "value":
                  value = propValue;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          if (selectedValue != null) {
            var stringValue;
            if (value !== null) {
              {
                checkAttributeStringCoercion(value, "value");
              }
              stringValue = "" + value;
            } else {
              {
                if (innerHTML !== null) {
                  if (!didWarnInvalidOptionInnerHTML) {
                    didWarnInvalidOptionInnerHTML = true;
                    error("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.");
                  }
                }
              }
              stringValue = flattenOptionChildren(children);
            }
            if (isArray(selectedValue)) {
              for (var i = 0; i < selectedValue.length; i++) {
                {
                  checkAttributeStringCoercion(selectedValue[i], "value");
                }
                var v = "" + selectedValue[i];
                if (v === stringValue) {
                  target.push(selectedMarkerAttribute);
                  break;
                }
              }
            } else {
              {
                checkAttributeStringCoercion(selectedValue, "select.value");
              }
              if ("" + selectedValue === stringValue) {
                target.push(selectedMarkerAttribute);
              }
            }
          } else if (selected) {
            target.push(selectedMarkerAttribute);
          }
          target.push(endOfStartTag);
          pushInnerHTML(target, innerHTML, children);
          return children;
        }
        function pushInput(target, props, responseState) {
          {
            checkControlledValueProps("input", props);
            if (props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnDefaultChecked) {
              error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
              didWarnDefaultChecked = true;
            }
            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultInputValue) {
              error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
              didWarnDefaultInputValue = true;
            }
          }
          target.push(startChunkForTag("input"));
          var value = null;
          var defaultValue = null;
          var checked = null;
          var defaultChecked = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                case "defaultChecked":
                  defaultChecked = propValue;
                  break;
                case "defaultValue":
                  defaultValue = propValue;
                  break;
                case "checked":
                  checked = propValue;
                  break;
                case "value":
                  value = propValue;
                  break;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          if (checked !== null) {
            pushAttribute(target, responseState, "checked", checked);
          } else if (defaultChecked !== null) {
            pushAttribute(target, responseState, "checked", defaultChecked);
          }
          if (value !== null) {
            pushAttribute(target, responseState, "value", value);
          } else if (defaultValue !== null) {
            pushAttribute(target, responseState, "value", defaultValue);
          }
          target.push(endOfStartTagSelfClosing);
          return null;
        }
        function pushStartTextArea(target, props, responseState) {
          {
            checkControlledValueProps("textarea", props);
            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultTextareaValue) {
              error("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components");
              didWarnDefaultTextareaValue = true;
            }
          }
          target.push(startChunkForTag("textarea"));
          var value = null;
          var defaultValue = null;
          var children = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "value":
                  value = propValue;
                  break;
                case "defaultValue":
                  defaultValue = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          if (value === null && defaultValue !== null) {
            value = defaultValue;
          }
          target.push(endOfStartTag);
          if (children != null) {
            {
              error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
            }
            if (value != null) {
              throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            }
            if (isArray(children)) {
              if (children.length > 1) {
                throw new Error("<textarea> can only have at most one child.");
              }
              {
                checkHtmlStringCoercion(children[0]);
              }
              value = "" + children[0];
            }
            {
              checkHtmlStringCoercion(children);
            }
            value = "" + children;
          }
          if (typeof value === "string" && value[0] === "\n") {
            target.push(leadingNewline);
          }
          if (value !== null) {
            {
              checkAttributeStringCoercion(value, "value");
            }
            target.push(stringToChunk(encodeHTMLTextNode("" + value)));
          }
          return null;
        }
        function pushSelfClosing(target, props, tag, responseState) {
          target.push(startChunkForTag(tag));
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw new Error(tag + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTagSelfClosing);
          return null;
        }
        function pushStartMenuItem(target, props, responseState) {
          target.push(startChunkForTag("menuitem"));
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          return null;
        }
        function pushStartTitle(target, props, responseState) {
          target.push(startChunkForTag("title"));
          var children = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          {
            var child = Array.isArray(children) && children.length < 2 ? children[0] || null : children;
            if (Array.isArray(children) && children.length > 1) {
              error("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
            } else if (child != null && child.$$typeof != null) {
              error("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
            } else if (child != null && typeof child !== "string" && typeof child !== "number") {
              error("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
            }
          }
          return children;
        }
        function pushStartGenericElement(target, props, tag, responseState) {
          target.push(startChunkForTag(tag));
          var children = null;
          var innerHTML = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          pushInnerHTML(target, innerHTML, children);
          if (typeof children === "string") {
            target.push(stringToChunk(encodeHTMLTextNode(children)));
            return null;
          }
          return children;
        }
        function pushStartCustomElement(target, props, tag, responseState) {
          target.push(startChunkForTag(tag));
          var children = null;
          var innerHTML = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                case "style":
                  pushStyle(target, responseState, propValue);
                  break;
                case "suppressContentEditableWarning":
                case "suppressHydrationWarning":
                  break;
                default:
                  if (isAttributeNameSafe(propKey) && typeof propValue !== "function" && typeof propValue !== "symbol") {
                    target.push(attributeSeparator, stringToChunk(propKey), attributeAssign, stringToChunk(escapeTextForBrowser(propValue)), attributeEnd);
                  }
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          pushInnerHTML(target, innerHTML, children);
          return children;
        }
        var leadingNewline = stringToPrecomputedChunk("\n");
        function pushStartPreformattedElement(target, props, tag, responseState) {
          target.push(startChunkForTag(tag));
          var children = null;
          var innerHTML = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          if (innerHTML != null) {
            if (children != null) {
              throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
            }
            if (typeof innerHTML !== "object" || !("__html" in innerHTML)) {
              throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
            }
            var html = innerHTML.__html;
            if (html !== null && html !== void 0) {
              if (typeof html === "string" && html.length > 0 && html[0] === "\n") {
                target.push(leadingNewline, stringToChunk(html));
              } else {
                {
                  checkHtmlStringCoercion(html);
                }
                target.push(stringToChunk("" + html));
              }
            }
          }
          if (typeof children === "string" && children[0] === "\n") {
            target.push(leadingNewline);
          }
          return children;
        }
        var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
        var validatedTagCache = /* @__PURE__ */ new Map();
        function startChunkForTag(tag) {
          var tagStartChunk = validatedTagCache.get(tag);
          if (tagStartChunk === void 0) {
            if (!VALID_TAG_REGEX.test(tag)) {
              throw new Error("Invalid tag: " + tag);
            }
            tagStartChunk = stringToPrecomputedChunk("<" + tag);
            validatedTagCache.set(tag, tagStartChunk);
          }
          return tagStartChunk;
        }
        var DOCTYPE = stringToPrecomputedChunk("<!DOCTYPE html>");
        function pushStartInstance(target, type, props, responseState, formatContext) {
          {
            validateProperties(type, props);
            validateProperties$1(type, props);
            validateProperties$2(type, props, null);
            if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
              error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
            }
            if (formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE) {
              if (type.indexOf("-") === -1 && typeof props.is !== "string" && type.toLowerCase() !== type) {
                error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type);
              }
            }
          }
          switch (type) {
            case "select":
              return pushStartSelect(target, props, responseState);
            case "option":
              return pushStartOption(target, props, responseState, formatContext);
            case "textarea":
              return pushStartTextArea(target, props, responseState);
            case "input":
              return pushInput(target, props, responseState);
            case "menuitem":
              return pushStartMenuItem(target, props, responseState);
            case "title":
              return pushStartTitle(target, props, responseState);
            case "listing":
            case "pre": {
              return pushStartPreformattedElement(target, props, type, responseState);
            }
            case "area":
            case "base":
            case "br":
            case "col":
            case "embed":
            case "hr":
            case "img":
            case "keygen":
            case "link":
            case "meta":
            case "param":
            case "source":
            case "track":
            case "wbr": {
              return pushSelfClosing(target, props, type, responseState);
            }
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph": {
              return pushStartGenericElement(target, props, type, responseState);
            }
            case "html": {
              if (formatContext.insertionMode === ROOT_HTML_MODE) {
                target.push(DOCTYPE);
              }
              return pushStartGenericElement(target, props, type, responseState);
            }
            default: {
              if (type.indexOf("-") === -1 && typeof props.is !== "string") {
                return pushStartGenericElement(target, props, type, responseState);
              } else {
                return pushStartCustomElement(target, props, type, responseState);
              }
            }
          }
        }
        var endTag1 = stringToPrecomputedChunk("</");
        var endTag2 = stringToPrecomputedChunk(">");
        function pushEndInstance(target, type, props) {
          switch (type) {
            case "area":
            case "base":
            case "br":
            case "col":
            case "embed":
            case "hr":
            case "img":
            case "input":
            case "keygen":
            case "link":
            case "meta":
            case "param":
            case "source":
            case "track":
            case "wbr": {
              break;
            }
            default: {
              target.push(endTag1, stringToChunk(type), endTag2);
            }
          }
        }
        function writeCompletedRoot(destination, responseState) {
          var bootstrapChunks = responseState.bootstrapChunks;
          var i = 0;
          for (; i < bootstrapChunks.length - 1; i++) {
            writeChunk(destination, bootstrapChunks[i]);
          }
          if (i < bootstrapChunks.length) {
            return writeChunkAndReturn(destination, bootstrapChunks[i]);
          }
          return true;
        }
        var placeholder1 = stringToPrecomputedChunk('<template id="');
        var placeholder2 = stringToPrecomputedChunk('"></template>');
        function writePlaceholder(destination, responseState, id) {
          writeChunk(destination, placeholder1);
          writeChunk(destination, responseState.placeholderPrefix);
          var formattedID = stringToChunk(id.toString(16));
          writeChunk(destination, formattedID);
          return writeChunkAndReturn(destination, placeholder2);
        }
        var startCompletedSuspenseBoundary = stringToPrecomputedChunk("<!--$-->");
        var startPendingSuspenseBoundary1 = stringToPrecomputedChunk('<!--$?--><template id="');
        var startPendingSuspenseBoundary2 = stringToPrecomputedChunk('"></template>');
        var startClientRenderedSuspenseBoundary = stringToPrecomputedChunk("<!--$!-->");
        var endSuspenseBoundary = stringToPrecomputedChunk("<!--/$-->");
        var clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk("<template");
        var clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk('"');
        var clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(' data-dgst="');
        var clientRenderedSuspenseBoundaryError1B = stringToPrecomputedChunk(' data-msg="');
        var clientRenderedSuspenseBoundaryError1C = stringToPrecomputedChunk(' data-stck="');
        var clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk("></template>");
        function writeStartCompletedSuspenseBoundary(destination, responseState) {
          return writeChunkAndReturn(destination, startCompletedSuspenseBoundary);
        }
        function writeStartPendingSuspenseBoundary(destination, responseState, id) {
          writeChunk(destination, startPendingSuspenseBoundary1);
          if (id === null) {
            throw new Error("An ID must have been assigned before we can complete the boundary.");
          }
          writeChunk(destination, id);
          return writeChunkAndReturn(destination, startPendingSuspenseBoundary2);
        }
        function writeStartClientRenderedSuspenseBoundary(destination, responseState, errorDigest, errorMesssage, errorComponentStack) {
          var result;
          result = writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary);
          writeChunk(destination, clientRenderedSuspenseBoundaryError1);
          if (errorDigest) {
            writeChunk(destination, clientRenderedSuspenseBoundaryError1A);
            writeChunk(destination, stringToChunk(escapeTextForBrowser(errorDigest)));
            writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
          }
          {
            if (errorMesssage) {
              writeChunk(destination, clientRenderedSuspenseBoundaryError1B);
              writeChunk(destination, stringToChunk(escapeTextForBrowser(errorMesssage)));
              writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
            }
            if (errorComponentStack) {
              writeChunk(destination, clientRenderedSuspenseBoundaryError1C);
              writeChunk(destination, stringToChunk(escapeTextForBrowser(errorComponentStack)));
              writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
            }
          }
          result = writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2);
          return result;
        }
        function writeEndCompletedSuspenseBoundary(destination, responseState) {
          return writeChunkAndReturn(destination, endSuspenseBoundary);
        }
        function writeEndPendingSuspenseBoundary(destination, responseState) {
          return writeChunkAndReturn(destination, endSuspenseBoundary);
        }
        function writeEndClientRenderedSuspenseBoundary(destination, responseState) {
          return writeChunkAndReturn(destination, endSuspenseBoundary);
        }
        var startSegmentHTML = stringToPrecomputedChunk('<div hidden id="');
        var startSegmentHTML2 = stringToPrecomputedChunk('">');
        var endSegmentHTML = stringToPrecomputedChunk("</div>");
        var startSegmentSVG = stringToPrecomputedChunk('<svg aria-hidden="true" style="display:none" id="');
        var startSegmentSVG2 = stringToPrecomputedChunk('">');
        var endSegmentSVG = stringToPrecomputedChunk("</svg>");
        var startSegmentMathML = stringToPrecomputedChunk('<math aria-hidden="true" style="display:none" id="');
        var startSegmentMathML2 = stringToPrecomputedChunk('">');
        var endSegmentMathML = stringToPrecomputedChunk("</math>");
        var startSegmentTable = stringToPrecomputedChunk('<table hidden id="');
        var startSegmentTable2 = stringToPrecomputedChunk('">');
        var endSegmentTable = stringToPrecomputedChunk("</table>");
        var startSegmentTableBody = stringToPrecomputedChunk('<table hidden><tbody id="');
        var startSegmentTableBody2 = stringToPrecomputedChunk('">');
        var endSegmentTableBody = stringToPrecomputedChunk("</tbody></table>");
        var startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id="');
        var startSegmentTableRow2 = stringToPrecomputedChunk('">');
        var endSegmentTableRow = stringToPrecomputedChunk("</tr></table>");
        var startSegmentColGroup = stringToPrecomputedChunk('<table hidden><colgroup id="');
        var startSegmentColGroup2 = stringToPrecomputedChunk('">');
        var endSegmentColGroup = stringToPrecomputedChunk("</colgroup></table>");
        function writeStartSegment(destination, responseState, formatContext, id) {
          switch (formatContext.insertionMode) {
            case ROOT_HTML_MODE:
            case HTML_MODE: {
              writeChunk(destination, startSegmentHTML);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentHTML2);
            }
            case SVG_MODE: {
              writeChunk(destination, startSegmentSVG);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentSVG2);
            }
            case MATHML_MODE: {
              writeChunk(destination, startSegmentMathML);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentMathML2);
            }
            case HTML_TABLE_MODE: {
              writeChunk(destination, startSegmentTable);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentTable2);
            }
            case HTML_TABLE_BODY_MODE: {
              writeChunk(destination, startSegmentTableBody);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentTableBody2);
            }
            case HTML_TABLE_ROW_MODE: {
              writeChunk(destination, startSegmentTableRow);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentTableRow2);
            }
            case HTML_COLGROUP_MODE: {
              writeChunk(destination, startSegmentColGroup);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentColGroup2);
            }
            default: {
              throw new Error("Unknown insertion mode. This is a bug in React.");
            }
          }
        }
        function writeEndSegment(destination, formatContext) {
          switch (formatContext.insertionMode) {
            case ROOT_HTML_MODE:
            case HTML_MODE: {
              return writeChunkAndReturn(destination, endSegmentHTML);
            }
            case SVG_MODE: {
              return writeChunkAndReturn(destination, endSegmentSVG);
            }
            case MATHML_MODE: {
              return writeChunkAndReturn(destination, endSegmentMathML);
            }
            case HTML_TABLE_MODE: {
              return writeChunkAndReturn(destination, endSegmentTable);
            }
            case HTML_TABLE_BODY_MODE: {
              return writeChunkAndReturn(destination, endSegmentTableBody);
            }
            case HTML_TABLE_ROW_MODE: {
              return writeChunkAndReturn(destination, endSegmentTableRow);
            }
            case HTML_COLGROUP_MODE: {
              return writeChunkAndReturn(destination, endSegmentColGroup);
            }
            default: {
              throw new Error("Unknown insertion mode. This is a bug in React.");
            }
          }
        }
        var completeSegmentFunction = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}";
        var completeBoundaryFunction = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}';
        var clientRenderFunction = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}';
        var completeSegmentScript1Full = stringToPrecomputedChunk(completeSegmentFunction + ';$RS("');
        var completeSegmentScript1Partial = stringToPrecomputedChunk('$RS("');
        var completeSegmentScript2 = stringToPrecomputedChunk('","');
        var completeSegmentScript3 = stringToPrecomputedChunk('")<\/script>');
        function writeCompletedSegmentInstruction(destination, responseState, contentSegmentID) {
          writeChunk(destination, responseState.startInlineScript);
          if (!responseState.sentCompleteSegmentFunction) {
            responseState.sentCompleteSegmentFunction = true;
            writeChunk(destination, completeSegmentScript1Full);
          } else {
            writeChunk(destination, completeSegmentScript1Partial);
          }
          writeChunk(destination, responseState.segmentPrefix);
          var formattedID = stringToChunk(contentSegmentID.toString(16));
          writeChunk(destination, formattedID);
          writeChunk(destination, completeSegmentScript2);
          writeChunk(destination, responseState.placeholderPrefix);
          writeChunk(destination, formattedID);
          return writeChunkAndReturn(destination, completeSegmentScript3);
        }
        var completeBoundaryScript1Full = stringToPrecomputedChunk(completeBoundaryFunction + ';$RC("');
        var completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC("');
        var completeBoundaryScript2 = stringToPrecomputedChunk('","');
        var completeBoundaryScript3 = stringToPrecomputedChunk('")<\/script>');
        function writeCompletedBoundaryInstruction(destination, responseState, boundaryID, contentSegmentID) {
          writeChunk(destination, responseState.startInlineScript);
          if (!responseState.sentCompleteBoundaryFunction) {
            responseState.sentCompleteBoundaryFunction = true;
            writeChunk(destination, completeBoundaryScript1Full);
          } else {
            writeChunk(destination, completeBoundaryScript1Partial);
          }
          if (boundaryID === null) {
            throw new Error("An ID must have been assigned before we can complete the boundary.");
          }
          var formattedContentID = stringToChunk(contentSegmentID.toString(16));
          writeChunk(destination, boundaryID);
          writeChunk(destination, completeBoundaryScript2);
          writeChunk(destination, responseState.segmentPrefix);
          writeChunk(destination, formattedContentID);
          return writeChunkAndReturn(destination, completeBoundaryScript3);
        }
        var clientRenderScript1Full = stringToPrecomputedChunk(clientRenderFunction + ';$RX("');
        var clientRenderScript1Partial = stringToPrecomputedChunk('$RX("');
        var clientRenderScript1A = stringToPrecomputedChunk('"');
        var clientRenderScript2 = stringToPrecomputedChunk(")<\/script>");
        var clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(",");
        function writeClientRenderBoundaryInstruction(destination, responseState, boundaryID, errorDigest, errorMessage, errorComponentStack) {
          writeChunk(destination, responseState.startInlineScript);
          if (!responseState.sentClientRenderFunction) {
            responseState.sentClientRenderFunction = true;
            writeChunk(destination, clientRenderScript1Full);
          } else {
            writeChunk(destination, clientRenderScript1Partial);
          }
          if (boundaryID === null) {
            throw new Error("An ID must have been assigned before we can complete the boundary.");
          }
          writeChunk(destination, boundaryID);
          writeChunk(destination, clientRenderScript1A);
          if (errorDigest || errorMessage || errorComponentStack) {
            writeChunk(destination, clientRenderErrorScriptArgInterstitial);
            writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorDigest || "")));
          }
          if (errorMessage || errorComponentStack) {
            writeChunk(destination, clientRenderErrorScriptArgInterstitial);
            writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorMessage || "")));
          }
          if (errorComponentStack) {
            writeChunk(destination, clientRenderErrorScriptArgInterstitial);
            writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorComponentStack)));
          }
          return writeChunkAndReturn(destination, clientRenderScript2);
        }
        var regexForJSStringsInScripts = /[<\u2028\u2029]/g;
        function escapeJSStringsForInstructionScripts(input) {
          var escaped = JSON.stringify(input);
          return escaped.replace(regexForJSStringsInScripts, function(match) {
            switch (match) {
              case "<":
                return "\\u003c";
              case "\u2028":
                return "\\u2028";
              case "\u2029":
                return "\\u2029";
              default: {
                throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
              }
            }
          });
        }
        var assign = Object.assign;
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_SCOPE_TYPE = Symbol.for("react.scope");
        var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode");
        var REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
        var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for("react.default_value");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName;
          if (displayName) {
            return displayName;
          }
          var functionName = innerType.displayName || innerType.name || "";
          return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentNameFromType(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                var outerName = type.displayName || null;
                if (outerName !== null) {
                  return outerName;
                }
                return getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return getComponentNameFromType(init(payload));
                } catch (x) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: assign({}, props, {
                  value: prevLog
                }),
                info: assign({}, props, {
                  value: prevInfo
                }),
                warn: assign({}, props, {
                  value: prevWarn
                }),
                error: assign({}, props, {
                  value: prevError
                }),
                group: assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x) {
                var match = x.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x) {
                  control = x;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x) {
                control = x;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s = sampleLines.length - 1;
              var c = controlLines.length - 1;
              while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                c--;
              }
              for (; s >= 1 && c >= 0; s--, c--) {
                if (sampleLines[s] !== controlLines[c]) {
                  if (s !== 1 || c !== 1) {
                    do {
                      s--;
                      c--;
                      if (c < 0 || sampleLines[s] !== controlLines[c]) {
                        var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                        if (fn.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn.displayName);
                        }
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s >= 1 && c >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeClassComponentFrame(ctor, source, ownerFn) {
          {
            return describeNativeComponentFrame(ctor, true);
          }
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component) {
          var prototype = Component.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x) {
                }
              }
            }
          }
          return "";
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
          {
            var has = Function.call.bind(hasOwnProperty);
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        var warnedAboutMissingGetChildContext;
        {
          warnedAboutMissingGetChildContext = {};
        }
        var emptyContextObject = {};
        {
          Object.freeze(emptyContextObject);
        }
        function getMaskedContext(type, unmaskedContext) {
          {
            var contextTypes = type.contextTypes;
            if (!contextTypes) {
              return emptyContextObject;
            }
            var context = {};
            for (var key in contextTypes) {
              context[key] = unmaskedContext[key];
            }
            {
              var name = getComponentNameFromType(type) || "Unknown";
              checkPropTypes(contextTypes, context, "context", name);
            }
            return context;
          }
        }
        function processChildContext(instance, type, parentContext, childContextTypes) {
          {
            if (typeof instance.getChildContext !== "function") {
              {
                var componentName = getComponentNameFromType(type) || "Unknown";
                if (!warnedAboutMissingGetChildContext[componentName]) {
                  warnedAboutMissingGetChildContext[componentName] = true;
                  error("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
                }
              }
              return parentContext;
            }
            var childContext = instance.getChildContext();
            for (var contextKey in childContext) {
              if (!(contextKey in childContextTypes)) {
                throw new Error((getComponentNameFromType(type) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
              }
            }
            {
              var name = getComponentNameFromType(type) || "Unknown";
              checkPropTypes(childContextTypes, childContext, "child context", name);
            }
            return assign({}, parentContext, childContext);
          }
        }
        var rendererSigil;
        {
          rendererSigil = {};
        }
        var rootContextSnapshot = null;
        var currentActiveSnapshot = null;
        function popNode(prev) {
          {
            prev.context._currentValue = prev.parentValue;
          }
        }
        function pushNode(next) {
          {
            next.context._currentValue = next.value;
          }
        }
        function popToNearestCommonAncestor(prev, next) {
          if (prev === next)
            ;
          else {
            popNode(prev);
            var parentPrev = prev.parent;
            var parentNext = next.parent;
            if (parentPrev === null) {
              if (parentNext !== null) {
                throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
              }
            } else {
              if (parentNext === null) {
                throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
              }
              popToNearestCommonAncestor(parentPrev, parentNext);
            }
            pushNode(next);
          }
        }
        function popAllPrevious(prev) {
          popNode(prev);
          var parentPrev = prev.parent;
          if (parentPrev !== null) {
            popAllPrevious(parentPrev);
          }
        }
        function pushAllNext(next) {
          var parentNext = next.parent;
          if (parentNext !== null) {
            pushAllNext(parentNext);
          }
          pushNode(next);
        }
        function popPreviousToCommonLevel(prev, next) {
          popNode(prev);
          var parentPrev = prev.parent;
          if (parentPrev === null) {
            throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
          }
          if (parentPrev.depth === next.depth) {
            popToNearestCommonAncestor(parentPrev, next);
          } else {
            popPreviousToCommonLevel(parentPrev, next);
          }
        }
        function popNextToCommonLevel(prev, next) {
          var parentNext = next.parent;
          if (parentNext === null) {
            throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
          }
          if (prev.depth === parentNext.depth) {
            popToNearestCommonAncestor(prev, parentNext);
          } else {
            popNextToCommonLevel(prev, parentNext);
          }
          pushNode(next);
        }
        function switchContext(newSnapshot) {
          var prev = currentActiveSnapshot;
          var next = newSnapshot;
          if (prev !== next) {
            if (prev === null) {
              pushAllNext(next);
            } else if (next === null) {
              popAllPrevious(prev);
            } else if (prev.depth === next.depth) {
              popToNearestCommonAncestor(prev, next);
            } else if (prev.depth > next.depth) {
              popPreviousToCommonLevel(prev, next);
            } else {
              popNextToCommonLevel(prev, next);
            }
            currentActiveSnapshot = next;
          }
        }
        function pushProvider(context, nextValue) {
          var prevValue;
          {
            prevValue = context._currentValue;
            context._currentValue = nextValue;
            {
              if (context._currentRenderer !== void 0 && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
                error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
              }
              context._currentRenderer = rendererSigil;
            }
          }
          var prevNode = currentActiveSnapshot;
          var newNode = {
            parent: prevNode,
            depth: prevNode === null ? 0 : prevNode.depth + 1,
            context,
            parentValue: prevValue,
            value: nextValue
          };
          currentActiveSnapshot = newNode;
          return newNode;
        }
        function popProvider(context) {
          var prevSnapshot = currentActiveSnapshot;
          if (prevSnapshot === null) {
            throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
          }
          {
            if (prevSnapshot.context !== context) {
              error("The parent context is not the expected context. This is probably a bug in React.");
            }
          }
          {
            var value = prevSnapshot.parentValue;
            if (value === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {
              prevSnapshot.context._currentValue = prevSnapshot.context._defaultValue;
            } else {
              prevSnapshot.context._currentValue = value;
            }
            {
              if (context._currentRenderer !== void 0 && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
                error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
              }
              context._currentRenderer = rendererSigil;
            }
          }
          return currentActiveSnapshot = prevSnapshot.parent;
        }
        function getActiveContext() {
          return currentActiveSnapshot;
        }
        function readContext(context) {
          var value = context._currentValue;
          return value;
        }
        function get(key) {
          return key._reactInternals;
        }
        function set(key, value) {
          key._reactInternals = value;
        }
        var didWarnAboutNoopUpdateForComponent = {};
        var didWarnAboutDeprecatedWillMount = {};
        var didWarnAboutUninitializedState;
        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
        var didWarnAboutLegacyLifecyclesAndDerivedState;
        var didWarnAboutUndefinedDerivedState;
        var warnOnUndefinedDerivedState;
        var warnOnInvalidCallback;
        var didWarnAboutDirectlyAssigningPropsToState;
        var didWarnAboutContextTypeAndContextTypes;
        var didWarnAboutInvalidateContextType;
        {
          didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
          didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
          didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
          didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
          didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
          didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set();
          didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
          var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
          warnOnInvalidCallback = function(callback, callerName) {
            if (callback === null || typeof callback === "function") {
              return;
            }
            var key = callerName + "_" + callback;
            if (!didWarnOnInvalidCallback.has(key)) {
              didWarnOnInvalidCallback.add(key);
              error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
            }
          };
          warnOnUndefinedDerivedState = function(type, partialState) {
            if (partialState === void 0) {
              var componentName = getComponentNameFromType(type) || "Component";
              if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
                didWarnAboutUndefinedDerivedState.add(componentName);
                error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
              }
            }
          };
        }
        function warnNoop(publicInstance, callerName) {
          {
            var _constructor = publicInstance.constructor;
            var componentName = _constructor && getComponentNameFromType(_constructor) || "ReactClass";
            var warningKey = componentName + "." + callerName;
            if (didWarnAboutNoopUpdateForComponent[warningKey]) {
              return;
            }
            error("%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\n\nPlease check the code for the %s component.", callerName, callerName, componentName);
            didWarnAboutNoopUpdateForComponent[warningKey] = true;
          }
        }
        var classComponentUpdater = {
          isMounted: function(inst) {
            return false;
          },
          enqueueSetState: function(inst, payload, callback) {
            var internals = get(inst);
            if (internals.queue === null) {
              warnNoop(inst, "setState");
            } else {
              internals.queue.push(payload);
              {
                if (callback !== void 0 && callback !== null) {
                  warnOnInvalidCallback(callback, "setState");
                }
              }
            }
          },
          enqueueReplaceState: function(inst, payload, callback) {
            var internals = get(inst);
            internals.replace = true;
            internals.queue = [payload];
            {
              if (callback !== void 0 && callback !== null) {
                warnOnInvalidCallback(callback, "setState");
              }
            }
          },
          enqueueForceUpdate: function(inst, callback) {
            var internals = get(inst);
            if (internals.queue === null) {
              warnNoop(inst, "forceUpdate");
            } else {
              {
                if (callback !== void 0 && callback !== null) {
                  warnOnInvalidCallback(callback, "setState");
                }
              }
            }
          }
        };
        function applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, prevState, nextProps) {
          var partialState = getDerivedStateFromProps(nextProps, prevState);
          {
            warnOnUndefinedDerivedState(ctor, partialState);
          }
          var newState = partialState === null || partialState === void 0 ? prevState : assign({}, prevState, partialState);
          return newState;
        }
        function constructClassInstance(ctor, props, maskedLegacyContext) {
          var context = emptyContextObject;
          var contextType = ctor.contextType;
          {
            if ("contextType" in ctor) {
              var isValid = (
                // Allow null for conditional declaration
                contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0
              );
              if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
                didWarnAboutInvalidateContextType.add(ctor);
                var addendum = "";
                if (contextType === void 0) {
                  addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
                } else if (typeof contextType !== "object") {
                  addendum = " However, it is set to a " + typeof contextType + ".";
                } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                  addendum = " Did you accidentally pass the Context.Provider instead?";
                } else if (contextType._context !== void 0) {
                  addendum = " Did you accidentally pass the Context.Consumer instead?";
                } else {
                  addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
                }
                error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
              }
            }
          }
          if (typeof contextType === "object" && contextType !== null) {
            context = readContext(contextType);
          } else {
            context = maskedLegacyContext;
          }
          var instance = new ctor(props, context);
          {
            if (typeof ctor.getDerivedStateFromProps === "function" && (instance.state === null || instance.state === void 0)) {
              var componentName = getComponentNameFromType(ctor) || "Component";
              if (!didWarnAboutUninitializedState.has(componentName)) {
                didWarnAboutUninitializedState.add(componentName);
                error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
              }
            }
            if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
              var foundWillMountName = null;
              var foundWillReceivePropsName = null;
              var foundWillUpdateName = null;
              if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
                foundWillMountName = "componentWillMount";
              } else if (typeof instance.UNSAFE_componentWillMount === "function") {
                foundWillMountName = "UNSAFE_componentWillMount";
              }
              if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                foundWillReceivePropsName = "componentWillReceiveProps";
              } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
                foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
              }
              if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                foundWillUpdateName = "componentWillUpdate";
              } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                foundWillUpdateName = "UNSAFE_componentWillUpdate";
              }
              if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
                var _componentName = getComponentNameFromType(ctor) || "Component";
                var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                  didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                  error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
                }
              }
            }
          }
          return instance;
        }
        function checkClassInstance(instance, ctor, newProps) {
          {
            var name = getComponentNameFromType(ctor) || "Component";
            var renderPresent = instance.render;
            if (!renderPresent) {
              if (ctor.prototype && typeof ctor.prototype.render === "function") {
                error("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name);
              } else {
                error("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name);
              }
            }
            if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
              error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name);
            }
            if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name);
            }
            if (instance.propTypes) {
              error("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name);
            }
            if (instance.contextType) {
              error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name);
            }
            {
              if (instance.contextTypes) {
                error("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name);
              }
              if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
                didWarnAboutContextTypeAndContextTypes.add(ctor);
                error("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name);
              }
            }
            if (typeof instance.componentShouldUpdate === "function") {
              error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name);
            }
            if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
              error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component");
            }
            if (typeof instance.componentDidUnmount === "function") {
              error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name);
            }
            if (typeof instance.componentDidReceiveProps === "function") {
              error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name);
            }
            if (typeof instance.componentWillRecieveProps === "function") {
              error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name);
            }
            if (typeof instance.UNSAFE_componentWillRecieveProps === "function") {
              error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name);
            }
            var hasMutatedProps = instance.props !== newProps;
            if (instance.props !== void 0 && hasMutatedProps) {
              error("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name, name);
            }
            if (instance.defaultProps) {
              error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name, name);
            }
            if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
              didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
              error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor));
            }
            if (typeof instance.getDerivedStateFromProps === "function") {
              error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
            }
            if (typeof instance.getDerivedStateFromError === "function") {
              error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
            }
            if (typeof ctor.getSnapshotBeforeUpdate === "function") {
              error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name);
            }
            var _state = instance.state;
            if (_state && (typeof _state !== "object" || isArray(_state))) {
              error("%s.state: must be set to an object or null", name);
            }
            if (typeof instance.getChildContext === "function" && typeof ctor.childContextTypes !== "object") {
              error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name);
            }
          }
        }
        function callComponentWillMount(type, instance) {
          var oldState = instance.state;
          if (typeof instance.componentWillMount === "function") {
            {
              if (instance.componentWillMount.__suppressDeprecationWarning !== true) {
                var componentName = getComponentNameFromType(type) || "Unknown";
                if (!didWarnAboutDeprecatedWillMount[componentName]) {
                  warn(
                    // keep this warning in sync with ReactStrictModeWarning.js
                    "componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\n\nPlease update the following components: %s",
                    componentName
                  );
                  didWarnAboutDeprecatedWillMount[componentName] = true;
                }
              }
            }
            instance.componentWillMount();
          }
          if (typeof instance.UNSAFE_componentWillMount === "function") {
            instance.UNSAFE_componentWillMount();
          }
          if (oldState !== instance.state) {
            {
              error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromType(type) || "Component");
            }
            classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
          }
        }
        function processUpdateQueue(internalInstance, inst, props, maskedLegacyContext) {
          if (internalInstance.queue !== null && internalInstance.queue.length > 0) {
            var oldQueue = internalInstance.queue;
            var oldReplace = internalInstance.replace;
            internalInstance.queue = null;
            internalInstance.replace = false;
            if (oldReplace && oldQueue.length === 1) {
              inst.state = oldQueue[0];
            } else {
              var nextState = oldReplace ? oldQueue[0] : inst.state;
              var dontMutate = true;
              for (var i = oldReplace ? 1 : 0; i < oldQueue.length; i++) {
                var partial = oldQueue[i];
                var partialState = typeof partial === "function" ? partial.call(inst, nextState, props, maskedLegacyContext) : partial;
                if (partialState != null) {
                  if (dontMutate) {
                    dontMutate = false;
                    nextState = assign({}, nextState, partialState);
                  } else {
                    assign(nextState, partialState);
                  }
                }
              }
              inst.state = nextState;
            }
          } else {
            internalInstance.queue = null;
          }
        }
        function mountClassInstance(instance, ctor, newProps, maskedLegacyContext) {
          {
            checkClassInstance(instance, ctor, newProps);
          }
          var initialState = instance.state !== void 0 ? instance.state : null;
          instance.updater = classComponentUpdater;
          instance.props = newProps;
          instance.state = initialState;
          var internalInstance = {
            queue: [],
            replace: false
          };
          set(instance, internalInstance);
          var contextType = ctor.contextType;
          if (typeof contextType === "object" && contextType !== null) {
            instance.context = readContext(contextType);
          } else {
            instance.context = maskedLegacyContext;
          }
          {
            if (instance.state === newProps) {
              var componentName = getComponentNameFromType(ctor) || "Component";
              if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
                didWarnAboutDirectlyAssigningPropsToState.add(componentName);
                error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
              }
            }
          }
          var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
          if (typeof getDerivedStateFromProps === "function") {
            instance.state = applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, initialState, newProps);
          }
          if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
            callComponentWillMount(ctor, instance);
            processUpdateQueue(internalInstance, instance, newProps, maskedLegacyContext);
          }
        }
        var emptyTreeContext = {
          id: 1,
          overflow: ""
        };
        function getTreeId(context) {
          var overflow = context.overflow;
          var idWithLeadingBit = context.id;
          var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
          return id.toString(32) + overflow;
        }
        function pushTreeContext(baseContext, totalChildren, index) {
          var baseIdWithLeadingBit = baseContext.id;
          var baseOverflow = baseContext.overflow;
          var baseLength = getBitLength(baseIdWithLeadingBit) - 1;
          var baseId = baseIdWithLeadingBit & ~(1 << baseLength);
          var slot = index + 1;
          var length = getBitLength(totalChildren) + baseLength;
          if (length > 30) {
            var numberOfOverflowBits = baseLength - baseLength % 5;
            var newOverflowBits = (1 << numberOfOverflowBits) - 1;
            var newOverflow = (baseId & newOverflowBits).toString(32);
            var restOfBaseId = baseId >> numberOfOverflowBits;
            var restOfBaseLength = baseLength - numberOfOverflowBits;
            var restOfLength = getBitLength(totalChildren) + restOfBaseLength;
            var restOfNewBits = slot << restOfBaseLength;
            var id = restOfNewBits | restOfBaseId;
            var overflow = newOverflow + baseOverflow;
            return {
              id: 1 << restOfLength | id,
              overflow
            };
          } else {
            var newBits = slot << baseLength;
            var _id = newBits | baseId;
            var _overflow = baseOverflow;
            return {
              id: 1 << length | _id,
              overflow: _overflow
            };
          }
        }
        function getBitLength(number) {
          return 32 - clz32(number);
        }
        function getLeadingBit(id) {
          return 1 << getBitLength(id) - 1;
        }
        var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
        var log = Math.log;
        var LN2 = Math.LN2;
        function clz32Fallback(x) {
          var asUint = x >>> 0;
          if (asUint === 0) {
            return 32;
          }
          return 31 - (log(asUint) / LN2 | 0) | 0;
        }
        function is(x, y) {
          return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        var currentlyRenderingComponent = null;
        var currentlyRenderingTask = null;
        var firstWorkInProgressHook = null;
        var workInProgressHook = null;
        var isReRender = false;
        var didScheduleRenderPhaseUpdate = false;
        var localIdCounter = 0;
        var renderPhaseUpdates = null;
        var numberOfReRenders = 0;
        var RE_RENDER_LIMIT = 25;
        var isInHookUserCodeInDev = false;
        var currentHookNameInDev;
        function resolveCurrentlyRenderingComponent() {
          if (currentlyRenderingComponent === null) {
            throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
          }
          {
            if (isInHookUserCodeInDev) {
              error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
            }
          }
          return currentlyRenderingComponent;
        }
        function areHookInputsEqual(nextDeps, prevDeps) {
          if (prevDeps === null) {
            {
              error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
            }
            return false;
          }
          {
            if (nextDeps.length !== prevDeps.length) {
              error("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + nextDeps.join(", ") + "]", "[" + prevDeps.join(", ") + "]");
            }
          }
          for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
            if (objectIs(nextDeps[i], prevDeps[i])) {
              continue;
            }
            return false;
          }
          return true;
        }
        function createHook() {
          if (numberOfReRenders > 0) {
            throw new Error("Rendered more hooks than during the previous render");
          }
          return {
            memoizedState: null,
            queue: null,
            next: null
          };
        }
        function createWorkInProgressHook() {
          if (workInProgressHook === null) {
            if (firstWorkInProgressHook === null) {
              isReRender = false;
              firstWorkInProgressHook = workInProgressHook = createHook();
            } else {
              isReRender = true;
              workInProgressHook = firstWorkInProgressHook;
            }
          } else {
            if (workInProgressHook.next === null) {
              isReRender = false;
              workInProgressHook = workInProgressHook.next = createHook();
            } else {
              isReRender = true;
              workInProgressHook = workInProgressHook.next;
            }
          }
          return workInProgressHook;
        }
        function prepareToUseHooks(task, componentIdentity) {
          currentlyRenderingComponent = componentIdentity;
          currentlyRenderingTask = task;
          {
            isInHookUserCodeInDev = false;
          }
          localIdCounter = 0;
        }
        function finishHooks(Component, props, children, refOrContext) {
          while (didScheduleRenderPhaseUpdate) {
            didScheduleRenderPhaseUpdate = false;
            localIdCounter = 0;
            numberOfReRenders += 1;
            workInProgressHook = null;
            children = Component(props, refOrContext);
          }
          resetHooksState();
          return children;
        }
        function checkDidRenderIdHook() {
          var didRenderIdHook = localIdCounter !== 0;
          return didRenderIdHook;
        }
        function resetHooksState() {
          {
            isInHookUserCodeInDev = false;
          }
          currentlyRenderingComponent = null;
          currentlyRenderingTask = null;
          didScheduleRenderPhaseUpdate = false;
          firstWorkInProgressHook = null;
          numberOfReRenders = 0;
          renderPhaseUpdates = null;
          workInProgressHook = null;
        }
        function readContext$1(context) {
          {
            if (isInHookUserCodeInDev) {
              error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
            }
          }
          return readContext(context);
        }
        function useContext(context) {
          {
            currentHookNameInDev = "useContext";
          }
          resolveCurrentlyRenderingComponent();
          return readContext(context);
        }
        function basicStateReducer(state, action) {
          return typeof action === "function" ? action(state) : action;
        }
        function useState(initialState) {
          {
            currentHookNameInDev = "useState";
          }
          return useReducer(
            basicStateReducer,
            // useReducer has a special case to support lazy useState initializers
            initialState
          );
        }
        function useReducer(reducer, initialArg, init) {
          {
            if (reducer !== basicStateReducer) {
              currentHookNameInDev = "useReducer";
            }
          }
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          if (isReRender) {
            var queue = workInProgressHook.queue;
            var dispatch = queue.dispatch;
            if (renderPhaseUpdates !== null) {
              var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
              if (firstRenderPhaseUpdate !== void 0) {
                renderPhaseUpdates.delete(queue);
                var newState = workInProgressHook.memoizedState;
                var update = firstRenderPhaseUpdate;
                do {
                  var action = update.action;
                  {
                    isInHookUserCodeInDev = true;
                  }
                  newState = reducer(newState, action);
                  {
                    isInHookUserCodeInDev = false;
                  }
                  update = update.next;
                } while (update !== null);
                workInProgressHook.memoizedState = newState;
                return [newState, dispatch];
              }
            }
            return [workInProgressHook.memoizedState, dispatch];
          } else {
            {
              isInHookUserCodeInDev = true;
            }
            var initialState;
            if (reducer === basicStateReducer) {
              initialState = typeof initialArg === "function" ? initialArg() : initialArg;
            } else {
              initialState = init !== void 0 ? init(initialArg) : initialArg;
            }
            {
              isInHookUserCodeInDev = false;
            }
            workInProgressHook.memoizedState = initialState;
            var _queue = workInProgressHook.queue = {
              last: null,
              dispatch: null
            };
            var _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue);
            return [workInProgressHook.memoizedState, _dispatch];
          }
        }
        function useMemo(nextCreate, deps) {
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          if (workInProgressHook !== null) {
            var prevState = workInProgressHook.memoizedState;
            if (prevState !== null) {
              if (nextDeps !== null) {
                var prevDeps = prevState[1];
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  return prevState[0];
                }
              }
            }
          }
          {
            isInHookUserCodeInDev = true;
          }
          var nextValue = nextCreate();
          {
            isInHookUserCodeInDev = false;
          }
          workInProgressHook.memoizedState = [nextValue, nextDeps];
          return nextValue;
        }
        function useRef(initialValue) {
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          var previousRef = workInProgressHook.memoizedState;
          if (previousRef === null) {
            var ref = {
              current: initialValue
            };
            {
              Object.seal(ref);
            }
            workInProgressHook.memoizedState = ref;
            return ref;
          } else {
            return previousRef;
          }
        }
        function useLayoutEffect(create, inputs) {
          {
            currentHookNameInDev = "useLayoutEffect";
            error("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
          }
        }
        function dispatchAction(componentIdentity, queue, action) {
          if (numberOfReRenders >= RE_RENDER_LIMIT) {
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          }
          if (componentIdentity === currentlyRenderingComponent) {
            didScheduleRenderPhaseUpdate = true;
            var update = {
              action,
              next: null
            };
            if (renderPhaseUpdates === null) {
              renderPhaseUpdates = /* @__PURE__ */ new Map();
            }
            var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
            if (firstRenderPhaseUpdate === void 0) {
              renderPhaseUpdates.set(queue, update);
            } else {
              var lastRenderPhaseUpdate = firstRenderPhaseUpdate;
              while (lastRenderPhaseUpdate.next !== null) {
                lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
              }
              lastRenderPhaseUpdate.next = update;
            }
          }
        }
        function useCallback(callback, deps) {
          return useMemo(function() {
            return callback;
          }, deps);
        }
        function useMutableSource(source, getSnapshot, subscribe) {
          resolveCurrentlyRenderingComponent();
          return getSnapshot(source._source);
        }
        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          if (getServerSnapshot === void 0) {
            throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
          }
          return getServerSnapshot();
        }
        function useDeferredValue(value) {
          resolveCurrentlyRenderingComponent();
          return value;
        }
        function unsupportedStartTransition() {
          throw new Error("startTransition cannot be called during server rendering.");
        }
        function useTransition() {
          resolveCurrentlyRenderingComponent();
          return [false, unsupportedStartTransition];
        }
        function useId() {
          var task = currentlyRenderingTask;
          var treeId = getTreeId(task.treeContext);
          var responseState = currentResponseState;
          if (responseState === null) {
            throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
          }
          var localId = localIdCounter++;
          return makeId(responseState, treeId, localId);
        }
        function noop() {
        }
        var Dispatcher = {
          readContext: readContext$1,
          useContext,
          useMemo,
          useReducer,
          useRef,
          useState,
          useInsertionEffect: noop,
          useLayoutEffect,
          useCallback,
          // useImperativeHandle is not run in the server environment
          useImperativeHandle: noop,
          // Effects are not run in the server environment.
          useEffect: noop,
          // Debugging effect
          useDebugValue: noop,
          useDeferredValue,
          useTransition,
          useId,
          // Subscriptions are not setup in a server environment.
          useMutableSource,
          useSyncExternalStore
        };
        var currentResponseState = null;
        function setCurrentResponseState(responseState) {
          currentResponseState = responseState;
        }
        function getStackByComponentStackNode(componentStack) {
          try {
            var info = "";
            var node = componentStack;
            do {
              switch (node.tag) {
                case 0:
                  info += describeBuiltInComponentFrame(node.type, null, null);
                  break;
                case 1:
                  info += describeFunctionComponentFrame(node.type, null, null);
                  break;
                case 2:
                  info += describeClassComponentFrame(node.type, null, null);
                  break;
              }
              node = node.parent;
            } while (node);
            return info;
          } catch (x) {
            return "\nError generating stack: " + x.message + "\n" + x.stack;
          }
        }
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        var PENDING = 0;
        var COMPLETED = 1;
        var FLUSHED = 2;
        var ABORTED = 3;
        var ERRORED = 4;
        var OPEN = 0;
        var CLOSING = 1;
        var CLOSED = 2;
        var DEFAULT_PROGRESSIVE_CHUNK_SIZE = 12800;
        function defaultErrorHandler(error2) {
          console["error"](error2);
          return null;
        }
        function noop$1() {
        }
        function createRequest(children, responseState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError) {
          var pingedTasks = [];
          var abortSet = /* @__PURE__ */ new Set();
          var request = {
            destination: null,
            responseState,
            progressiveChunkSize: progressiveChunkSize === void 0 ? DEFAULT_PROGRESSIVE_CHUNK_SIZE : progressiveChunkSize,
            status: OPEN,
            fatalError: null,
            nextSegmentId: 0,
            allPendingTasks: 0,
            pendingRootTasks: 0,
            completedRootSegment: null,
            abortableTasks: abortSet,
            pingedTasks,
            clientRenderedBoundaries: [],
            completedBoundaries: [],
            partialBoundaries: [],
            onError: onError === void 0 ? defaultErrorHandler : onError,
            onAllReady: onAllReady === void 0 ? noop$1 : onAllReady,
            onShellReady: onShellReady === void 0 ? noop$1 : onShellReady,
            onShellError: onShellError === void 0 ? noop$1 : onShellError,
            onFatalError: onFatalError === void 0 ? noop$1 : onFatalError
          };
          var rootSegment = createPendingSegment(
            request,
            0,
            null,
            rootFormatContext,
            // Root segments are never embedded in Text on either edge
            false,
            false
          );
          rootSegment.parentFlushed = true;
          var rootTask = createTask(request, children, null, rootSegment, abortSet, emptyContextObject, rootContextSnapshot, emptyTreeContext);
          pingedTasks.push(rootTask);
          return request;
        }
        function pingTask(request, task) {
          var pingedTasks = request.pingedTasks;
          pingedTasks.push(task);
          if (pingedTasks.length === 1) {
            scheduleWork(function() {
              return performWork(request);
            });
          }
        }
        function createSuspenseBoundary(request, fallbackAbortableTasks) {
          return {
            id: UNINITIALIZED_SUSPENSE_BOUNDARY_ID,
            rootSegmentID: -1,
            parentFlushed: false,
            pendingTasks: 0,
            forceClientRender: false,
            completedSegments: [],
            byteSize: 0,
            fallbackAbortableTasks,
            errorDigest: null
          };
        }
        function createTask(request, node, blockedBoundary, blockedSegment, abortSet, legacyContext, context, treeContext) {
          request.allPendingTasks++;
          if (blockedBoundary === null) {
            request.pendingRootTasks++;
          } else {
            blockedBoundary.pendingTasks++;
          }
          var task = {
            node,
            ping: function() {
              return pingTask(request, task);
            },
            blockedBoundary,
            blockedSegment,
            abortSet,
            legacyContext,
            context,
            treeContext
          };
          {
            task.componentStack = null;
          }
          abortSet.add(task);
          return task;
        }
        function createPendingSegment(request, index, boundary, formatContext, lastPushedText, textEmbedded) {
          return {
            status: PENDING,
            id: -1,
            // lazily assigned later
            index,
            parentFlushed: false,
            chunks: [],
            children: [],
            formatContext,
            boundary,
            lastPushedText,
            textEmbedded
          };
        }
        var currentTaskInDEV = null;
        function getCurrentStackInDEV() {
          {
            if (currentTaskInDEV === null || currentTaskInDEV.componentStack === null) {
              return "";
            }
            return getStackByComponentStackNode(currentTaskInDEV.componentStack);
          }
        }
        function pushBuiltInComponentStackInDEV(task, type) {
          {
            task.componentStack = {
              tag: 0,
              parent: task.componentStack,
              type
            };
          }
        }
        function pushFunctionComponentStackInDEV(task, type) {
          {
            task.componentStack = {
              tag: 1,
              parent: task.componentStack,
              type
            };
          }
        }
        function pushClassComponentStackInDEV(task, type) {
          {
            task.componentStack = {
              tag: 2,
              parent: task.componentStack,
              type
            };
          }
        }
        function popComponentStackInDEV(task) {
          {
            if (task.componentStack === null) {
              error("Unexpectedly popped too many stack frames. This is a bug in React.");
            } else {
              task.componentStack = task.componentStack.parent;
            }
          }
        }
        var lastBoundaryErrorComponentStackDev = null;
        function captureBoundaryErrorDetailsDev(boundary, error2) {
          {
            var errorMessage;
            if (typeof error2 === "string") {
              errorMessage = error2;
            } else if (error2 && typeof error2.message === "string") {
              errorMessage = error2.message;
            } else {
              errorMessage = String(error2);
            }
            var errorComponentStack = lastBoundaryErrorComponentStackDev || getCurrentStackInDEV();
            lastBoundaryErrorComponentStackDev = null;
            boundary.errorMessage = errorMessage;
            boundary.errorComponentStack = errorComponentStack;
          }
        }
        function logRecoverableError(request, error2) {
          var errorDigest = request.onError(error2);
          if (errorDigest != null && typeof errorDigest !== "string") {
            throw new Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof errorDigest + '" instead');
          }
          return errorDigest;
        }
        function fatalError(request, error2) {
          var onShellError = request.onShellError;
          onShellError(error2);
          var onFatalError = request.onFatalError;
          onFatalError(error2);
          if (request.destination !== null) {
            request.status = CLOSED;
            closeWithError(request.destination, error2);
          } else {
            request.status = CLOSING;
            request.fatalError = error2;
          }
        }
        function renderSuspenseBoundary(request, task, props) {
          pushBuiltInComponentStackInDEV(task, "Suspense");
          var parentBoundary = task.blockedBoundary;
          var parentSegment = task.blockedSegment;
          var fallback = props.fallback;
          var content = props.children;
          var fallbackAbortSet = /* @__PURE__ */ new Set();
          var newBoundary = createSuspenseBoundary(request, fallbackAbortSet);
          var insertionIndex = parentSegment.chunks.length;
          var boundarySegment = createPendingSegment(
            request,
            insertionIndex,
            newBoundary,
            parentSegment.formatContext,
            // boundaries never require text embedding at their edges because comment nodes bound them
            false,
            false
          );
          parentSegment.children.push(boundarySegment);
          parentSegment.lastPushedText = false;
          var contentRootSegment = createPendingSegment(
            request,
            0,
            null,
            parentSegment.formatContext,
            // boundaries never require text embedding at their edges because comment nodes bound them
            false,
            false
          );
          contentRootSegment.parentFlushed = true;
          task.blockedBoundary = newBoundary;
          task.blockedSegment = contentRootSegment;
          try {
            renderNode(request, task, content);
            pushSegmentFinale(contentRootSegment.chunks, request.responseState, contentRootSegment.lastPushedText, contentRootSegment.textEmbedded);
            contentRootSegment.status = COMPLETED;
            queueCompletedSegment(newBoundary, contentRootSegment);
            if (newBoundary.pendingTasks === 0) {
              popComponentStackInDEV(task);
              return;
            }
          } catch (error2) {
            contentRootSegment.status = ERRORED;
            newBoundary.forceClientRender = true;
            newBoundary.errorDigest = logRecoverableError(request, error2);
            {
              captureBoundaryErrorDetailsDev(newBoundary, error2);
            }
          } finally {
            task.blockedBoundary = parentBoundary;
            task.blockedSegment = parentSegment;
          }
          var suspendedFallbackTask = createTask(request, fallback, parentBoundary, boundarySegment, fallbackAbortSet, task.legacyContext, task.context, task.treeContext);
          {
            suspendedFallbackTask.componentStack = task.componentStack;
          }
          request.pingedTasks.push(suspendedFallbackTask);
          popComponentStackInDEV(task);
        }
        function renderHostElement(request, task, type, props) {
          pushBuiltInComponentStackInDEV(task, type);
          var segment = task.blockedSegment;
          var children = pushStartInstance(segment.chunks, type, props, request.responseState, segment.formatContext);
          segment.lastPushedText = false;
          var prevContext = segment.formatContext;
          segment.formatContext = getChildFormatContext(prevContext, type, props);
          renderNode(request, task, children);
          segment.formatContext = prevContext;
          pushEndInstance(segment.chunks, type);
          segment.lastPushedText = false;
          popComponentStackInDEV(task);
        }
        function shouldConstruct$1(Component) {
          return Component.prototype && Component.prototype.isReactComponent;
        }
        function renderWithHooks(request, task, Component, props, secondArg) {
          var componentIdentity = {};
          prepareToUseHooks(task, componentIdentity);
          var result = Component(props, secondArg);
          return finishHooks(Component, props, result, secondArg);
        }
        function finishClassComponent(request, task, instance, Component, props) {
          var nextChildren = instance.render();
          {
            if (instance.props !== props) {
              if (!didWarnAboutReassigningProps) {
                error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromType(Component) || "a component");
              }
              didWarnAboutReassigningProps = true;
            }
          }
          {
            var childContextTypes = Component.childContextTypes;
            if (childContextTypes !== null && childContextTypes !== void 0) {
              var previousContext = task.legacyContext;
              var mergedContext = processChildContext(instance, Component, previousContext, childContextTypes);
              task.legacyContext = mergedContext;
              renderNodeDestructive(request, task, nextChildren);
              task.legacyContext = previousContext;
              return;
            }
          }
          renderNodeDestructive(request, task, nextChildren);
        }
        function renderClassComponent(request, task, Component, props) {
          pushClassComponentStackInDEV(task, Component);
          var maskedContext = getMaskedContext(Component, task.legacyContext);
          var instance = constructClassInstance(Component, props, maskedContext);
          mountClassInstance(instance, Component, props, maskedContext);
          finishClassComponent(request, task, instance, Component, props);
          popComponentStackInDEV(task);
        }
        var didWarnAboutBadClass = {};
        var didWarnAboutModulePatternComponent = {};
        var didWarnAboutContextTypeOnFunctionComponent = {};
        var didWarnAboutGetDerivedStateOnFunctionComponent = {};
        var didWarnAboutReassigningProps = false;
        var didWarnAboutGenerators = false;
        var didWarnAboutMaps = false;
        var hasWarnedAboutUsingContextAsConsumer = false;
        function renderIndeterminateComponent(request, task, Component, props) {
          var legacyContext;
          {
            legacyContext = getMaskedContext(Component, task.legacyContext);
          }
          pushFunctionComponentStackInDEV(task, Component);
          {
            if (Component.prototype && typeof Component.prototype.render === "function") {
              var componentName = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutBadClass[componentName]) {
                error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
                didWarnAboutBadClass[componentName] = true;
              }
            }
          }
          var value = renderWithHooks(request, task, Component, props, legacyContext);
          var hasId = checkDidRenderIdHook();
          {
            if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0) {
              var _componentName = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutModulePatternComponent[_componentName]) {
                error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
                didWarnAboutModulePatternComponent[_componentName] = true;
              }
            }
          }
          if (
            // Run these checks in production only if the flag is off.
            // Eventually we'll delete this branch altogether.
            typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0
          ) {
            {
              var _componentName2 = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutModulePatternComponent[_componentName2]) {
                error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
                didWarnAboutModulePatternComponent[_componentName2] = true;
              }
            }
            mountClassInstance(value, Component, props, legacyContext);
            finishClassComponent(request, task, value, Component, props);
          } else {
            {
              validateFunctionComponentInDev(Component);
            }
            if (hasId) {
              var prevTreeContext = task.treeContext;
              var totalChildren = 1;
              var index = 0;
              task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);
              try {
                renderNodeDestructive(request, task, value);
              } finally {
                task.treeContext = prevTreeContext;
              }
            } else {
              renderNodeDestructive(request, task, value);
            }
          }
          popComponentStackInDEV(task);
        }
        function validateFunctionComponentInDev(Component) {
          {
            if (Component) {
              if (Component.childContextTypes) {
                error("%s(...): childContextTypes cannot be defined on a function component.", Component.displayName || Component.name || "Component");
              }
            }
            if (typeof Component.getDerivedStateFromProps === "function") {
              var _componentName3 = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
                error("%s: Function components do not support getDerivedStateFromProps.", _componentName3);
                didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
              }
            }
            if (typeof Component.contextType === "object" && Component.contextType !== null) {
              var _componentName4 = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
                error("%s: Function components do not support contextType.", _componentName4);
                didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
              }
            }
          }
        }
        function resolveDefaultProps(Component, baseProps) {
          if (Component && Component.defaultProps) {
            var props = assign({}, baseProps);
            var defaultProps = Component.defaultProps;
            for (var propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
            return props;
          }
          return baseProps;
        }
        function renderForwardRef(request, task, type, props, ref) {
          pushFunctionComponentStackInDEV(task, type.render);
          var children = renderWithHooks(request, task, type.render, props, ref);
          var hasId = checkDidRenderIdHook();
          if (hasId) {
            var prevTreeContext = task.treeContext;
            var totalChildren = 1;
            var index = 0;
            task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);
            try {
              renderNodeDestructive(request, task, children);
            } finally {
              task.treeContext = prevTreeContext;
            }
          } else {
            renderNodeDestructive(request, task, children);
          }
          popComponentStackInDEV(task);
        }
        function renderMemo(request, task, type, props, ref) {
          var innerType = type.type;
          var resolvedProps = resolveDefaultProps(innerType, props);
          renderElement(request, task, innerType, resolvedProps, ref);
        }
        function renderContextConsumer(request, task, context, props) {
          {
            if (context._context === void 0) {
              if (context !== context.Consumer) {
                if (!hasWarnedAboutUsingContextAsConsumer) {
                  hasWarnedAboutUsingContextAsConsumer = true;
                  error("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                }
              }
            } else {
              context = context._context;
            }
          }
          var render = props.children;
          {
            if (typeof render !== "function") {
              error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
            }
          }
          var newValue = readContext(context);
          var newChildren = render(newValue);
          renderNodeDestructive(request, task, newChildren);
        }
        function renderContextProvider(request, task, type, props) {
          var context = type._context;
          var value = props.value;
          var children = props.children;
          var prevSnapshot;
          {
            prevSnapshot = task.context;
          }
          task.context = pushProvider(context, value);
          renderNodeDestructive(request, task, children);
          task.context = popProvider(context);
          {
            if (prevSnapshot !== task.context) {
              error("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
            }
          }
        }
        function renderLazyComponent(request, task, lazyComponent, props, ref) {
          pushBuiltInComponentStackInDEV(task, "Lazy");
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;
          var Component = init(payload);
          var resolvedProps = resolveDefaultProps(Component, props);
          renderElement(request, task, Component, resolvedProps, ref);
          popComponentStackInDEV(task);
        }
        function renderElement(request, task, type, props, ref) {
          if (typeof type === "function") {
            if (shouldConstruct$1(type)) {
              renderClassComponent(request, task, type, props);
              return;
            } else {
              renderIndeterminateComponent(request, task, type, props);
              return;
            }
          }
          if (typeof type === "string") {
            renderHostElement(request, task, type, props);
            return;
          }
          switch (type) {
            case REACT_LEGACY_HIDDEN_TYPE:
            case REACT_DEBUG_TRACING_MODE_TYPE:
            case REACT_STRICT_MODE_TYPE:
            case REACT_PROFILER_TYPE:
            case REACT_FRAGMENT_TYPE: {
              renderNodeDestructive(request, task, props.children);
              return;
            }
            case REACT_SUSPENSE_LIST_TYPE: {
              pushBuiltInComponentStackInDEV(task, "SuspenseList");
              renderNodeDestructive(request, task, props.children);
              popComponentStackInDEV(task);
              return;
            }
            case REACT_SCOPE_TYPE: {
              throw new Error("ReactDOMServer does not yet support scope components.");
            }
            case REACT_SUSPENSE_TYPE: {
              {
                renderSuspenseBoundary(request, task, props);
              }
              return;
            }
          }
          if (typeof type === "object" && type !== null) {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE: {
                renderForwardRef(request, task, type, props, ref);
                return;
              }
              case REACT_MEMO_TYPE: {
                renderMemo(request, task, type, props, ref);
                return;
              }
              case REACT_PROVIDER_TYPE: {
                renderContextProvider(request, task, type, props);
                return;
              }
              case REACT_CONTEXT_TYPE: {
                renderContextConsumer(request, task, type, props);
                return;
              }
              case REACT_LAZY_TYPE: {
                renderLazyComponent(request, task, type, props);
                return;
              }
            }
          }
          var info = "";
          {
            if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
          }
          throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (type == null ? type : typeof type) + "." + info));
        }
        function validateIterable(iterable, iteratorFn) {
          {
            if (typeof Symbol === "function" && // $FlowFixMe Flow doesn't know about toStringTag
            iterable[Symbol.toStringTag] === "Generator") {
              if (!didWarnAboutGenerators) {
                error("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
              }
              didWarnAboutGenerators = true;
            }
            if (iterable.entries === iteratorFn) {
              if (!didWarnAboutMaps) {
                error("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
              }
              didWarnAboutMaps = true;
            }
          }
        }
        function renderNodeDestructive(request, task, node) {
          {
            try {
              return renderNodeDestructiveImpl(request, task, node);
            } catch (x) {
              if (typeof x === "object" && x !== null && typeof x.then === "function")
                ;
              else {
                lastBoundaryErrorComponentStackDev = lastBoundaryErrorComponentStackDev !== null ? lastBoundaryErrorComponentStackDev : getCurrentStackInDEV();
              }
              throw x;
            }
          }
        }
        function renderNodeDestructiveImpl(request, task, node) {
          task.node = node;
          if (typeof node === "object" && node !== null) {
            switch (node.$$typeof) {
              case REACT_ELEMENT_TYPE: {
                var element = node;
                var type = element.type;
                var props = element.props;
                var ref = element.ref;
                renderElement(request, task, type, props, ref);
                return;
              }
              case REACT_PORTAL_TYPE:
                throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
              case REACT_LAZY_TYPE: {
                var lazyNode = node;
                var payload = lazyNode._payload;
                var init = lazyNode._init;
                var resolvedNode;
                {
                  try {
                    resolvedNode = init(payload);
                  } catch (x) {
                    if (typeof x === "object" && x !== null && typeof x.then === "function") {
                      pushBuiltInComponentStackInDEV(task, "Lazy");
                    }
                    throw x;
                  }
                }
                renderNodeDestructive(request, task, resolvedNode);
                return;
              }
            }
            if (isArray(node)) {
              renderChildrenArray(request, task, node);
              return;
            }
            var iteratorFn = getIteratorFn(node);
            if (iteratorFn) {
              {
                validateIterable(node, iteratorFn);
              }
              var iterator = iteratorFn.call(node);
              if (iterator) {
                var step = iterator.next();
                if (!step.done) {
                  var children = [];
                  do {
                    children.push(step.value);
                    step = iterator.next();
                  } while (!step.done);
                  renderChildrenArray(request, task, children);
                  return;
                }
                return;
              }
            }
            var childString = Object.prototype.toString.call(node);
            throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(node).join(", ") + "}" : childString) + "). If you meant to render a collection of children, use an array instead.");
          }
          if (typeof node === "string") {
            var segment = task.blockedSegment;
            segment.lastPushedText = pushTextInstance(task.blockedSegment.chunks, node, request.responseState, segment.lastPushedText);
            return;
          }
          if (typeof node === "number") {
            var _segment = task.blockedSegment;
            _segment.lastPushedText = pushTextInstance(task.blockedSegment.chunks, "" + node, request.responseState, _segment.lastPushedText);
            return;
          }
          {
            if (typeof node === "function") {
              error("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
            }
          }
        }
        function renderChildrenArray(request, task, children) {
          var totalChildren = children.length;
          for (var i = 0; i < totalChildren; i++) {
            var prevTreeContext = task.treeContext;
            task.treeContext = pushTreeContext(prevTreeContext, totalChildren, i);
            try {
              renderNode(request, task, children[i]);
            } finally {
              task.treeContext = prevTreeContext;
            }
          }
        }
        function spawnNewSuspendedTask(request, task, x) {
          var segment = task.blockedSegment;
          var insertionIndex = segment.chunks.length;
          var newSegment = createPendingSegment(
            request,
            insertionIndex,
            null,
            segment.formatContext,
            // Adopt the parent segment's leading text embed
            segment.lastPushedText,
            // Assume we are text embedded at the trailing edge
            true
          );
          segment.children.push(newSegment);
          segment.lastPushedText = false;
          var newTask = createTask(request, task.node, task.blockedBoundary, newSegment, task.abortSet, task.legacyContext, task.context, task.treeContext);
          {
            if (task.componentStack !== null) {
              newTask.componentStack = task.componentStack.parent;
            }
          }
          var ping = newTask.ping;
          x.then(ping, ping);
        }
        function renderNode(request, task, node) {
          var previousFormatContext = task.blockedSegment.formatContext;
          var previousLegacyContext = task.legacyContext;
          var previousContext = task.context;
          var previousComponentStack = null;
          {
            previousComponentStack = task.componentStack;
          }
          try {
            return renderNodeDestructive(request, task, node);
          } catch (x) {
            resetHooksState();
            if (typeof x === "object" && x !== null && typeof x.then === "function") {
              spawnNewSuspendedTask(request, task, x);
              task.blockedSegment.formatContext = previousFormatContext;
              task.legacyContext = previousLegacyContext;
              task.context = previousContext;
              switchContext(previousContext);
              {
                task.componentStack = previousComponentStack;
              }
              return;
            } else {
              task.blockedSegment.formatContext = previousFormatContext;
              task.legacyContext = previousLegacyContext;
              task.context = previousContext;
              switchContext(previousContext);
              {
                task.componentStack = previousComponentStack;
              }
              throw x;
            }
          }
        }
        function erroredTask(request, boundary, segment, error2) {
          var errorDigest = logRecoverableError(request, error2);
          if (boundary === null) {
            fatalError(request, error2);
          } else {
            boundary.pendingTasks--;
            if (!boundary.forceClientRender) {
              boundary.forceClientRender = true;
              boundary.errorDigest = errorDigest;
              {
                captureBoundaryErrorDetailsDev(boundary, error2);
              }
              if (boundary.parentFlushed) {
                request.clientRenderedBoundaries.push(boundary);
              }
            }
          }
          request.allPendingTasks--;
          if (request.allPendingTasks === 0) {
            var onAllReady = request.onAllReady;
            onAllReady();
          }
        }
        function abortTaskSoft(task) {
          var request = this;
          var boundary = task.blockedBoundary;
          var segment = task.blockedSegment;
          segment.status = ABORTED;
          finishedTask(request, boundary, segment);
        }
        function abortTask(task, request, reason) {
          var boundary = task.blockedBoundary;
          var segment = task.blockedSegment;
          segment.status = ABORTED;
          if (boundary === null) {
            request.allPendingTasks--;
            if (request.status !== CLOSED) {
              request.status = CLOSED;
              if (request.destination !== null) {
                close(request.destination);
              }
            }
          } else {
            boundary.pendingTasks--;
            if (!boundary.forceClientRender) {
              boundary.forceClientRender = true;
              var _error = reason === void 0 ? new Error("The render was aborted by the server without a reason.") : reason;
              boundary.errorDigest = request.onError(_error);
              {
                var errorPrefix = "The server did not finish this Suspense boundary: ";
                if (_error && typeof _error.message === "string") {
                  _error = errorPrefix + _error.message;
                } else {
                  _error = errorPrefix + String(_error);
                }
                var previousTaskInDev = currentTaskInDEV;
                currentTaskInDEV = task;
                try {
                  captureBoundaryErrorDetailsDev(boundary, _error);
                } finally {
                  currentTaskInDEV = previousTaskInDev;
                }
              }
              if (boundary.parentFlushed) {
                request.clientRenderedBoundaries.push(boundary);
              }
            }
            boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
              return abortTask(fallbackTask, request, reason);
            });
            boundary.fallbackAbortableTasks.clear();
            request.allPendingTasks--;
            if (request.allPendingTasks === 0) {
              var onAllReady = request.onAllReady;
              onAllReady();
            }
          }
        }
        function queueCompletedSegment(boundary, segment) {
          if (segment.chunks.length === 0 && segment.children.length === 1 && segment.children[0].boundary === null) {
            var childSegment = segment.children[0];
            childSegment.id = segment.id;
            childSegment.parentFlushed = true;
            if (childSegment.status === COMPLETED) {
              queueCompletedSegment(boundary, childSegment);
            }
          } else {
            var completedSegments = boundary.completedSegments;
            completedSegments.push(segment);
          }
        }
        function finishedTask(request, boundary, segment) {
          if (boundary === null) {
            if (segment.parentFlushed) {
              if (request.completedRootSegment !== null) {
                throw new Error("There can only be one root segment. This is a bug in React.");
              }
              request.completedRootSegment = segment;
            }
            request.pendingRootTasks--;
            if (request.pendingRootTasks === 0) {
              request.onShellError = noop$1;
              var onShellReady = request.onShellReady;
              onShellReady();
            }
          } else {
            boundary.pendingTasks--;
            if (boundary.forceClientRender)
              ;
            else if (boundary.pendingTasks === 0) {
              if (segment.parentFlushed) {
                if (segment.status === COMPLETED) {
                  queueCompletedSegment(boundary, segment);
                }
              }
              if (boundary.parentFlushed) {
                request.completedBoundaries.push(boundary);
              }
              boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request);
              boundary.fallbackAbortableTasks.clear();
            } else {
              if (segment.parentFlushed) {
                if (segment.status === COMPLETED) {
                  queueCompletedSegment(boundary, segment);
                  var completedSegments = boundary.completedSegments;
                  if (completedSegments.length === 1) {
                    if (boundary.parentFlushed) {
                      request.partialBoundaries.push(boundary);
                    }
                  }
                }
              }
            }
          }
          request.allPendingTasks--;
          if (request.allPendingTasks === 0) {
            var onAllReady = request.onAllReady;
            onAllReady();
          }
        }
        function retryTask(request, task) {
          var segment = task.blockedSegment;
          if (segment.status !== PENDING) {
            return;
          }
          switchContext(task.context);
          var prevTaskInDEV = null;
          {
            prevTaskInDEV = currentTaskInDEV;
            currentTaskInDEV = task;
          }
          try {
            renderNodeDestructive(request, task, task.node);
            pushSegmentFinale(segment.chunks, request.responseState, segment.lastPushedText, segment.textEmbedded);
            task.abortSet.delete(task);
            segment.status = COMPLETED;
            finishedTask(request, task.blockedBoundary, segment);
          } catch (x) {
            resetHooksState();
            if (typeof x === "object" && x !== null && typeof x.then === "function") {
              var ping = task.ping;
              x.then(ping, ping);
            } else {
              task.abortSet.delete(task);
              segment.status = ERRORED;
              erroredTask(request, task.blockedBoundary, segment, x);
            }
          } finally {
            {
              currentTaskInDEV = prevTaskInDEV;
            }
          }
        }
        function performWork(request) {
          if (request.status === CLOSED) {
            return;
          }
          var prevContext = getActiveContext();
          var prevDispatcher = ReactCurrentDispatcher$1.current;
          ReactCurrentDispatcher$1.current = Dispatcher;
          var prevGetCurrentStackImpl;
          {
            prevGetCurrentStackImpl = ReactDebugCurrentFrame$1.getCurrentStack;
            ReactDebugCurrentFrame$1.getCurrentStack = getCurrentStackInDEV;
          }
          var prevResponseState = currentResponseState;
          setCurrentResponseState(request.responseState);
          try {
            var pingedTasks = request.pingedTasks;
            var i;
            for (i = 0; i < pingedTasks.length; i++) {
              var task = pingedTasks[i];
              retryTask(request, task);
            }
            pingedTasks.splice(0, i);
            if (request.destination !== null) {
              flushCompletedQueues(request, request.destination);
            }
          } catch (error2) {
            logRecoverableError(request, error2);
            fatalError(request, error2);
          } finally {
            setCurrentResponseState(prevResponseState);
            ReactCurrentDispatcher$1.current = prevDispatcher;
            {
              ReactDebugCurrentFrame$1.getCurrentStack = prevGetCurrentStackImpl;
            }
            if (prevDispatcher === Dispatcher) {
              switchContext(prevContext);
            }
          }
        }
        function flushSubtree(request, destination, segment) {
          segment.parentFlushed = true;
          switch (segment.status) {
            case PENDING: {
              var segmentID = segment.id = request.nextSegmentId++;
              segment.lastPushedText = false;
              segment.textEmbedded = false;
              return writePlaceholder(destination, request.responseState, segmentID);
            }
            case COMPLETED: {
              segment.status = FLUSHED;
              var r = true;
              var chunks = segment.chunks;
              var chunkIdx = 0;
              var children = segment.children;
              for (var childIdx = 0; childIdx < children.length; childIdx++) {
                var nextChild = children[childIdx];
                for (; chunkIdx < nextChild.index; chunkIdx++) {
                  writeChunk(destination, chunks[chunkIdx]);
                }
                r = flushSegment(request, destination, nextChild);
              }
              for (; chunkIdx < chunks.length - 1; chunkIdx++) {
                writeChunk(destination, chunks[chunkIdx]);
              }
              if (chunkIdx < chunks.length) {
                r = writeChunkAndReturn(destination, chunks[chunkIdx]);
              }
              return r;
            }
            default: {
              throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
            }
          }
        }
        function flushSegment(request, destination, segment) {
          var boundary = segment.boundary;
          if (boundary === null) {
            return flushSubtree(request, destination, segment);
          }
          boundary.parentFlushed = true;
          if (boundary.forceClientRender) {
            writeStartClientRenderedSuspenseBoundary(destination, request.responseState, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
            flushSubtree(request, destination, segment);
            return writeEndClientRenderedSuspenseBoundary(destination, request.responseState);
          } else if (boundary.pendingTasks > 0) {
            boundary.rootSegmentID = request.nextSegmentId++;
            if (boundary.completedSegments.length > 0) {
              request.partialBoundaries.push(boundary);
            }
            var id = boundary.id = assignSuspenseBoundaryID(request.responseState);
            writeStartPendingSuspenseBoundary(destination, request.responseState, id);
            flushSubtree(request, destination, segment);
            return writeEndPendingSuspenseBoundary(destination, request.responseState);
          } else if (boundary.byteSize > request.progressiveChunkSize) {
            boundary.rootSegmentID = request.nextSegmentId++;
            request.completedBoundaries.push(boundary);
            writeStartPendingSuspenseBoundary(destination, request.responseState, boundary.id);
            flushSubtree(request, destination, segment);
            return writeEndPendingSuspenseBoundary(destination, request.responseState);
          } else {
            writeStartCompletedSuspenseBoundary(destination, request.responseState);
            var completedSegments = boundary.completedSegments;
            if (completedSegments.length !== 1) {
              throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
            }
            var contentSegment = completedSegments[0];
            flushSegment(request, destination, contentSegment);
            return writeEndCompletedSuspenseBoundary(destination, request.responseState);
          }
        }
        function flushClientRenderedBoundary(request, destination, boundary) {
          return writeClientRenderBoundaryInstruction(destination, request.responseState, boundary.id, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
        }
        function flushSegmentContainer(request, destination, segment) {
          writeStartSegment(destination, request.responseState, segment.formatContext, segment.id);
          flushSegment(request, destination, segment);
          return writeEndSegment(destination, segment.formatContext);
        }
        function flushCompletedBoundary(request, destination, boundary) {
          var completedSegments = boundary.completedSegments;
          var i = 0;
          for (; i < completedSegments.length; i++) {
            var segment = completedSegments[i];
            flushPartiallyCompletedSegment(request, destination, boundary, segment);
          }
          completedSegments.length = 0;
          return writeCompletedBoundaryInstruction(destination, request.responseState, boundary.id, boundary.rootSegmentID);
        }
        function flushPartialBoundary(request, destination, boundary) {
          var completedSegments = boundary.completedSegments;
          var i = 0;
          for (; i < completedSegments.length; i++) {
            var segment = completedSegments[i];
            if (!flushPartiallyCompletedSegment(request, destination, boundary, segment)) {
              i++;
              completedSegments.splice(0, i);
              return false;
            }
          }
          completedSegments.splice(0, i);
          return true;
        }
        function flushPartiallyCompletedSegment(request, destination, boundary, segment) {
          if (segment.status === FLUSHED) {
            return true;
          }
          var segmentID = segment.id;
          if (segmentID === -1) {
            var rootSegmentID = segment.id = boundary.rootSegmentID;
            if (rootSegmentID === -1) {
              throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
            }
            return flushSegmentContainer(request, destination, segment);
          } else {
            flushSegmentContainer(request, destination, segment);
            return writeCompletedSegmentInstruction(destination, request.responseState, segmentID);
          }
        }
        function flushCompletedQueues(request, destination) {
          beginWriting();
          try {
            var completedRootSegment = request.completedRootSegment;
            if (completedRootSegment !== null && request.pendingRootTasks === 0) {
              flushSegment(request, destination, completedRootSegment);
              request.completedRootSegment = null;
              writeCompletedRoot(destination, request.responseState);
            }
            var clientRenderedBoundaries = request.clientRenderedBoundaries;
            var i;
            for (i = 0; i < clientRenderedBoundaries.length; i++) {
              var boundary = clientRenderedBoundaries[i];
              if (!flushClientRenderedBoundary(request, destination, boundary)) {
                request.destination = null;
                i++;
                clientRenderedBoundaries.splice(0, i);
                return;
              }
            }
            clientRenderedBoundaries.splice(0, i);
            var completedBoundaries = request.completedBoundaries;
            for (i = 0; i < completedBoundaries.length; i++) {
              var _boundary = completedBoundaries[i];
              if (!flushCompletedBoundary(request, destination, _boundary)) {
                request.destination = null;
                i++;
                completedBoundaries.splice(0, i);
                return;
              }
            }
            completedBoundaries.splice(0, i);
            completeWriting(destination);
            beginWriting(destination);
            var partialBoundaries = request.partialBoundaries;
            for (i = 0; i < partialBoundaries.length; i++) {
              var _boundary2 = partialBoundaries[i];
              if (!flushPartialBoundary(request, destination, _boundary2)) {
                request.destination = null;
                i++;
                partialBoundaries.splice(0, i);
                return;
              }
            }
            partialBoundaries.splice(0, i);
            var largeBoundaries = request.completedBoundaries;
            for (i = 0; i < largeBoundaries.length; i++) {
              var _boundary3 = largeBoundaries[i];
              if (!flushCompletedBoundary(request, destination, _boundary3)) {
                request.destination = null;
                i++;
                largeBoundaries.splice(0, i);
                return;
              }
            }
            largeBoundaries.splice(0, i);
          } finally {
            completeWriting(destination);
            if (request.allPendingTasks === 0 && request.pingedTasks.length === 0 && request.clientRenderedBoundaries.length === 0 && request.completedBoundaries.length === 0) {
              {
                if (request.abortableTasks.size !== 0) {
                  error("There was still abortable task at the root when we closed. This is a bug in React.");
                }
              }
              close(destination);
            }
          }
        }
        function startWork(request) {
          scheduleWork(function() {
            return performWork(request);
          });
        }
        function startFlowing(request, destination) {
          if (request.status === CLOSING) {
            request.status = CLOSED;
            closeWithError(destination, request.fatalError);
            return;
          }
          if (request.status === CLOSED) {
            return;
          }
          if (request.destination !== null) {
            return;
          }
          request.destination = destination;
          try {
            flushCompletedQueues(request, destination);
          } catch (error2) {
            logRecoverableError(request, error2);
            fatalError(request, error2);
          }
        }
        function abort(request, reason) {
          try {
            var abortableTasks = request.abortableTasks;
            abortableTasks.forEach(function(task) {
              return abortTask(task, request, reason);
            });
            abortableTasks.clear();
            if (request.destination !== null) {
              flushCompletedQueues(request, request.destination);
            }
          } catch (error2) {
            logRecoverableError(request, error2);
            fatalError(request, error2);
          }
        }
        function renderToReadableStream(children, options) {
          return new Promise(function(resolve, reject) {
            var onFatalError;
            var onAllReady;
            var allReady = new Promise(function(res, rej) {
              onAllReady = res;
              onFatalError = rej;
            });
            function onShellReady() {
              var stream = new ReadableStream(
                {
                  type: "bytes",
                  pull: function(controller) {
                    startFlowing(request, controller);
                  },
                  cancel: function(reason) {
                    abort(request);
                  }
                },
                // $FlowFixMe size() methods are not allowed on byte streams.
                {
                  highWaterMark: 0
                }
              );
              stream.allReady = allReady;
              resolve(stream);
            }
            function onShellError(error2) {
              allReady.catch(function() {
              });
              reject(error2);
            }
            var request = createRequest(children, createResponseState(options ? options.identifierPrefix : void 0, options ? options.nonce : void 0, options ? options.bootstrapScriptContent : void 0, options ? options.bootstrapScripts : void 0, options ? options.bootstrapModules : void 0), createRootFormatContext(options ? options.namespaceURI : void 0), options ? options.progressiveChunkSize : void 0, options ? options.onError : void 0, onAllReady, onShellReady, onShellError, onFatalError);
            if (options && options.signal) {
              var signal = options.signal;
              var listener = function() {
                abort(request, signal.reason);
                signal.removeEventListener("abort", listener);
              };
              signal.addEventListener("abort", listener);
            }
            startWork(request);
          });
        }
        exports.renderToReadableStream = renderToReadableStream;
        exports.version = ReactVersion;
      })();
    }
  }
});

// ../../node_modules/react-dom/server.browser.js
var require_server_browser = __commonJS({
  "../../node_modules/react-dom/server.browser.js"(exports) {
    "use strict";
    var l;
    var s;
    if (false) {
      l = null;
      s = null;
    } else {
      l = require_react_dom_server_legacy_browser_development();
      s = require_react_dom_server_browser_development();
    }
    exports.version = l.version;
    exports.renderToString = l.renderToString;
    exports.renderToStaticMarkup = l.renderToStaticMarkup;
    exports.renderToNodeStream = l.renderToNodeStream;
    exports.renderToStaticNodeStream = l.renderToStaticNodeStream;
    exports.renderToReadableStream = s.renderToReadableStream;
  }
});

// ../../node_modules/@lifeomic/react-vis-network/lib/util/svg.js
var require_svg = __commonJS({
  "../../node_modules/@lifeomic/react-vis-network/lib/util/svg.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.reactToSvgImageUrl = void 0;
    var _server = _interopRequireDefault(require_server_browser());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var svgToDataURI = function svgToDataURI2(svg) {
      return "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svg);
    };
    var reactToSvgImageUrl = function reactToSvgImageUrl2(element) {
      var svgString = _server.default.renderToStaticMarkup(element);
      return svgToDataURI(svgString);
    };
    exports.reactToSvgImageUrl = reactToSvgImageUrl;
  }
});

// ../../node_modules/@lifeomic/react-vis-network/lib/util/RafDebouncer.js
var require_RafDebouncer = __commonJS({
  "../../node_modules/@lifeomic/react-vis-network/lib/util/RafDebouncer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var RafDebouncer = function() {
      function RafDebouncer2() {
        _classCallCheck(this, RafDebouncer2);
        _defineProperty(this, "rafTimeout", null);
      }
      _createClass(RafDebouncer2, [{
        key: "requestAnimationFrame",
        value: function(_requestAnimationFrame) {
          function requestAnimationFrame2(_x) {
            return _requestAnimationFrame.apply(this, arguments);
          }
          requestAnimationFrame2.toString = function() {
            return _requestAnimationFrame.toString();
          };
          return requestAnimationFrame2;
        }(function(callback) {
          if (this.rafTimeout) {
            cancelAnimationFrame(this.rafTimeout);
          }
          this.rafTimeout = requestAnimationFrame(callback);
        })
      }]);
      return RafDebouncer2;
    }();
    exports.default = RafDebouncer;
  }
});

// ../../node_modules/@lifeomic/react-vis-network/lib/Module.js
var require_Module = __commonJS({
  "../../node_modules/@lifeomic/react-vis-network/lib/Module.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _react = _interopRequireWildcard(require_react());
    var _propTypes = _interopRequireDefault(require_prop_types());
    var _svg = require_svg();
    var _RafDebouncer = _interopRequireDefault(require_RafDebouncer());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};
              if (desc.get || desc.set) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    function _typeof(obj) {
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys.forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      }
      return target;
    }
    function _objectWithoutProperties(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose(source, excluded);
      var key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++) {
          key = sourceSymbolKeys[i];
          if (excluded.indexOf(key) >= 0)
            continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key))
            continue;
          target[key] = source[key];
        }
      }
      return target;
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var style = {
      position: "absolute",
      display: "none",
      top: 0,
      left: 0
    };
    var VisModule = function(_PureComponent) {
      _inherits(VisModule2, _PureComponent);
      function VisModule2() {
        var _getPrototypeOf2;
        var _this;
        _classCallCheck(this, VisModule2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(VisModule2)).call.apply(_getPrototypeOf2, [this].concat(args)));
        _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "decoratorRef", _react.default.createRef());
        _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "drawDebouncer", new _RafDebouncer.default());
        _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "hasAfterDrawingListener", false);
        _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "updateNetwork", function() {
          var _this$props = _this.props, decorator = _this$props.decorator, network = _this$props.vis.network;
          if (!_this.hasAfterDrawingListener && decorator) {
            _this.hasAfterDrawingListener = true;
            network.on("afterDrawing", _this.moveDecorator);
          }
          if (_this.hasAfterDrawingListener && !decorator) {
            network.off("afterDrawing", _this.moveDecorator);
            _this.hasAfterDrawingListener = false;
          }
          if (_this.hasAfterDrawingListener) {
            _this.moveDecorator();
          }
        });
        _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "moveDecorator", function() {
          return _this.drawDebouncer.requestAnimationFrame(function() {
            var _this$props2 = _this.props, id = _this$props2.id, network = _this$props2.vis.network;
            var decoratorEl = _this.decoratorRef.current;
            if (network && decoratorEl) {
              var _network$getPositions = network.getPositions([id]), canvasPosition = _network$getPositions[id];
              if (canvasPosition) {
                var boundingBox = network.getBoundingBox(id);
                var topCenterPosition = {
                  x: canvasPosition.x,
                  y: boundingBox.top
                };
                var domPosition = network.canvasToDOM(topCenterPosition);
                decoratorEl.style.display = "block";
                var _decoratorEl$getBound = decoratorEl.getBoundingClientRect(), height = _decoratorEl$getBound.height, width = _decoratorEl$getBound.width;
                var x = domPosition.x - width / 2;
                var y = domPosition.y - height;
                decoratorEl.style.transform = "translateX(".concat(x, "px) translateY(").concat(y, "px)");
              }
            }
          });
        });
        return _this;
      }
      _createClass(VisModule2, [{
        key: "updateDecorator",
        value: function updateDecorator() {
          var _this$props3 = this.props, network = _this$props3.vis.network, decorator = _this$props3.decorator;
          if (!network) {
            return;
          }
          if (!this.hasAfterDrawingListener && decorator) {
            this.hasAfterDrawingListener = true;
            network.on("afterDrawing", this.moveDecorator);
          }
          if (this.hasAfterDrawingListener && !decorator) {
            network.off("afterDrawing", this.moveDecorator);
            this.hasAfterDrawingListener = false;
          }
          if (this.hasAfterDrawingListener) {
            this.moveDecorator();
          }
        }
      }, {
        key: "getModuleOptions",
        value: function getModuleOptions() {
          var _this$props4 = this.props, component = _this$props4.component, entityOptions = _objectWithoutProperties(_this$props4, ["component"]);
          var options = _objectSpread({}, entityOptions);
          if (component) {
            options.image = (0, _svg.reactToSvgImageUrl)(component(this.props));
            options.shape = options.shape || "image";
          }
          return options;
        }
      }, {
        key: "componentDidMount",
        value: function componentDidMount() {
          this.updateDecorator();
        }
      }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate() {
          this.updateDecorator();
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          var network = this.props.vis.network;
          if (this.hasAfterDrawingListener) {
            network.off("afterDrawing", this.moveDecorator);
          }
        }
      }, {
        key: "render",
        value: function render() {
          var _this$props5 = this.props, decorator = _this$props5.decorator, network = _this$props5.vis.network;
          return _react.default.createElement(_react.default.Fragment, null, network && decorator && _react.default.createElement("div", {
            style,
            ref: this.decoratorRef
          }, decorator(this.props)));
        }
      }]);
      return VisModule2;
    }(_react.PureComponent);
    exports.default = VisModule;
    _defineProperty(VisModule, "propTypes", {
      id: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number]).isRequired,
      component: _propTypes.default.oneOfType([_propTypes.default.bool, _propTypes.default.func]),
      decorator: _propTypes.default.oneOfType([_propTypes.default.bool, _propTypes.default.func]),
      vis: _propTypes.default.shape({
        nodes: _propTypes.default.object.isRequired,
        edges: _propTypes.default.object.isRequired,
        network: _propTypes.default.object
      })
    });
  }
});

// ../../node_modules/@lifeomic/react-vis-network/lib/Node.js
var require_Node = __commonJS({
  "../../node_modules/@lifeomic/react-vis-network/lib/Node.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _Module2 = _interopRequireDefault(require_Module());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _typeof(obj) {
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var VisNode = function(_Module) {
      _inherits(VisNode2, _Module);
      function VisNode2() {
        _classCallCheck(this, VisNode2);
        return _possibleConstructorReturn(this, _getPrototypeOf(VisNode2).apply(this, arguments));
      }
      _createClass(VisNode2, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          _get(_getPrototypeOf(VisNode2.prototype), "componentDidMount", this).call(this);
          var nodes = this.props.vis.nodes;
          var config = this.getModuleOptions();
          nodes.add(config);
        }
      }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate() {
          _get(_getPrototypeOf(VisNode2.prototype), "componentDidUpdate", this).call(this);
          var nodes = this.props.vis.nodes;
          var config = this.getModuleOptions();
          nodes.update(config);
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          _get(_getPrototypeOf(VisNode2.prototype), "componentWillUnmount", this).call(this);
          var _this$props = this.props, nodes = _this$props.vis.nodes, id = _this$props.id;
          nodes.remove(id);
        }
      }]);
      return VisNode2;
    }(_Module2.default);
    exports.default = VisNode;
  }
});

// ../../node_modules/@lifeomic/react-vis-network/lib/Edge.js
var require_Edge = __commonJS({
  "../../node_modules/@lifeomic/react-vis-network/lib/Edge.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _Module2 = _interopRequireDefault(require_Module());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _typeof(obj) {
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var VisEdge = function(_Module) {
      _inherits(VisEdge2, _Module);
      function VisEdge2() {
        _classCallCheck(this, VisEdge2);
        return _possibleConstructorReturn(this, _getPrototypeOf(VisEdge2).apply(this, arguments));
      }
      _createClass(VisEdge2, [{
        key: "updateDecorator",
        value: function updateDecorator() {
        }
      }, {
        key: "componentDidMount",
        value: function componentDidMount() {
          _get(_getPrototypeOf(VisEdge2.prototype), "componentDidMount", this).call(this);
          var edges = this.props.vis.edges;
          var config = this.getModuleOptions();
          edges.add(config);
        }
      }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate() {
          _get(_getPrototypeOf(VisEdge2.prototype), "componentDidUpdate", this).call(this);
          var edges = this.props.vis.edges;
          var config = this.getModuleOptions();
          edges.update(config);
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          _get(_getPrototypeOf(VisEdge2.prototype), "componentWillUnmount", this).call(this);
          var _this$props = this.props, edges = _this$props.vis.edges, id = _this$props.id;
          edges.remove(id);
        }
      }]);
      return VisEdge2;
    }(_Module2.default);
    exports.default = VisEdge;
  }
});

// ../../node_modules/@lifeomic/react-vis-network/lib/Cluster.js
var require_Cluster = __commonJS({
  "../../node_modules/@lifeomic/react-vis-network/lib/Cluster.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _Module2 = _interopRequireDefault(require_Module());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _typeof(obj) {
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var Cluster = function(_Module) {
      _inherits(Cluster2, _Module);
      function Cluster2() {
        var _getPrototypeOf2;
        var _this;
        _classCallCheck(this, Cluster2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Cluster2)).call.apply(_getPrototypeOf2, [this].concat(args)));
        _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "updateCluster", function() {
          var _this$props = _this.props, id = _this$props.id, network = _this$props.vis.network;
          if (!network) {
            return;
          }
          var config = _this.getModuleOptions();
          if (network.isCluster(id)) {
            network.clustering.updateClusteredNode(id, config);
          } else {
            network.clustering.cluster({
              joinCondition: function joinCondition(node) {
                return config.nodes.indexOf(node.id) > -1;
              },
              clusterNodeProperties: config
            });
          }
        });
        return _this;
      }
      _createClass(Cluster2, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          _get(_getPrototypeOf(Cluster2.prototype), "componentDidMount", this).call(this);
          this.updateCluster();
        }
      }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate() {
          _get(_getPrototypeOf(Cluster2.prototype), "componentDidUpdate", this).call(this);
          this.updateCluster();
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          _get(_getPrototypeOf(Cluster2.prototype), "componentWillUnmount", this).call(this);
          var _this$props2 = this.props, id = _this$props2.id, network = _this$props2.vis.network;
          if (network.clustering && network.isCluster(id)) {
            network.openCluster(id);
          }
        }
      }]);
      return Cluster2;
    }(_Module2.default);
    exports.default = Cluster;
  }
});

// ../../node_modules/@lifeomic/react-vis-network/lib/ClusterByConnection.js
var require_ClusterByConnection = __commonJS({
  "../../node_modules/@lifeomic/react-vis-network/lib/ClusterByConnection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _Module2 = _interopRequireDefault(require_Module());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _typeof(obj) {
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target2, property2, receiver2) {
          var base = _superPropBase(target2, property2);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property2);
          if (desc.get) {
            return desc.get.call(receiver2);
          }
          return desc.value;
        };
      }
      return _get(target, property, receiver || target);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var ClusterByConnection = function(_Module) {
      _inherits(ClusterByConnection2, _Module);
      function ClusterByConnection2() {
        var _getPrototypeOf2;
        var _this;
        _classCallCheck(this, ClusterByConnection2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ClusterByConnection2)).call.apply(_getPrototypeOf2, [this].concat(args)));
        _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "updateCluster", function() {
          var _this$props = _this.props, id = _this$props.id, rootNodeId = _this$props.rootNodeId, network = _this$props.vis.network;
          if (!network) {
            return;
          }
          var config = _this.getModuleOptions();
          if (network.findNode(id).length > 0) {
            network.clustering.updateClusteredNode(id, config);
          } else {
            network.clusterByConnection(rootNodeId, {
              clusterNodeProperties: config
            });
          }
        });
        return _this;
      }
      _createClass(ClusterByConnection2, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          _get(_getPrototypeOf(ClusterByConnection2.prototype), "componentDidMount", this).call(this);
          this.updateCluster();
        }
      }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate() {
          _get(_getPrototypeOf(ClusterByConnection2.prototype), "componentDidUpdate", this).call(this);
          this.updateCluster();
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          _get(_getPrototypeOf(ClusterByConnection2.prototype), "componentWillUnmount", this).call(this);
          var _this$props2 = this.props, id = _this$props2.id, network = _this$props2.vis.network;
          if (network.clustering) {
            network.openCluster(id);
          }
        }
      }]);
      return ClusterByConnection2;
    }(_Module2.default);
    exports.default = ClusterByConnection;
  }
});

// ../../node_modules/@lifeomic/react-vis-network/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/@lifeomic/react-vis-network/lib/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "Network", {
      enumerable: true,
      get: function get() {
        return _Network.default;
      }
    });
    Object.defineProperty(exports, "Node", {
      enumerable: true,
      get: function get() {
        return _Node.default;
      }
    });
    Object.defineProperty(exports, "Edge", {
      enumerable: true,
      get: function get() {
        return _Edge.default;
      }
    });
    Object.defineProperty(exports, "Cluster", {
      enumerable: true,
      get: function get() {
        return _Cluster.default;
      }
    });
    Object.defineProperty(exports, "ClusterByConnection", {
      enumerable: true,
      get: function get() {
        return _ClusterByConnection.default;
      }
    });
    Object.defineProperty(exports, "Module", {
      enumerable: true,
      get: function get() {
        return _Module.default;
      }
    });
    Object.defineProperty(exports, "reactToSvgImageUrl", {
      enumerable: true,
      get: function get() {
        return _svg.reactToSvgImageUrl;
      }
    });
    var _Network = _interopRequireDefault(require_Network());
    var _Node = _interopRequireDefault(require_Node());
    var _Edge = _interopRequireDefault(require_Edge());
    var _Cluster = _interopRequireDefault(require_Cluster());
    var _ClusterByConnection = _interopRequireDefault(require_ClusterByConnection());
    var _Module = _interopRequireDefault(require_Module());
    var _svg = require_svg();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
  }
});
export default require_lib();
/*! Bundled license information:

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)

vis/dist/vis-network.min.js:
  (**
   * vis.js
   * https://github.com/almende/vis
   *
   * A dynamic, browser-based visualization library.
   *
   * @version 4.21.0
   * @date    2017-10-12
   *
   * @license
   * Copyright (C) 2011-2017 Almende B.V, http://almende.com
   *
   * Vis.js is dual licensed under both
   *
   * * The Apache 2.0 License
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * and
   *
   * * The MIT License
   *   http://opensource.org/licenses/MIT
   *
   * Vis.js may be distributed under either license.
   *)
  (*! Hammer.JS - v2.0.7 - 2016-04-22
  * http://hammerjs.github.io/
  *
  * Copyright (c) 2016 Jorik Tangelder;
  * Licensed under the MIT license *)

react-dom/cjs/react-dom-server-legacy.browser.development.js:
  (**
   * @license React
   * react-dom-server-legacy.browser.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom-server.browser.development.js:
  (**
   * @license React
   * react-dom-server.browser.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=@lifeomic_react-vis-network.js.map
